<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>粉笔灰杂谈</title>
  <meta name="description" content="关于产品、技术、商业的一些见解，顺便记录一下自己的生活感悟和读书笔记。">
  <script src="/static/jquery-3.1.1.min.js"></script>
  <link rel="stylesheet" href="/static/bootstrap.min.css">
  <link rel="stylesheet" href="/static/font-awesome-4.6.3/css/font-awesome.min.css">
  <script src="/static/bootstrap.min.js"></script>
  <!-- should put bootstrap before main style sheet, otherwise it't hard to override  -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="canonical" href="http://localhost:4000/">
  <link rel="alternate" type="application/rss+xml" title="粉笔灰杂谈" href="http://localhost:4000/feed.xml">
</head>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86140592-1', 'auto');
  ga('send', 'pageview');

</script>

  <body>

    <header class="site-header">
  <div class="container" style="text-align:center">
    <div class="navbar" style="margin-bottom:0;border:0">
    <ul class="navbar-nav nav header-nav">
    <li><a href="/index.html" class="button">首页</a></li>
      <li><a href="/category/技术" class="button">技术</a></li>
      <li><a href="/category/产品商业" class="button">产品商业</a></li>
      <li><a href="/category/随记" class="button">随记</a></li>
    </ul>
    </div>
  </div>

</header>
<div class="clearfix">


    <div class="page-content">
      <div class="container" style="padding-left:0;padding-right:0;">
        <div class="row" style="margin-bottom:30px">
  <div class="home col-md-8">
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/06/27/JavaAgent-Instrument.html">JavaAgent-Instrument</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Jun 27, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/06/27/JavaAgent-Instrument.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>Java</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<p>DDos Distributed Denial of Service
https://www.jianshu.com/p/e7a5fdc67b8f</p>

<p>攻击方式叫做crossing site scripting,跨站脚本，简称XSS
https://www.jianshu.com/p/38d61b0c0a17
这种攻击方式叫做cross site request forgery,跨站请求伪造CSRF
https://www.jianshu.com/p/2de97b609a44</p>

<p>SQL注入 https://www.cnblogs.com/myseries/p/10821372.html</p>

<p>常见六大Web安全攻防解析
https://www.cnblogs.com/fundebug/p/details-about-6-web-security.html</p>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/06/27/JavaAgent-Instrument.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E9%9A%8F%E8%AE%B0/2020/06/25/MckinseyMethodology.html">麦肯锡方法</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Jun 25, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E9%9A%8F%E8%AE%B0/2020/06/25/MckinseyMethodology.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>方法论</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<h4 id="专业主义">专业主义</h4>
<ul>
  <li>结构化的思维，清晰的语言，具有责任心同时又敢于发表不同意见的知识精英以及专业化的目标，
  这都是会让一个组织及其人员发挥其最大的潜力。</li>
</ul>

<h4 id="主要方法论">主要方法论</h4>
<ul>
  <li>以事实为基础</li>
  <li>严格的结构化（MESE原则，相互独立完全穷尽）</li>
  <li>以假设为导向，寻找关键路径。（错误的路径某种程度上会促使你发现正确路径）</li>
</ul>

<h4 id="作用力量分析框架">作用力量分析框架</h4>
<ul>
  <li>客户的供应商</li>
  <li>顾客</li>
  <li>竞争对手</li>
  <li>可能的替代产品</li>
</ul>

<h4 id="重要原则">重要原则</h4>
<ul>
  <li>80/20原则</li>
  <li>电梯测试</li>
  <li>界定你的前提，这是把你由问题引向解决方案的路线图</li>
  <li>为你的情况说明”预先布线”以确保成功的秘密</li>
  <li>为什么问题不会永远是问题？
    <ul>
      <li>不要去重新发明轮子，尽可能寻找现有的或类似的解决方案</li>
      <li>每个客户都是独一无二的，不存在一刀切的解决办法</li>
      <li>不要让事实去适应你的解决办法</li>
      <li>确保你的解决办法适合你的客户</li>
      <li>有时候你必须让解决方案来找你。（收集事实，描述清楚问题，解决方案就会自己找上门来）</li>
      <li>遇到”不可能解决”的难题怎么办？
        <ul>
          <li>重新定义问题</li>
          <li>锲而不舍实施看似不是最优方案的方案，最终有可能就是最优</li>
          <li>解决政治问题</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>成功地进行收集信息的谈话的7个要诀
    <ul>
      <li>让被访者的上司安排会面</li>
      <li>两个人一起进行走访</li>
      <li>倾听，不要指导</li>
      <li>复述、复述、复述</li>
      <li>采用旁敲侧击的方式</li>
      <li>不要问太多</li>
      <li>采用考伦波的策略。（电梯间提问，此时大家都放松了，可能能得到意想不到的答案）</li>
    </ul>
  </li>
  <li>高效沟通的3个构成要素
    <ul>
      <li>简洁、完整、结构</li>
    </ul>
  </li>
  <li>如何应付”讨债鬼”似的团队成员或难以打交道的同事。
    <ul>
      <li>清除或转化</li>
    </ul>
  </li>
  <li>如何让整个企业接受你的方案。
    <ul>
      <li>让客户参与，并从上到下的沟通实施</li>
    </ul>
  </li>
</ul>

<h4 id="如何保持团队士气">如何保持团队士气</h4>
<ul>
  <li>把握团队温度</li>
  <li>掌握稳定的过程</li>
  <li>让团队明白为什么他们要干正在干的事情</li>
  <li>以尊重对待你的团队</li>
  <li>把队友当成人来了解</li>
  <li>耐心坚持</li>
</ul>

      </div>
      <div style="height:50px;">
	<a href="/%E9%9A%8F%E8%AE%B0/2020/06/25/MckinseyMethodology.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E4%BA%A7%E5%93%81%E5%95%86%E4%B8%9A/2020/06/22/SaaS%E4%B8%9A%E5%8A%A1.html">SaaS业务分析</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Jun 22, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E4%BA%A7%E5%93%81%E5%95%86%E4%B8%9A/2020/06/22/SaaS%E4%B8%9A%E5%8A%A1.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>toB</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<h4 id="中国saas的增长困境">中国SaaS的增长困境</h4>
<ul>
  <li>SaaS的收入模式是订阅模式，而订阅收入的衡量指标是所谓的NDR（Net Dollar Retention），也就是收入的净留存。
  NDR的计算公式为：NDR=(beginningrevenue+upgrades-downgrades-churn)/beginning revenue</li>
  <li>SaaS销售员的首要任务不是成交，而是找到可合作的优质客户，其次的责任才是成交。</li>
  <li>销售员这个角色，在SaaS公司应该被定义为播种者，而非收割者。
改变培训导向和调整提成制度。引导价值成交，树立SaaS的销售业绩导向。</li>
  <li>ARR是annual recurring revenue的缩写</li>
  <li><a href="https://news.futunn.com/market/125247">https://news.futunn.com/market/125247</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/101133113">https://zhuanlan.zhihu.com/p/101133113</a></li>
</ul>


      </div>
      <div style="height:50px;">
	<a href="/%E4%BA%A7%E5%93%81%E5%95%86%E4%B8%9A/2020/06/22/SaaS%E4%B8%9A%E5%8A%A1.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E4%BA%A7%E5%93%81%E5%95%86%E4%B8%9A/2020/06/22/UserProfile.html">用户画像</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Jun 22, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E4%BA%A7%E5%93%81%E5%95%86%E4%B8%9A/2020/06/22/UserProfile.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>用户</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<h4 id="核心">核心</h4>
<ul>
  <li>用户画像体系，有这一篇就够了 <a href="https://mp.weixin.qq.com/s/WbBUX2g_XhGXrH9xtv0i2Q">https://mp.weixin.qq.com/s/WbBUX2g_XhGXrH9xtv0i2Q</a></li>
  <li>用户画像原理、技术选型及架构实现 <a href="https://blog.csdn.net/SecondLieutenant/article/details/81153565">https://blog.csdn.net/SecondLieutenant/article/details/81153565</a></li>
</ul>

<h4 id="用户画像概述">用户画像概述</h4>
<ul>
  <li>用户画像根本目的就是寻找目标客户、优化产品设计，指导运营策略，分析业务场景和完善业务形态。</li>
  <li>不同的企业做用户画像有不同的战略目的，广告公司做用户画像是为精准广告服务，电商做用户画像是为用户购买更多商品，内容平台做用户画像是推荐用户更感兴趣的内容提升流量再变现，金融行业做用户画像是为了寻找到目标客户的同时做好风险的控制。</li>
</ul>

<h4 id="画像维度">画像维度</h4>
<ul>
  <li>特征：
    <ul>
      <li>人口统计：性别、年龄、教育</li>
      <li>社会属性：家庭、社交、职业</li>
    </ul>
  </li>
  <li>行为：
    <ul>
      <li>使用行为：手机使用、电脑类型、套餐使用、套餐余额</li>
      <li>消费行为：购买力、购买频次、购买渠道、额度、信用等级</li>
    </ul>
  </li>
  <li>需求
    <ul>
      <li>偏好属性：兴趣爱好、品牌爱好、产品爱好、网购偏好、支付偏好、价格偏好</li>
      <li>潜在需求：</li>
    </ul>
  </li>
</ul>

<h4 id="指标体系">指标体系</h4>
<ul>
  <li>用户属性维度</li>
  <li>用户行为维度</li>
  <li>用户消费维度</li>
  <li>风险控制维度</li>
  <li>社交属性维度</li>
</ul>

<h4 id="画像之静态标签动态标签">画像之静态标签、动态标签</h4>
<ul>
  <li>静态画像：实时性弱、覆盖广、粒度粗</li>
  <li>动态画像：
    <ul>
      <li>一般建立兴趣模型，更加实时并且动态</li>
      <li>用户行为可疑结构为5W（What/Who/When/Where/Why)</li>
      <li>时效性非常敏感</li>
      <li>在空间上，不同应用领域侧重点不同，营销领域更侧重消费习惯，推荐领域更侧重喜好</li>
    </ul>
  </li>
</ul>

<h4 id="画像之标签结构化程度">画像之标签结构化程度</h4>
<ul>
  <li>结构化标签体系，定向广告平台采用的结构化标签体系</li>
  <li>半结构化标签体系，在用于效果广告时，标签设计的灵活性大大提高了。标签体系是不是规整，就不那么重要了，只要有效果就行。</li>
  <li>非结构化标签体系，非结构化，就是各个标签就事论事，各自反应各自的用户兴趣，彼此之间并无层级关系，也很难组织成规整的树状结构。非结构化标签的典型例子，是搜索广告里用的关键词。还有Facebook用的用户兴趣词</li>
  <li>例如
    <ul>
      <li>汽车行业的标签体系大体应该是：价格—&gt;车型—&gt;品牌</li>
      <li>游戏行业：按照类别、游戏素材、游戏厂商等等。游戏的用户决策过程总体上令人难以捉摸，这是因为它有点儿电影、音乐一样的艺术性特质。而人们对艺术的喜爱，并不是理性的，也就难以总结规律。</li>
      <li>电商行业的实际做法大家都看到了，基本上不依靠分类，完全以“单品+个性化推荐”的方法构建和使用标签体系。</li>
    </ul>
  </li>
</ul>

<h4 id="画像之应用">画像之应用</h4>
<ul>
  <li>精准营销：根据历史用户特征，分析产品的潜在用户和用户的潜在需求，针对特定群体，利用短信、邮件等方式进行营销。</li>
  <li>用户统计：根据用户的属性、行为特征对用户进行分类后，统计不同特征下的用户数量、分布；分析不同用户画像群体的分布特征。</li>
  <li>数据挖掘：以用户画像为基础构建推荐系统、搜索引擎、广告投放系统，提升服务精准度。</li>
  <li>服务产品：对产品进行用户画像，对产品进行受众分析，更透彻地理解用户使用产品的心理动机和行为习惯，完善产品运营，提升服务质量。</li>
  <li>行业报告&amp;用户研究：通过用户画像分析可以了解行业动态，比如人群消费习惯、消费偏好分析、不同地域品类消费差异分析</li>
</ul>

<h4 id="画像之reachctr曲线">画像之reach/CTR曲线</h4>
<ul>
  <li>reach：该标签占总用户比例</li>
  <li>CTR：点击率</li>
  <li>reach越大，一般情况CTR会小</li>
</ul>

<h4 id="用户画像架构图">用户画像架构图</h4>
<p><img src="/img/user_profile.jpg" width="600px" /></p>

<h4 id="用户画像后台标签">用户画像后台标签</h4>
<p><img src="/img/user_profile_admin.jpg" width="600px" /></p>

<h4 id="用户业务标签">用户业务标签</h4>
<p><img src="/img/user_profile_tags.jpg" width="600px" /></p>

<h4 id="会员理论模型">会员理论模型</h4>
<ul>
  <li>会员体系模型：AIPL
    <ul>
      <li>Awareness潜客：内容运营、宣传吸引、新手任务、了解产品</li>
      <li>Interest粉丝：社会新闻、热点话题、习惯养成、积分积累</li>
      <li>Purchase会员：日常任务、促销活动、品牌影响力、共同利益</li>
      <li>Loyalty超级会员：专属特权、心理诉求、社群活动、1V1维护</li>
    </ul>
  </li>
  <li>会员体系模型：RFM
    <ul>
      <li>R(Recency)近度：距某节点最近的一次消费</li>
      <li>F(Frequency)频度：消费频次</li>
      <li>M (Monetary)额度：消费金额
<img src="/img/RFM.jpg" width="600px" /></li>
    </ul>
  </li>
  <li>会员体系模型：AARRR
    <ul>
      <li>Acquisition（获取用户）：关注PV、UV、CPC、点击转化率、注册量、注册率、获客成本CAC</li>
      <li>Activation（提高活跃度）：关注登陆量、激活转化率、活跃度指标</li>
      <li>Retention（提高留存率）：关注留存率、复购率、人均购买次数、召回率</li>
      <li>Revenue（获取收入）：关注获客成本、顾客终身价值、营销ROI</li>
      <li>Referral（传播）：关注邀请量、激活量、邀请激活率、传播系数</li>
    </ul>
  </li>
  <li>鱼塘理论
    <ul>
      <li>养鱼、抓潜、成交、追销、形成自己的鱼塘</li>
    </ul>
  </li>
  <li>Hook模型概念
    <ul>
      <li>触发Trigger：即诱发用户采取行动，进入系统的契机。这是上瘾模型的第一步，也是最关键一步，如果这步不能引起用户的兴趣，后续就无从谈起。</li>
      <li>行动Action：按照斯坦福大学B.J.Fogg博士的Behavior Model理论，B=MAT，即行动（Behavior）=动机（Motivation）+能力（Ability）+触发器（Trigger）。</li>
      <li>多变的酬赏Variable Reward：当行为被触发之后，接下来就需要给用户一些酬赏进行持续刺激，以培养对他们对产品的使用习惯。酬赏简单来说就是产品带给用户的满足感，但为什么要强调“多变”呢？
  据行为学研究，人们对产品的满足感会随着时间的推移逐渐降低，即使现阶段用户因为产品解决了某方面问题而产生依赖，但市面上的新产品层出不穷，要想不被淘汰，“无穷的多变性”是保持产品神秘感和吸引力，维持用户长期兴趣的关键。</li>
      <li>投入Investment：有研究表明，用户对某个产品投入时间精力的多寡与对这个产品的依赖程度成正比，就像免费东西你不会珍惜，而氪过金的游戏或服务反而会不断充值一样。已经享受酬赏的用户，想要他们对你的产品彻底“上瘾”，最后一步就是要让他们有所投入。</li>
    </ul>
  </li>
  <li>《疯传》STEPPS原则
    <ul>
      <li>社交货币（Social Currency）：我们会共享那些能让我们显得更优秀的事情</li>
      <li>诱因（Triggers）：顶尖的记忆，风口浪尖的提醒</li>
      <li>情绪（Emotion）：当我们关心时，我们回去分享</li>
      <li>公共性（Public）：构建可视的、正面的事物</li>
      <li>实用价值（Practical Value）：如果有用，人们会情不自禁地分享</li>
      <li>故事（Stories）：好故事就意味着成功了一般，好故事都有翅膀</li>
    </ul>
  </li>
</ul>

<h4 id="参考">参考</h4>
<ul>
  <li>用户研究：如何做用户画像分析 <a href="https://www.jianshu.com/p/440c30383bec">https://www.jianshu.com/p/440c30383bec</a></li>
  <li>什么是用户画像和标签？ <a href="http://www.woshipm.com/user-research/1083807.html">http://www.woshipm.com/user-research/1083807.html</a></li>
  <li>结构化标签、非结构化标签及reach/CTR曲线 <a href="http://www.woshipm.com/user-research/436269.html">http://www.woshipm.com/user-research/436269.html</a></li>
  <li>电商案例、金融案例（用户画像标签体系——从零开始搭建实时用户画像） <a href="https://cloud.tencent.com/developer/column/79937">https://cloud.tencent.com/developer/column/79937</a></li>
  <li>航空公司案例、证券案例、打车公司案例 <a href="https://www.zhihu.com/question/302695500">https://www.zhihu.com/question/302695500</a></li>
  <li>从阿里会员解读会员体系建设 <a href="https://zhuanlan.zhihu.com/p/88738148">https://zhuanlan.zhihu.com/p/88738148</a></li>
  <li>用户画像10大误区 <a href="https://mp.weixin.qq.com/s/Nzxa7stwvLhDvfSzqkCeAA">https://mp.weixin.qq.com/s/Nzxa7stwvLhDvfSzqkCeAA</a></li>
  <li>1号店案例 <a href="https://mp.weixin.qq.com/s/gtwdjTS9x_0xGKWEgo1zxg">https://mp.weixin.qq.com/s/gtwdjTS9x_0xGKWEgo1zxg</a></li>
  <li>Qunar用户画像构建策略及应用实践 <a href="https://blog.csdn.net/xiaoshunzi111/article/details/53170658">https://blog.csdn.net/xiaoshunzi111/article/details/53170658</a></li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>携程</td>
          <td>手把手教你用大数据打造用户画像 <a href="https://blog.csdn.net/chenjunji123456/article/details/54966633">https://blog.csdn.net/chenjunji123456/article/details/54966633</a></td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>《用户画像：方法论与工程化解决方案》<a href="https://www.jianshu.com/p/94dadecc162b">https://www.jianshu.com/p/94dadecc162b</a></li>
  <li>汽车之家如何构建用户画像 <a href="https://mp.weixin.qq.com/s/ihvcpS0Mb5G1_-EzrhEOBw">https://mp.weixin.qq.com/s/ihvcpS0Mb5G1_-EzrhEOBw</a></li>
</ul>

      </div>
      <div style="height:50px;">
	<a href="/%E4%BA%A7%E5%93%81%E5%95%86%E4%B8%9A/2020/06/22/UserProfile.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/06/17/DotDot2.html">DotDot2</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Jun 17, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/06/17/DotDot2.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>数据结构与算法</span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>BigData</span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>分布式</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<h4 id="基础">基础</h4>
<ol>
  <li>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线
程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入(CAS)的开销，看起
来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级
锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换
ThreadID 的时候依赖一次 CAS 原子指令(由于一旦出现多线程竞争的情况就必须撤销偏向锁，所
以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗)。上面说过，轻
量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进
一步提高性能。</li>
  <li>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要
在子线程结束后再结束，这时候就要用到 join() 方法。</li>
</ol>

<h4 id="spring">Spring</h4>
<ul>
  <li>ApplicationContext
    <ol>
      <li>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身;ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层 的 BeanFactory。</li>
      <li>HierarchicalBeanFactory 父子级联，父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器; 通过 HierarchicalBeanFactory 接口， Spring 的 IoC 容器可以建立父子层级关联的容器体系，子 容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实 现了很多功能，比如在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久 层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务 层和持久层的 Bean 则看不到展现层的 Bean。</li>
      <li>ClassPathXmlApplicationContext -&gt; ApplicationContext -&gt; HierarchicalBeanFactory/ListableBeanFactory</li>
      <li>ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要 的方法: refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下 文的能力。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动 的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用 close()则可关闭应用 上下文。</li>
      <li>WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的 路径中装载配置文件完成初始化工作。从 WebApplicationContext 中可以获得 ServletContext 的引用，整个 Web 应用上下文对象将作为属性放置到 ServletContext 中，以便 Web 应用环境可以访问 Spring 应用上下文。</li>
    </ol>
  </li>
  <li>Bean的Scope
    <ol>
      <li>singleton</li>
      <li>prototype，每次都创建（对有状态的 bean 使用 prototype 作用域，而对无状态的 bean 使用 singleton 作用域。）</li>
      <li>request：一次request一个实例</li>
      <li>session：一个session一个实例</li>
      <li>global Session:在一个全局的 Http Session 中，容器会返回该 Bean 的同一个实例，仅在 使用 portlet context 时有效。</li>
    </ol>
  </li>
  <li>Bean的生命周期
    <ol>
      <li>根据scope，实例化</li>
      <li>设置熟悉</li>
      <li>postProcessBeforeInitialization</li>
      <li>afterPropertiesSet</li>
      <li>postProcessAfterInitialization</li>
      <li>Done
```xml</li>
    </ol>
  </li>
</ul>
<bean class="" init-method="初始化方法" destroy-method="销毁方法" />

<p>```</p>
<ul>
  <li>依赖注入
    <ul>
      <li>构造器注入</li>
      <li>setter 方法注入</li>
      <li>接口注入</li>
    </ul>
  </li>
  <li>
    <p>IOC:把对象的创建、初始化、销毁交给 spring 来管理，而不是由开发者控制，实现控制反转。</p>
  </li>
  <li>5 种不同方式的自动装配
    <ul>
      <li>no:默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。</li>
      <li>byName:通过参数名 自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。</li>
      <li>byType:通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被 设置成 byType，之后容器试图匹配、装配和该 bean 的属性具有相同类型的 bean。如果有多个 bean 符合条件，则抛出错误。</li>
      <li>constructor:这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</li>
      <li>autodetect:首先尝试使用 constructor 来自动装配，如果无法工作，则使用 byType 方式</li>
    </ul>
  </li>
  <li>AOP 核心概念
    <ul>
      <li>切面(aspect):类是对物体特征的抽象，切面就是对横切关注点的抽象</li>
      <li>横切关注点:对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。</li>
      <li>连接点(joinpoint):被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。</li>
      <li>切入点(pointcut):对连接点进行拦截的定义</li>
      <li>通知(advice):所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、 异常、最终、环绕通知五类。</li>
      <li>目标对象:代理的目标对象</li>
      <li>织入(weave):将切面应用到目标对象并导致代理对象创建的过程</li>
      <li>引入(introduction):在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法 或字段。</li>
    </ul>
  </li>
  <li>MyBatis缓存
    <ul>
      <li>Mybatis 中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存 是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以 后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存 是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的 sqlsession 是可以共享的。</li>
      <li>如果两次中间出现 commit 操作 (修改、添加、删除)，本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所 以要从数据库查询，从数据库查询到再写入缓存。</li>
    </ul>
  </li>
  <li>Slf4j
slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接 口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不 能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带 的 java.util.logging.Logger 等。</li>
</ul>

<h4 id="redis分布式锁与zk分布式锁">redis分布式锁与zk分布式锁</h4>

<h4 id="zab协议4阶段">ZAB协议4阶段</h4>
<ol>
  <li>Leader election(选举阶段):节点在一开始都处于选举阶段，只要有一个节点得到超半数 节点的票数，它就可以当选准 leader。只有到达 广播阶段(broadcast) 准 leader 才会成 为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。</li>
  <li>Discovery(发现阶段-接受提议、生成 epoch、接受 epoch):在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且 准 leader 生成新的 epoch，让 followers 接受，更新它们的 accepted Epoch
 一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入重新选举阶段。</li>
  <li>Synchronization(同步阶段):同步阶段主要是利用 leader 前一阶段获得的最新提议历史， 同步集群中所有的副本。只有当 大多数节点都同步完成，准 leader 才会成为真正的 leader。 follower 只会接收 zxid 比自己的 lastZxid 大的提议。</li>
  <li>Broadcast(广播阶段-leader 消息广播) Broadcast(广播阶段):到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，
    <ul>
      <li>两大阶段：让大家投票，告诉大家投票结果</li>
    </ul>
  </li>
</ol>

<h4 id="rabbitmq-4种分发策略">RabbitMq 4种分发策略</h4>
<ul>
  <li>Direct : 单Queue</li>
  <li>Fanout : 类似redis pub/sub</li>
  <li>Topic : 模糊匹配</li>
</ul>

<h4 id="hadoop-region寻址方式通过zookeepermeta">Hadoop Region寻址方式(通过zookeeper.META)</h4>
<p>第 1 步:Client 请求 ZK 获取.META.所在的 RegionServer 的地址。
第 2 步:Client 请求.META.所在的 RegionServer 获取访问数据所在的 RegionServer 地 址，client 会将.META.的相关信息 cache 下来，以便下一次快速访问。
第 3 步:Client 请求数据所在的 RegionServer，获取所需要的数据。</p>

<h4 id="hbase的写入流程">HBase的写入流程</h4>
<ul>
  <li>获取 RegionServer
第 1 步:Client 获取数据写入的 Region 所在的 RegionServer
请求写 Hlog</li>
  <li>第 2 步:请求写 Hlog, Hlog 存储在 HDFS，当 RegionServer 出现异常，需要使用 Hlog 来
恢复数据。
请求写 MemStore</li>
  <li>第 3 步:请求写 MemStore,只有当写 Hlog 和写 MemStore 都成功了才算请求写入完成。
MemStore 后续会逐渐刷到 HDFS 中。 14.1.5.2. MemStore刷盘
为了提高 Hbase 的写入性能，当写请求写入 MemStore 后，不会立即刷盘。而是会等到一 定的时候进行刷盘的操作。具体是哪些场景会触发刷盘的操作呢?总结成如下的几个场景:</li>
</ul>

<h4 id="hbase全局内存控制">HBase全局内存控制</h4>
<ol>
  <li>这个全局的参数是控制内存整体的使用情况，当所有 memstore 占整个 heap 的最大比 例的时候，会触发刷盘的操作。这个参数是 hbase.regionserver.global.memstore.upperLimit，默认为整个 heap 内存的 40%。 但这并不意味着全局内存触发的刷盘操作会将所有的 MemStore 都进行输盘，而是通过 另外一个参数 hbase.regionserver.global.memstore.lowerLimit 来控制，默认是整个 heap 内存的 35%。当 flush 到所有 memstore 占整个 heap 内存的比率为 35%的时 候，就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响，实现平滑系统负载的 目的。
MemStore 达到上限</li>
  <li>当 MemStore 的大小达到 hbase.hregion.memstore.flush.size 大小的时候会触发刷
盘，默认 128M 大小
RegionServer 的 Hlog 数量达到上限</li>
  <li>前面说到 Hlog 为了保证 Hbase 数据的一致性，那么如果 Hlog 太多的话，会导致故障 恢复的时间太长，因此 Hbase 会对 Hlog 的最大个数做限制。当达到 Hlog 的最大个数 的时候，会强制刷盘。这个参数是 hase.regionserver.max.logs，默认是 32 个。
手工触发</li>
  <li>可以通过 hbase shell 或者 java api 手工触发 flush 的操作。
关闭 RegionServer 触发</li>
  <li>在正常关闭 RegionServer 会触发刷盘的操作，全部数据刷盘后就不需要再使用 Hlog 恢
复数据。
Region 使用 HLOG 恢复完数据后触发</li>
  <li>:当 RegionServer 出现故障的时候，其上面的 Region 会迁移到其他正常的 RegionServer 上，在恢复完 Region 的数据后，会触发刷盘，当刷盘完成后才会提供给 业务访问。</li>
</ol>

<h4 id="mongodb的mapreduce">MongoDB的Map/Reduce</h4>
<ul>
  <li>Mongodb 中的 Map/reduce 主要是用来对数据进行批量处理和聚合操作。</li>
  <li>Map 和 Reduce。Map 函数调用 emit(key,value)遍历集合中所有的记录，将 key 与 value 传 给 Reduce 函数进行处理。</li>
  <li>Map 函数和 Reduce 函数是使用 Javascript 编写的，并可以通过 db.runCommand 或 mapre duce 命令来执行 MapReduce 操作。</li>
</ul>

<h4 id="raft-协议和-zab-协议区别">raft 协议和 zab 协议区别</h4>
<ul>
  <li>相同点
    <ul>
      <li>采用quorum来确定整个系统的一致性,这个quorum一般实现是集群中半数以上的服务器,  zookeeper里还提供了带权重的quorum实现.</li>
      <li>都由leader来发起写操作.</li>
      <li>都采用心跳检测存活性</li>
      <li>leader election都采用先到先得的投票方式</li>
    </ul>
  </li>
  <li>不同点
    <ul>
      <li>zab用的是epoch和count的组合来唯一表示一个值,而raft用的是term和index</li>
      <li>zab的follower在投票给一个leader之前必须和leader的日志达成一致,而raft的follower则简单地说是谁的 term 高就投票给谁</li>
      <li>raft协议的心跳是从leader到follower,而zab协议则相反</li>
      <li>raft协议数据只有单向地从leader到follower(成为leader的条件之一就是拥有最新的log),
  而 zab 协议在 discovery 阶段, 一个 prospective leader 需要将自己的 log 更新为 quorum 里面 最新的 log,然后才好在 synchronization 阶段将 quorum 里的其他机器的 log 都同步到一致.</li>
    </ul>
  </li>
</ul>

<h4 id="cyclicbarriercountdownlatchsemaphore-的用法">CyclicBarrier、CountDownLatch、Semaphore 的用法</h4>
<ul>
  <li>CountDownLatch，等多搞一</li>
  <li>CyclicBarrier，等多搞多</li>
  <li>Semaphore，8个工人5台机器</li>
</ul>

<h4 id="throwable-是-java-语言中所有错误或异常的超类下一层分为-error-和-exception">Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception</h4>
<ol>
  <li>Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</li>
  <li>Exception 又有两个分支，一个是运行时异常 RuntimeException，一个是CheckedException。</li>
</ol>

<h4 id="序列化-id">序列化 ID</h4>
<p>Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，
这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，
就可能要求在 JVM 停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。
Java 对象序列化就能够帮助我们实现该功能。
 使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装
 成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对
 象序列化不会关注类中的静态变量。
 除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，
 都会用到对象序列化。Java 序列化 API 为处理对象序列化提供了一个标准机制，该 API 简单易用。
 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个
 类的序列化 ID 是否一致(就是 private static final long serialVersionUID)</p>

<h4 id="springboot-starter">SpringBoot Starter</h4>
<ul>
  <li>其实是Java的SPI的全名为Service Provider Interfac的一种实现</li>
  <li>EnableAutoConfiguration 导入 @Import({AutoConfigurationImportSelector.class})</li>
  <li>AutoConfigurationImportSelector 从classpath中搜寻所有的META-INF/spring.factories配置文件</li>
  <li>找到org.springframework.boot.autoconfigure.EnableAutoConfiguration该key对应的其他自动配置className</li>
  <li>通过反射按照相关Conditional进行实例化</li>
  <li>如关闭数据源自动配置功能: @SpringBootApplication(exclude ={ DataSourceAutoConfiguration.class })。</li>
</ul>

<h4 id="如何在-spring-boot-启动的时候运行一些特定的代码">如何在 Spring Boot 启动的时候运行一些特定的代码?</h4>
<ul>
  <li>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一 样，它们都只提供了一个 run 方法。</li>
  <li>Spring Boot 可以通过 @PropertySource,@Value,@Environment</li>
</ul>

<h4 id="es-bulk-一次最大处理多少数据量">Es Bulk 一次最大处理多少数据量???</h4>
<p>bulk 会把将要处理的数据载入内存中，所以数据量是有限制的 最佳的数据量不是一个确定的数值，它取决于你的硬件，你的文档大小以及复杂性，你的索
引以及搜索的负载。
一般建议是 1000-5000 个文档，如果你的文档很大，可以适当减少队列,大小建议是 5-15MB，
默认不能超过 100M，可以在 es 的配置文件中修改这个值 http.max_content_length: 100mb</p>

<h4 id="es-在高并发的情况下如何保证数据线程安全问题">ES 在高并发的情况下如何保证数据线程安全问题?</h4>
<p>在读数据与写数据之间如果有其他线程进行写操作，就会出问题，es 使用版本控制才避免 这种问题
在修改数据的时候指定版本号，操作一次版本号加 1</p>

<h4 id="es-管理的工具有哪些">ES 管理的工具有哪些?</h4>
<p>BigDesk Plugin、Elasticsearch Head Plugin 、Kibana</p>

<h4 id="dubbo-服务上线怎么兼容旧版本">Dubbo 服务上线怎么兼容旧版本?</h4>
<p>可以用版本号(version)过渡，多个不同版本的服务注册到注册中心，版本号不同的服务 相互间不引用。这个和服务分组的概念有一点类似。</p>

<h4 id="dubbo-可以使用-pinpoint-和-apache-skywalkingincubator-实现分布式服务追踪-当然还有其他很多方案">Dubbo 可以使用 Pinpoint 和 Apache Skywalking(Incubator) 实现分布式服务追踪， 当然还有其他很多方案。</h4>

<h4 id="kafka-数据传输的事物定义有哪三种">Kafka 数据传输的事物定义有哪三种?</h4>
<p>数据传输的事务定义通常有以下三种级别:</p>
<ol>
  <li>最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输</li>
  <li>最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.</li>
  <li>精确的一次(Exactly once): 不会漏传输也不会重复传输,每个消息都传输被一次而且 仅仅被传输一次，这是大家所期望的</li>
</ol>

<h4 id="kafka-收到消息的-ack-机制">kafka 收到消息的 ack 机制</h4>
<p>request.required.acks 有三个值 0 1 -1
0:生产者不会等待 broker 的 ack，这个延迟最低但是存储的保证最弱当 server 挂掉的时候就 会丢数据
1:服务端会等待 ack 值 leader 副本确认接收到消息后发送 ack 但是如果 leader 挂掉后他不 确保是否复制完成新 leader 也会导致数据丢失
-1:同样在 1 的基础上 服务端会等所有的 follower 的副本受到数据后才会受到 leader 发出 的 ack，这样数据不会丢失</p>

<h4 id="kafka-more">Kafka More</h4>
<p>15.消费者负载均衡策略 ，一个消费者组中的一个分片对应一个消费者成员，他能保证每个消费者成员都能访问，如果 组中成员太多会有空闲的成员
16.数据有序 ，一个消费者组里它的内部是有序的 消费者组与消费者组之间是无序的
17.kafaka ，生产数据时数据的分组策略 生产者决定数据产生到集群的哪个 partition 中 每一条消息都是以(key，value)格式Key 是由生产者发送数据传入</p>

<h4 id="线程间共享">线程间共享</h4>
<p>线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤: 1. 首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。</p>
<ol>
  <li>然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。</li>
</ol>

<h4 id="iterater-和-listiterator-之间有什么区别">Iterater 和 ListIterator 之间有什么区别?</h4>
<p>(1)我们可以使用 Iterator 来遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。 (2)Iterator 只可以向前遍历，而 LIstIterator 可以双向遍历。
(3)ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替 换一个元素、获取前面或后面元素的索引位置。</p>

<h4 id="什么是-java-内存模型">什么是 Java 内存模型</h4>
<p>Java 内存模型定义了一种多线程访问 Java 内存的规范。Java 内存模型要完 整讲不是这里几句话能说清楚的，我简单总结一下 Java 内存模型的几部分内 容:
 1)Java 内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间 共享的变量，是存储在主内存中的，每次 Java 线程用到这些主内存中的变量 的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份
 拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中 的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 2)定义了几个原子操作，用于操作主内存和工作内存中的变量
 3)定义了 volatile 变量的使用规则 4)happens-before，即先行发生原则，定义了操作 A 必然先行发生于操作 B 的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流 后面的代码、一个释放锁 unlock 的动作一定先行发生于后面对于同一个锁进 行锁定 lock 的动作等等，只要符合这些规则，则不需要额外做同步措施，如 果某段代码不符合所有的 happens-before 规则，则这段代码一定是线程非 安全的</p>

<h4 id="mybatis-和的区别是什么">myBatis #{}和${}的区别是什么?</h4>
<p>1)#{}是预编译处理，${}是字符串替换。
2)Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值;
3)Mybatis 在处理${}时，就是把${}替换成变量的值。 4)使用#{}可以有效的防止 SQL 注入，提高系统安全性。</p>

<h4 id="35ibatis-和-mybatis-区别">35、IBatis 和 MyBatis 区别</h4>
<ul>
  <li>IBatis 里面的核心处理类交 SqlMapClient,MyBatis 里面的核心处理类叫做 SqlSession。</li>
  <li>在 sql 里面变量命名有原来的#变量# 变成了#{变量}</li>
  <li>原来的$变量$变成了${变量}</li>
  <li>原来在 sql 节点里面的 class 都换名字交 type</li>
  <li>原来的 queryForObject queryForList 变成了 selectOne selectList5)原来的别名设置在映射 文件里面放在了核心配置文件里。</li>
</ul>

<h4 id="apache-shiro">Apache Shiro</h4>
<p>Apache Shiro 是 Java 的一个安全框架。使用 shiro 可以非常容易的开发出足够好的应用，其不仅可以用在 JavaSE 环境，也可以用在 JavaEE 环境。Shiro 可以帮助我们完成:认证、授权、加密、会话管理、与 Web 集成、缓存等。
三个核心组件:Subject, SecurityManager 和 Realms.
Subject:即“当前操作用户”。但是，在 Shiro 中，Subject 这一概念并不仅仅指人，也可以是第三方进程、后台帐 户(Daemon Account)或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途， 你可以把它认为是 Shiro 的“用户”概念。
Subject 代表了当前用户的安全操作，SecurityManager 则管理所有用户的安全操作。
SecurityManager:它是 Shiro 框架的核心，典型的 Facade 模式，Shiro 通过 SecurityManager 来管理内部组 件实例，并通过它来提供安全管理的各种服务。
Realm: Realm 充当了 Shiro 与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证(登 录)和授权(访问控制)验证时，Shiro 会从应用配置的 Realm 中查找用户及其权限信息。</p>

<h4 id="使用-redis-如何设计分布式锁说一下实现思路使用-zk-可以吗如何实现这两种有什-么区别">使用 redis 如何设计分布式锁?说一下实现思路?使用 zk 可以吗?如何实现?这两种有什 么区别?</h4>
<ul>
  <li>redis:
    <ol>
      <li>线程 A setnx(上锁的对象,超时时的时间戳 t1)，如果返回 true，获得锁。</li>
      <li>线程 B 用 get 获取 t1,与当前时间戳比较,判断是是否超时,没超时 false,若超时执行第 3 步; 3.计算新的超时时间 t2,使用 getset 命令返回 t3(该值可能其他线程已经修改过),如果 t1==t3，获得锁，如果 t1!=t3 说明锁被其他线程获取了。 4.获取锁后，处理完业务逻辑，再去判断锁是否超时，如果没超时删除锁，如果已超时， 不用处理(防止删除其他线程的锁)。</li>
    </ol>
  </li>
  <li>zk:
    <ol>
      <li>客户端对某个方法加锁时，在 zk 上的与该方法对应的指定节点的目录下，生成一个唯一 的瞬时有序节点 node1; 2.客户端获取该路径下所有已经创建的子节点，如果发现自己创建的 node1 的序号是最小 的，就认为这个客户端获得了锁。</li>
      <li>如果发现 node1 不是最小的，则监听比自己创建节点序号小的最大的节点，进入等待。</li>
      <li>获取锁后，处理完逻辑，删除自己创建的 node1 即可。 区别:zk 性能差一些，开销大，实现简单。</li>
    </ol>
  </li>
</ul>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/06/17/DotDot2.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    

    <div style="text-align:center">
    
    <div class="pagination">
      

      
      
      <a href="" class="button current-page-button">1</a>
      
      
      
      <a href="/page2" class="button page-button">2</a>
      
      
      
      <a href="/page3" class="button page-button">3</a>
      
      
      
      <a href="/page4" class="button page-button">4</a>
      
      
      
      <a href="/page5" class="button page-button">5</a>
      
      
      
      <a href="/page6" class="button page-button">6</a>
      
      
      
      <a href="/page7" class="button page-button">7</a>
      
      
      
      <a href="/page8" class="button page-button">8</a>
      
      
      
      <a href="/page9" class="button page-button">9</a>
      
      
      
      <a href="/page10" class="button page-button">10</a>
      
      
      
      <a href="/page11" class="button page-button">11</a>
      
      
      
      <a href="/page12" class="button page-button">12</a>
      
      

      
      <a href="/page2" class="button page-button">&raquo;</a>
      
    </div>
    
    </div>
  </div>

    <div class="col-md-4">
    <div class="post-contents">
      <i class="fa fa-tags">&nbsp;&nbsp; Tags</i><br />
      
      
      
      <a  href="/tag/programming">
      <span class="label label-default">programming ( 4 )</span>
      </a><br />

      
      
      
      <a  href="/tag/python">
      <span class="label label-default">python ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/云服务">
      <span class="label label-default">云服务 ( 2 )</span>
      </a><br />

      
      
      
      <a  href="/tag/工具">
      <span class="label label-default">工具 ( 3 )</span>
      </a><br />

      
      
      
      <a  href="/tag/网络">
      <span class="label label-default">网络 ( 6 )</span>
      </a><br />

      
      
      
      <a  href="/tag/构建">
      <span class="label label-default">构建 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/分布式">
      <span class="label label-default">分布式 ( 15 )</span>
      </a><br />

      
      
      
      <a  href="/tag/股票">
      <span class="label label-default">股票 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/读书笔记">
      <span class="label label-default">读书笔记 ( 4 )</span>
      </a><br />

      
      
      
      <a  href="/tag/数据库">
      <span class="label label-default">数据库 ( 6 )</span>
      </a><br />

      
      
      
      <a  href="/tag/数据结构与算法">
      <span class="label label-default">数据结构与算法 ( 11 )</span>
      </a><br />

      
      
      
      <a  href="/tag/linux">
      <span class="label label-default">Linux ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/java">
      <span class="label label-default">Java ( 9 )</span>
      </a><br />

      
      
      
      <a  href="/tag/nosql">
      <span class="label label-default">NoSQL ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/极致思考">
      <span class="label label-default">极致思考 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/架构">
      <span class="label label-default">架构 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/容器">
      <span class="label label-default">容器 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/spring">
      <span class="label label-default">Spring ( 2 )</span>
      </a><br />

      
      
      
      <a  href="/tag/微服务">
      <span class="label label-default">微服务 ( 3 )</span>
      </a><br />

      
      
      
      <a  href="/tag/bigdata">
      <span class="label label-default">BigData ( 4 )</span>
      </a><br />

      
      
      
      <a  href="/tag/mq">
      <span class="label label-default">MQ ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/安全">
      <span class="label label-default">安全 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/用户">
      <span class="label label-default">用户 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/tob">
      <span class="label label-default">toB ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/方法论">
      <span class="label label-default">方法论 ( 1 )</span>
      </a><br />

      
    </div>
    <br />
    <div class="post-contents">
      <h3>About Me</h3>
      <img src="/img/me.jpg" style="margin:20px auto 0 auto;">
      <p style="font-size:18px;margin-top:10px">I'm Siglea,That's All.</p>
      <br />
    </div>
    </div>
</div>
      </div>
      <div class="clearfix">
    </div>

    <footer class="site-footer">

  <div class="container">

    <h2 class="footer-heading">粉笔灰杂谈</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>粉笔灰杂谈</li>
          <li><a href="mailto:siglea@sina.com">siglea@sina.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/siglea"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">siglea</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>关于产品、技术、商业的一些见解，顺便记录一下自己的生活感悟和读书笔记。</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
