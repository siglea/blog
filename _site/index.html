<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>粉笔灰杂谈</title>
  <meta name="description" content="关于产品、技术、商业的一些见解，顺便记录一下自己的生活感悟和读书笔记。">
  <script src="/static/jquery-3.1.1.min.js"></script>
  <link rel="stylesheet" href="/static/bootstrap.min.css">
  <link rel="stylesheet" href="/static/font-awesome-4.6.3/css/font-awesome.min.css">
  <script src="/static/bootstrap.min.js"></script>
  <!-- should put bootstrap before main style sheet, otherwise it't hard to override  -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="canonical" href="http://localhost:4000/">
  <link rel="alternate" type="application/rss+xml" title="粉笔灰杂谈" href="http://localhost:4000/feed.xml">
</head>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86140592-1', 'auto');
  ga('send', 'pageview');

</script>

  <body>

    <header class="site-header">
  <div class="container" style="text-align:center">
    <div class="navbar" style="margin-bottom:0;border:0">
    <ul class="navbar-nav nav header-nav">
    <li><a href="/index.html" class="button">首页</a></li>
      <li><a href="/category/技术" class="button">技术</a></li>
      <li><a href="/category/产品商业" class="button">产品商业</a></li>
      <li><a href="/category/随记" class="button">随记</a></li>
    </ul>
    </div>
  </div>

</header>
<div class="clearfix">


    <div class="page-content">
      <div class="container" style="padding-left:0;padding-right:0;">
        <div class="row" style="margin-bottom:30px">
  <div class="home col-md-8">
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/06/16/DotDot.html">DotDot</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Jun 16, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/06/16/DotDot.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>数据结构与算法</span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>BigData</span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>分布式</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<h3 id="存储精华">存储精华</h3>
<ul>
  <li>说到存储，其实效率才是最主要的，容量不是我们关心的，但是说到存储，不只是mq，所有需要高效率的存储其实最后利用的核心都是一样的。
    <ol>
      <li>随机写转换成顺序写：现在主流的硬盘是机械硬盘，
 机械硬盘的机械结构一次读写时间 = 寻道时间 + 旋转延迟 + 读取数据时间，
 那么寻道时间比较长，如果是顺序写，只需要一次寻道时间，关于机械硬盘整个过程，读者可自行google。</li>
      <li>集中刷盘：
 因为每次刷盘都会进行系统调用，第二还是跟硬盘的本身属性有关，无论是机械硬盘还是ssd按照一定块刷盘会比小数据刷盘效率更好</li>
    </ol>
  </li>
  <li>对于存储系统而言，原本存储在一台机器上的数据，现在要存放在多台机器上。此时必须解决两个问题：分片，复制。
    <ul>
      <li>数据分片(sharding)，又称分区(partition)，将数据集“合理的”拆分成多个分片，每台机器负责其中若干个分片。以此来突破单机容量的限制，同时也提升了整体的访问能力。另外，分片也降低了单个分片故障的影响范围。</li>
      <li>数据复制(replica)，也叫“副本”。分片无法解决单机故障丢数据的问题，所以，必然要通过冗余来解决系统高可用的问题。同时，副本机制也是提升系统吞吐、解决热点问题的重要手段。</li>
      <li>分片和副本是正交的，这意味着我们可以只使用其中一种或都使用，但通常都是同时使用的。因为分片解决的是规模和扩展性的问题，副本解决可靠、可用性的问题。对于一个生产可用的系统，二者必须同时具备。</li>
      <li>从使用者/客户端的角度看，分片和副本可以归结为同一个问题：请求路由，即请求应该发送给哪台机器来处理。</li>
      <li>读数据时，能通过某种机制来确保有一个合适的分片/副本来提供服务</li>
      <li>写数据时，能通过同样的机制来确保写到一个合适的地方，并确保副本的一致性</li>
    </ul>
  </li>
</ul>

<h4 id="innodb引擎的4大特性">InnoDB引擎的4大特性</h4>
<p>https://www.cnblogs.com/zhs0/p/10528520.html</p>
<ul>
  <li>插入缓冲（insert buffer)，只对于非聚集索引（非唯一）的插入和更新有效，对于每一次的插入不是写到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在则直接插入；若不在，则先放到Insert Buffer 中，再按照一定的频率进行合并操作，再写回disk。这样通常能将多个插入合并到一个操作中，目的还是为了减少随机IO带来性能损耗。</li>
  <li>二次写(double write)
    <ul>
      <li>InnoDB默认DB page为 16KB，而文件系统、磁盘、扇区对应的page小于该数字，因此，一次DB page可能被多次写入才能真正写入成功</li>
      <li>在写数据时，会在共享表空间写一份数据，之后再同步到磁盘</li>
      <li>在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是double write</li>
      <li><a href="https://www.cnblogs.com/chenpingzhao/p/4876282.html">https://www.cnblogs.com/chenpingzhao/p/4876282.html</a></li>
    </ul>
  </li>
  <li>自适应哈希索引(ahi)，innodb会监控表上多个索引页的查询。如果观察到建立哈希索引可以带来速度提升，则自动建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。
  主要是精确等值查找，对范围查找搜索不生效</li>
  <li>预读(read ahead)，数据预加载</li>
</ul>

<h5 id="共享表空间-独立表空间">共享表空间 、独立表空间</h5>
<ul>
  <li>共享表空间： Innodb的所有数据保存在一个单独的表空间里面，而这个表空间可以由很多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。从Innodb的官方文档中可以看到，其表空间的最大限制为64TB，也就是说，Innodb的单表限制基本上也在64TB左右了，当然这个大小是包括这个表的所有索引等其他相关数据。</li>
  <li>独占表空间:  每一个表都将会生成以独立的文件方式来进行存储，每一个表都有一个.frm表描述文件，还有一个.ibd文件。 其中这个文件包括了单独一个表的数据内容以及索引内容，默认情况下它的存储位置也是在表的位置之中。</li>
</ul>

<h5 id="聚集索引-与-非聚集索引">聚集索引 与 非聚集索引</h5>
<ul>
  <li><a href="https://blog.csdn.net/riemann_/article/details/90324846">https://blog.csdn.net/riemann_/article/details/90324846</a></li>
</ul>

<h4 id="tcp">TCP</h4>
<ul>
  <li>TCP三要素：ip+端口、序列号（解决乱序）、窗口大小（流量控制）</li>
  <li>TCP与UDP
    <ul>
      <li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。
    UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>
      <li>为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？
  原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度。</li>
      <li>为什么 UDP 头部有「包长度」字段，而 TCP 头部则没有「包长度」字段呢？
  TCP数据的长度 = IP总长度-IP首位长度-TCP首部长度。实际上，UDP的长度也可以用这个方式计算，因此UDP包长度有点多余</li>
    </ul>
  </li>
  <li>TCP建立连接
    <ul>
      <li>3次握手+4种状态：LISTEN、SYS_SEND、SYN_RCVD、ESTABLISHED。（第三次握手可以携带数据，是因为客户端已经明确知道连接建立了）</li>
      <li>为什么是三次握手？不是两次、四次？
        <ul>
          <li>三次握手才可以阻止历史重复连接的初始化（主要原因）
            <ul>
              <li>如果是两次握手连接，就不能判断当前连接是否是历史连接，三次握手则可以在客户端（发送方）准备发送第三次报文时，客户端因有足够的上下文来判断当前连接是否是历史连接：</li>
              <li>如果是历史连接（序列号过期或超时），则第三次握手发送的报文是 RST 报文，以此中止历史连接；</li>
              <li>如果不是历史连接，则第三次发送的报文是 ACK 报文，通信双方就会成功建立连接；</li>
            </ul>
          </li>
          <li>三次握手才可以同步双方的初始序列号</li>
          <li>三次握手才可以避免资源浪费
            <ul>
              <li>如果只有「两次握手」，当客户端的 SYN 请求连接在网络中阻塞，客户端没有接收到 ACK 报文，就会重新发送 SYN ，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号，所以每收到一个 SYN 就只能先主动建立一个连接，这会造成什么情况呢？</li>
              <li>如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>什么是 SYN 攻击？
        <ul>
          <li>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务。</li>
        </ul>
      </li>
      <li>如何避免 SYN 攻击？
        <ul>
          <li>net.ipv4.tcp_syncookies = 1，同一个客户端发起的和自己的cookie绑到，服务端就不会生成太多的SYN_RECD连接</li>
          <li>net.ipv4.tcp_max_syn_backlog，设置最大的SYN_REVD数字</li>
          <li>net.ipv4.tcp_abort_on_overflow ，超出处理能力丢弃</li>
          <li>net.core.netdev_max_backlog，设置最大队列处理数字</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>为什么客户端和服务端的初始序列号 ISN 是不相同的？
    <ul>
      <li>因为网络中的报文会延迟、会复制重发、也有可能丢失，这样会造成的不同连接之间产生互相影响，所以为了避免互相影响，客户端和服务端的初始序列号是随机且不同的。</li>
    </ul>
  </li>
  <li>初始序列号 ISN 是如何随机产生的？
    <ul>
      <li>起始 ISN 是基于时钟的，每 4 毫秒 + 1，转一圈要 4.55 个小时。</li>
      <li>RFC1948 中提出了一个较好的初始化序列号 ISN 随机生成算法。</li>
      <li>ISN = M + F (localhost, localport, remotehost, remoteport)
        <ul>
          <li>M 是一个计时器，这个计时器每隔 4 毫秒加 1。</li>
          <li>F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？
    <ul>
      <li>MTU：一个网络包的最大长度，以太网中一般为 1500 字节；</li>
      <li>MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</li>
      <li>如果TCP 的整个报文（头部 + 数据）交给 IP 层进行分片，会有什么异常呢？</li>
      <li>当 IP 层有一个超过 MTU 大小的数据（TCP 头部 + TCP 数据）要发送，那么 IP 层就要进行分片，把数据分片成若干片，保证每一个分片都小于 MTU。把一份 IP 数据报进行分片以后，由目标主机的 IP 层来进行重新组装后，在交给上一层 TCP 传输层。</li>
      <li>这看起来井然有序，但这存在隐患的，那么当如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。</li>
      <li>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。</li>
      <li>当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的 TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</li>
      <li>因此，可以得知由 IP 层进行分片传输，是非常没有效率的。</li>
      <li>所以，为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，当 TCP 层发现数据超过 MSS 时，则就先会进行分片，当然由它形成的 IP 包的长度也就不会大于 MTU ，自然也就不用 IP 分片了。</li>
      <li>握手阶段协商 MSS，经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率。</li>
    </ul>
  </li>
  <li>TCP断开连接
    <ul>
      <li>4次握手和6种状态，客户端FIN_WAIT_1、FIN_WAIT_2、TIME_WAIT，服务端CLOSED_WAIT、LAST_ACK，CLOSE</li>
    </ul>
  </li>
  <li>为什么 TIME_WAIT 等待的时间是 2MSL？
    <ul>
      <li>MSL 与 TTL 的区别：MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。</li>
      <li>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</li>
      <li>在LAST-ACK状态，如果一直没有收到ACK，会发起重发。</li>
      <li>TIME_WAIT太短会造成，服务端则会一直处在 LASE-ACK 状态。当客户端发起建立连接的 SYN 请求报文后，服务端会发送 RST 报文给客户端，连接建立的过程就会被终止。</li>
    </ul>
  </li>
  <li>为什么需要 TIME_WAIT 状态？
    <ul>
      <li>防止具有相同「四元组」的「旧」数据包被收到；</li>
      <li>保证「被动关闭连接」的一方能被正确的关闭，即保证最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭；</li>
    </ul>
  </li>
  <li>TIME_WAIT 过多有什么危害？
    <ul>
      <li>第一是内存资源占用；</li>
      <li>第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口；</li>
    </ul>
  </li>
  <li>如何优化 TIME_WAIT？
    <ul>
      <li>net.ipv4.tcp_tw_reuse = 1 ; net.ipv4.tcp_timstamps=1;这个时间戳的字段是在 TCP 头部的「选项」里，用于记录 TCP 发送方的当前时间戳和从对端接收到的最新时间戳。
  由于引入了时间戳，我们在前面提到的 2MSL 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。
  温馨提醒：net.ipv4.tcp_tw_reuse要慎用，因为使用了它就必然要打开时间戳的支持 net.ipv4.tcp_timestamps，当客户端与服务端主机时间不同步时，客户端的发送的消息会被直接拒绝掉。小林在工作中就遇到过。。。排查了非常的久</li>
      <li>net.ipv4.tcp_max_tw_buckets ; 这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将所有的 TIME_WAIT 连接状态重置。这个方法过于暴力，而且治标不治本，带来的问题远比解决的问题多，不推荐使用。</li>
      <li>程序中使用 SO_LINGER ,如果l_onoff为非 0， 且l_linger值为 0，那么调用close后，会立该发送一个RST标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了TIME_WAIT状态，直接关闭。但这为跨越TIME_WAIT状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</li>
    </ul>
  </li>
  <li>保活机制
    <ul>
      <li>tcp_keepalive_time=7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li>
      <li>tcp_keepalive_intvl=75：表示每次检测间隔 75 秒；</li>
      <li>tcp_keepalive_probes=9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
      <li>高效保活长连接：手把手教你实现 自适应的心跳保活机制 <a href="https://mp.weixin.qq.com/s/BsLAXegZOE6B9CzW31xIdA">https://mp.weixin.qq.com/s/BsLAXegZOE6B9CzW31xIdA</a></li>
      <li>聊聊 TCP 长连接和心跳那些事 <a href="https://mp.weixin.qq.com/s/cwqAMPku-LwXAGM3Cqztig">https://mp.weixin.qq.com/s/cwqAMPku-LwXAGM3Cqztig</a></li>
    </ul>
  </li>
  <li>listen 时候参数 backlog 的意义？
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int listen <span class="o">(</span>int socketfd, int backlog<span class="o">)</span>
参数一 socketfd 为 socketfd 文件描述符
参数二 backlog，这参数在历史有一定的变化
在早期 Linux 内核 backlog 是 SYN 队列大小，也就是未完成的队列大小。
在 Linux 内核 2.2 之后，backlog 变成 accept 队列，也就是已完成连接建立的队列长度，所以现在通常认为 backlog 是 accept 队列。
</code></pre></div>    </div>
  </li>
  <li>粘包拆包，应用层拆包？
    <ul>
      <li>如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。
我们都知道TCP属于传输层的协议，传输层除了有TCP协议外还有UDP协议。那么UDP是否会发生粘包或拆包的现象呢？答案是不会。UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能</li>
      <li>SO_TCPNODELAY:NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量 小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法。</li>
      <li>拆包方案
        <ul>
          <li>客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；</li>
          <li>客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；</li>
          <li>将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；</li>
          <li>通过自定义协议进行粘包和拆包的处理。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>使用了哪些算法？
    <ul>
      <li>重传算法</li>
      <li>RTO计算</li>
      <li>Nagle算法，累计够数据再发送</li>
    </ul>
  </li>
  <li>netty
    <ul>
      <li>无锁设计、线程绑定，类似偏向锁读写操作会判断是否是之前绑定的线程</li>
      <li>netty + protobuf ???</li>
    </ul>
  </li>
  <li>reactor和proactor模型
    <ul>
      <li>reactor：基于NIO技术，可读可写时通知应用；await阻塞等待</li>
      <li>proactor：基于AIO技术，读完成时通知应用，写操作应用通知内核。真正的异步。</li>
    </ul>
  </li>
  <li>Java nio 空轮询bug到底是什么，异常情况导致的fd集合为空时，selector仍然会轮训 <a href="https://mp.weixin.qq.com/s/-SoUVFB5DhaUZg_novolkg">https://mp.weixin.qq.com/s/-SoUVFB5DhaUZg_novolkg</a></li>
</ul>

<h4 id="zookeeper的observer">ZooKeeper的observer</h4>
<p>当ZooKeeper集群中follower的数量很多时，投票过程会成为一个性能瓶颈，为了解决投票造成的压力，于是出现了observer角色。
observer角色不参与投票，它只是投票结果的”听众”，除此之外，它和follower完全一样，例如能接受读、写请求。就这一个特点，让整个ZooKeeper集群性能大大改善。
和follower一样，当observer收到客户端的读请求时，会直接从内存数据库中取出数据返回给客户端。
对于写请求，当写请求发送到某server上后，无论这个节点是follower还是observer，都会将它发送给leader。然后leader组织投票过程，所有server都收到这个proposal(包括observer，因为proposal是广播出去的)，但是leader和follower以及observer通过配置文件，都知道自己是不是observer以及谁是observer。自己是observer的server不参与投票。当leader收集完投票后，将那些observer的server去掉，在剩下的server中计算大多数，如果投票结果达到了大多数，这次写事务就成功，于是leader通知所有的节点(包括observer)，让它们将事务写入事务日志，并提交。</p>

<p>Pojo(plian ordinary普通的; 平常的; java object)</p>

<h4 id="jvm">JVM</h4>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-Xms2g</span>：初始化推大小为 2g；
<span class="nt">-Xmx2g</span>：堆最大内存为 2g；
<span class="nt">-XX</span>:NewRatio<span class="o">=</span>4：设置年轻的和老年代的内存比例为 1:4；
<span class="nt">-XX</span>:SurvivorRatio<span class="o">=</span>8：设置新生代 Eden 和 Survivor 比例为 8:2；
–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
<span class="nt">-XX</span>:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
<span class="nt">-XX</span>:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
<span class="nt">-XX</span>:+PrintGC：开启打印 gc 信息；
<span class="nt">-XX</span>:+PrintGCDetails：打印 gc 详细信息。
</code></pre></div></div>

<h4 id="分代垃圾回收器是怎么工作的">分代垃圾回收器是怎么工作的？</h4>
<ul>
  <li>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</li>
  <li>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是  8:1:1，它的执行流程如下：</li>
  <li>把 Eden + From Survivor 存活的对象放入 To Survivor 区；
清空 Eden 和 From Survivor 分区；
From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。
每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</li>
  <li>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</li>
</ul>

<h4 id="垃圾回收器">垃圾回收器</h4>
<ul>
  <li>Serial收集器（复制算法): 新生代单线程收集器，标记和清理都是单线程，优点是简单高效；</li>
  <li>ParNew收集器 (复制算法): 新生代收并行集器，实际上是Serial收集器的多线程版本，在多核CPU环境下有着比Serial更好的表现；</li>
  <li>Parallel Scavenge收集器 (复制算法): 新生代并行收集器，追求高吞吐量，高效利用 CPU。吞吐量 = 用户线程时间/(用户线程时间+GC线程时间)，高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，适合后台应用等对交互相应要求不高的场景；</li>
  <li>Serial Old收集器 (标记-整理算法): 老年代单线程收集器，Serial收集器的老年代版本；</li>
  <li>Parallel Old收集器 (标记-整理算法)： 老年代并行收集器，吞吐量优先，Parallel Scavenge收集器的老年代版本；</li>
  <li>CMS(Concurrent Mark Sweep)收集器（标记-清除算法）： 老年代并行收集器，以获取最短回收停顿时间为目标的收集器，具有高并发、低停顿的特点，追求最短GC回收停顿时间。</li>
  <li>G1(Garbage First)收集器 (标记-整理算法)： Java堆并行收集器，G1收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。此外，G1收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆(包括新生代，老年代)，而前六种收集器回收的范围仅限于新生代或老年代。</li>
</ul>

<h4 id="bionioaio-有什么区别">BIO,NIO,AIO 有什么区别?</h4>
<p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>

<p>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发
AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p>

<h4 id="kafka数据存储">kafka数据存储</h4>
<ul>
  <li>Kafka和RocketMQ存储区别 <a href="https://mp.weixin.qq.com/s/_hJcEqTMASpeDkavcdtDsw">https://mp.weixin.qq.com/s/_hJcEqTMASpeDkavcdtDsw</a>
    <ul>
      <li>partition升级为ConsumerQueue，并且只存储消息的地址，由单独的commitLog记录消息文件</li>
      <li>consumerQueue消息格式大小固定（20字节），写入pagecache之后被触发刷盘频率相对较低。就是因为每次写入的消息小，造成他占用的pagecache少，主要占用方一旦被清理，那么他就可以不用清理了。</li>
      <li>kafka中多partition会存在随机写的可能性，partition之间刷盘的冲撞率会高，但是rocketmq中commitLog都是顺序写。</li>
    </ul>
  </li>
  <li>partition：topic 的分区，一个 topic 可以包含多个 partition，topic 消息保存在各个partition 上
    <ul>
      <li>每个partition是一个有序的队列也是一个目录。</li>
      <li>partition 内消息是有序的，Consumer 通过 pull 方式消费消息。Kafka 不删除已消费的消息.。对于 partition，顺序读写磁盘数据，以时间复杂度 O(1)方式提供消息持久化能力。</li>
      <li>每个partition(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。但每个段segment file消息数量不一定相等，这种特性方便old segment file快速被删除。</li>
    </ul>
  </li>
  <li>segment：partition物理上由多个segment文件组成，每个segment大小相等，顺序读写。
    <ul>
      <li>每个 segment 数据文件以该段中最小的 offset 命名，文件扩展名为.log。这样在查找指定 offset 的 Message 的 时候，用二分查找就可以定位到该 Message 在哪个 segment 数据文件中。</li>
      <li>segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件。</li>
    </ul>
  </li>
  <li>Kafka 为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩 展名为.index。index 文件中并没有为数据文件中的每条 Message 建立索引，而是采用了稀疏存 储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以 将索引文件保留在内存中。</li>
  <li>由于消息 topic 由多个 partition 组成，且 partition 会均衡分布到不同 broker 上，因此，为了有 效利用 broker 集群的性能，提高消息的吞吐量，producer 可以通过随机或者 hash 等方式，将消 息平均发送到多个 partition 上，以实现负载均衡。</li>
  <li>是提高消息吞吐量重要的方式，Producer 端可以在内存中合并多条消息后，以一次请求的方式发 送了批量的消息给 broker，从而大大减少 broker 存储消息的 IO 操作次数。但也一定程度上影响 了消息的实时性，相当于以时延代价，换取更好的吞吐量。</li>
  <li>Producer 端可以通过 GZIP 或 Snappy 格式对消息集合进行压缩。Producer 端进行压缩之后，在 Consumer 端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大 数据处理上，瓶颈往往体现在网络上而不是 CPU(压缩和解压会耗掉部分 CPU 资源)。</li>
  <li>Current Offset是针对Consumer的poll过程的，它可以保证每次poll都返回不重复的消息；而Committed Offset是用于Consumer Rebalance过程的，它能够保证新的Consumer能够从正确的位置开始消费一个partition，从而避免重复消费。</li>
  <li>Zookeeper：保存着集群 broker、topic、partition 等 meta 数据;另外，还负责 broker 故障发现，partition leader 选举，负载均衡等功能。</li>
  <li>auto.offset.reset表示如果Kafka中没有存储对应的offset信息的话（有可能offset信息被删除），消费者从何处开始消费消息。它拥有三个可选值：earliest：从最早的offset开始消费、latest：从最后的offset开始消费、none：直接抛出exception给consumer</li>
</ul>

<h4 id="hashmap-为啥size是2的倍数18比17做了哪些优化">HashMap 为啥size是2的倍数，1.8比1.7做了哪些优化？</h4>
<p>JDK1.7 VS JDK1.8 比较
JDK1.8主要解决或优化了一下问题：
resize 扩容优化
引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考
解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</p>

<h4 id="spring">Spring</h4>
<ul>
  <li>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；</li>
  <li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</li>
  <li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li>
  <li>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</li>
  <li>Zuul：API网关组件，对请求提供路由及过滤功能。</li>
  <li>Spring Cloud Bus
用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。
Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点/总线/刷新来实现对任何单个实例的刷新。</li>
  <li>Spring Cloud Consul
基于Hashicorp Consul的服务治理组件。</li>
  <li>Spring Cloud Security
安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</li>
  <li>Spring Cloud Sleuth
Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</li>
  <li>Spring Cloud Stream
轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</li>
  <li>Spring Cloud Task
用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</li>
  <li>Spring Cloud Zookeeper
基于Apache Zookeeper的服务治理组件。</li>
  <li>Spring Cloud Gateway
API网关组件，对请求提供路由及过滤功能。Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。
使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</li>
  <li>Spring Cloud OpenFeign
基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</li>
  <li>什么是Spring Cloud Config?
在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。
使用：（1）添加pom依赖（2）配置文件添加相关配置（3）启动类添加注解@EnableConfigServer</li>
  <li>Spring中使用@Autowired注解静态实例对象 <a href="https://blog.csdn.net/RogueFist/article/details/79575665">https://blog.csdn.net/RogueFist/article/details/79575665</a></li>
  <li>多个ApplicationRunner，可以用@Order指定优先级串行执行的，如果优先级高的block了，后面的需要等着</li>
</ul>

<h4 id="protocol-buffer-的序列化--反序列化简单--速度快的原因是">Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是:</h4>
<ol>
  <li>编码 / 解码 方式简单(只需要简单的数学运算 = 位移等等)</li>
  <li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li>
</ol>

<h4 id="protocol-buffer-的数据压缩效果好即序列化后的数据量体积小的原因是">Protocol Buffer 的数据压缩效果好(即序列化后的数据量体积小)的原因是:</h4>
<ol>
  <li>a. 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li>
  <li>b. 采用 T - L - V 的数据存储方式:减少了分隔符的使用 &amp; 数据存储得紧凑</li>
</ol>

<h3 id="hbase-cassandra-mongodb">HBase Cassandra MongoDB</h3>
<ul>
  <li>与RDBMS的区别
    <ul>
      <li>关系数据库，磁盘存储是一行接一行，而列式存储是一列接一列</li>
    </ul>
  </li>
  <li>存储结构
    <ul>
      <li>MongoDB：GridFS、JSON/BSON</li>
      <li>HBase：HRegionServer：【HLog、HRegion：【Store MemStore、StoreFile、HFile】】、HDFS。
        <ul>
          <li>HBase的数据分片按表进行，以行为粒度，基于rowkey范围进行拆分，每个分片称为一个region。一个集群有多张表，每张表划分为多个region，每台服务器服务很多region。所以，HBase的服务器称为RegionServer，简称RS。RS与表是正交的，即一张表的region会分布到多台RS上，一台RS也会调度多张表的region</li>
          <li>HBase是水平拆分,意思是行是region划分的最小单位，即一行数据要么属于A region，要么属于Bregion，不会被拆到两个region中去。</li>
          <li>浅谈HBase的数据分布 <a href="https://zhuanlan.zhihu.com/p/47074785">https://zhuanlan.zhihu.com/p/47074785</a></li>
          <li>hbase.regionserver.global.memstore.upperLimit、hbase.regionserver.global.memstore.lowerLimit、hbase.hregion.memstore.flush.size</li>
          <li>HLog限制，hase.regionserver.max.logs</li>
        </ul>
      </li>
      <li>Cassandra：LSM、HashNode、CommitLog、memtable、SSTable</li>
      <li>HBase、Cassandra都是基于类似的LSM机制</li>
    </ul>
  </li>
  <li>存储形式
    <ul>
      <li>MongoDB：Collection JSON</li>
      <li>Cassandra：Column family ，Row，Name/Value/Timestamp</li>
      <li>HBase：put ‘t_user’,’1001’,’st1:age’,’18’</li>
    </ul>
  </li>
  <li>数据类型
    <ul>
      <li>MongoDB丰富，类似SQL</li>
      <li>HBase只支持字符串</li>
      <li>Cassandra多种</li>
    </ul>
  </li>
  <li>索引、二级索引、辅助索引
    <ul>
      <li>MongoDB：支持全索引，实现高性能。单一索引、复合、哈希、地址位置、文本等索引。BTree</li>
      <li>HBase：主要是设计二级索引。二级索引的本质就是建立各列值与行键之间的映射关系。简单的可以借助RowKey
        <ol>
          <li>RowKey也是基于B+树</li>
          <li>MapReduce方案</li>
          <li>ITHBASE（Indexed-Transanctional HBase）方案</li>
          <li>IHBASE（Index HBase）方案</li>
          <li>Hbase Coprocessor(协处理器)方案</li>
          <li>Solr+HBase方案</li>
          <li>CCIndex（complemental clustering index）方案</li>
          <li>Phoenix</li>
          <li>HBase RowKey与索引设计 <a href="https://www.cnblogs.com/swordfall/p/10597802.html">https://www.cnblogs.com/swordfall/p/10597802.html</a></li>
        </ol>
      </li>
    </ul>
  </li>
  <li>事务
    <ul>
      <li>HBase的事务是行级事务，可以保证行级数据的原子性、一致性、隔离性以及持久性</li>
      <li>MongoDB不支持事务</li>
    </ul>
  </li>
  <li>一致性和CAP
    <ul>
      <li>MongoDB、HBase强一致性，CP，0 数据丢失</li>
      <li>Cassandra最终一致性（可调一致性），数据可能丢失，AP</li>
    </ul>
  </li>
  <li>Join支持
    <ul>
      <li>MongoDB不支持多表连接</li>
      <li>Cassandra不支持多表连接，用数据冗余解决问题hotels_by_poi</li>
      <li>HBase不支持Join，需要借助其他工具或者算法实现</li>
    </ul>
  </li>
  <li>范围查询
    <ul>
      <li>MongoDB：利用skip().limit()实现</li>
      <li>HBase：scan  ‘stu2’,{COLUMNS =&gt; ‘cf1:age’, LIMMIT 10, STARTROW =&gt; ‘xx’}</li>
    </ul>
  </li>
  <li>读写
    <ul>
      <li>HBase快速读取和写入，具有可扩展性。读写性能数据读写定位可能要通过最多 6 次的网络RPC，性能较低。</li>
      <li>Cassandra快速随机性读取/写入，写多读少。数据读写定位非常快。</li>
    </ul>
  </li>
</ul>

<p>Hbase和Cassandra <a href="https://blog.csdn.net/aa5305123/article/details/83142514">https://blog.csdn.net/aa5305123/article/details/83142514</a>
MongoDB、HBase、Cassandra比较<a href="https://www.cnblogs.com/yanduanduan/p/10563678.html">https://www.cnblogs.com/yanduanduan/p/10563678.html</a>  <br />
1.强一致性的读写：HBase不是一个最终一致性的存储。
2.自动sharding：HBase的table在集群种被分布在各个region，region可以做自动切分。
3.regionserver的failover；
4.Hadoop/HDFS的集成；
5.MapReduce：支持大数据的并行处理；
6.JAVA Client 以及Thrift/RESR API 访问；
7.Block Cache 以及Bloom filter；
8.操作管理。</p>

<p>1.C<em>借鉴Dynamo的架构思想，把自己叫做一个最终一致性的系统，如果使用至少是QUORUM 读写，还算是一个强一致的系统。
2.C</em>的sharding方式：一致性hash，有2种：
（1）人为配置好initial_token；
2.使用vnode，集群初始化以及节点bootstrap的时候会计算token，基于这些token做数据sharding。
3.可以容忍：replicator_number - (read/write level sufficient nodes)个节点挂了，比如3个副本，读写级别QUORUM（sufficient nodes是2），能容忍1节点挂；
4.支持MapReduce;
5.Thrift、CQL访问;
6.大数据处理的bloom filter 必备；
7.自己有jmx等常见管理，且datastax 公司有提供ops center；</p>

<h4 id="seata-的-demo">seata 的 Demo</h4>
<h4 id="hive--mysql数据互导">Hive &amp; Mysql数据互导</h4>
<h4 id="tweproxy">tweproxy</h4>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/06/16/DotDot.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/06/07/ClassicalAlgorithm.html">经典算法思想</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Jun 7, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/06/07/ClassicalAlgorithm.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>数据结构与算法</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<p>数据结构算法，问题TOP10 <a href="https://mp.weixin.qq.com/s/rqzCvFWira204eJ1HA22yg">https://mp.weixin.qq.com/s/rqzCvFWira204eJ1HA22yg</a></p>

<h4 id="贪心算法">贪心算法</h4>
<ul>
  <li>贪心的意思在于在作出选择时，每次都要选择对自身最为有利的结果，保证自身利益的最大化。贪心算法就是利用这种贪心思想而得出一种算法。</li>
  <li>例：小明手中有 1，5，10，50，100 五种面额的纸币，每种纸币对应张数分别为 5，2，2，3，5 张。若小明需要支付 456 元，则需要多少张纸币？</li>
  <li>最小生成树 Kruskal算法</li>
  <li>最小生成树 prim算法</li>
  <li>分发饼干、跳跃游戏、无重叠区间、摆动序列 <a href="https://mp.weixin.qq.com/s/4GKIwV34Zp4W1VFTwhx-uw">https://mp.weixin.qq.com/s/4GKIwV34Zp4W1VFTwhx-uw</a></li>
  <li>分糖果、无重叠区间 <a href="https://mp.weixin.qq.com/s/YhFGBAXhv8c-Rfs6Fuciow">https://mp.weixin.qq.com/s/YhFGBAXhv8c-Rfs6Fuciow</a></li>
</ul>

<h4 id="分治算法">分治算法</h4>
<ul>
  <li>快速排序算法、大整数乘法、残缺棋盘游戏 <a href="https://mp.weixin.qq.com/s/2rnEhHcJEGSEmlAK18B2VQ">https://mp.weixin.qq.com/s/2rnEhHcJEGSEmlAK18B2VQ</a></li>
  <li>汉诺塔、快速排序、归并排序 <a href="https://mp.weixin.qq.com/s/paOrlfpdMwvCUDywda0EvQ">https://mp.weixin.qq.com/s/paOrlfpdMwvCUDywda0EvQ</a></li>
</ul>

<h4 id="动态规划算法-dynamic-programming">动态规划算法 Dynamic Programming</h4>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>F<span class="o">(</span>1<span class="o">)</span> <span class="o">=</span> 1<span class="p">;</span>
F<span class="o">(</span>2<span class="o">)</span> <span class="o">=</span> 2<span class="p">;</span> 
F<span class="o">(</span>n<span class="o">)</span> <span class="o">=</span> F<span class="o">(</span>n-1<span class="o">)</span>+F<span class="o">(</span>n-2<span class="o">)</span><span class="p">;</span>（n&gt;<span class="o">=</span>3）

F<span class="o">(</span>10<span class="o">)</span> <span class="o">=</span> F<span class="o">(</span>9<span class="o">)</span> + F<span class="o">(</span>8<span class="o">)</span> <span class="c">#最优子结构</span>
F<span class="o">(</span>1<span class="o">)</span> F<span class="o">(</span>2<span class="o">)</span> <span class="c">#边界</span>
F<span class="o">(</span>n<span class="o">)</span> <span class="o">=</span> F<span class="o">(</span>n-1<span class="o">)</span> + F<span class="o">(</span>n-2<span class="o">)</span> <span class="c">#状态转移方程</span>
</code></pre></div></div>
<ul>
  <li>斐波那契 <a href="https://mp.weixin.qq.com/s/3LR-iVC4zgj0tGhZ780PcQ">https://mp.weixin.qq.com/s/3LR-iVC4zgj0tGhZ780PcQ</a></li>
  <li>上台阶与挖黄金 <a href="https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg">https://mp.weixin.qq.com/s/3h9iqU4rdH3EIy5m6AzXsg</a></li>
  <li>高楼扔鸡蛋 <a href="https://mp.weixin.qq.com/s/ncrvbpiZauXAGnUZTh5qtA">https://mp.weixin.qq.com/s/ncrvbpiZauXAGnUZTh5qtA</a></li>
</ul>

<h4 id="回溯法">回溯法</h4>
<ul>
  <li>深度优先遍历 <a href="https://mp.weixin.qq.com/s/UCTjKA7olFb00C6CLlqHAA">https://mp.weixin.qq.com/s/UCTjKA7olFb00C6CLlqHAA</a></li>
  <li>八皇后问题 <a href="https://mp.weixin.qq.com/s/puk7IAZkSe6FCkZnt0jnSA">https://mp.weixin.qq.com/s/puk7IAZkSe6FCkZnt0jnSA</a></li>
  <li>八皇后问题与数独 <a href="https://mp.weixin.qq.com/s/vfItwB2GpXCy-s2dQJnkIg">https://mp.weixin.qq.com/s/vfItwB2GpXCy-s2dQJnkIg</a></li>
  <li>A*寻路算法 <a href="https://mp.weixin.qq.com/s/FYKR_1yBKR4GJTn0fFIuAA">https://mp.weixin.qq.com/s/FYKR_1yBKR4GJTn0fFIuAA</a></li>
  <li>多源最短路径，弗洛伊德算法 Floyd-Warshall <a href="https://mp.weixin.qq.com/s/qnPSzv_xWSZN0VpdUgwvMg">https://mp.weixin.qq.com/s/qnPSzv_xWSZN0VpdUgwvMg</a></li>
</ul>

<h4 id="分支定界法">分支定界法</h4>
<ul>
  <li>广度优先遍历 <a href="https://mp.weixin.qq.com/s/Rdg14IPL4Czx4J5obgbqEQ">https://mp.weixin.qq.com/s/Rdg14IPL4Czx4J5obgbqEQ</a></li>
</ul>

<h4 id="字符串匹配算法">字符串匹配算法</h4>
<ul>
  <li>BF算法，是Brute Force（暴力算法，按位比较 O(m*n)）<a href="https://mp.weixin.qq.com/s/2RlyDBo-Ql-1Ofh8tMyikg">https://mp.weixin.qq.com/s/2RlyDBo-Ql-1Ofh8tMyikg</a></li>
  <li>RK算法，是Rabin-Karp (计算hash值进行比较 O(n)) <a href="https://mp.weixin.qq.com/s/EVkV1AQC9GBI29zNiWDH6g">https://mp.weixin.qq.com/s/EVkV1AQC9GBI29zNiWDH6g</a></li>
  <li>Knuth-Morris-Pratt算法（简称KMP）是最常用的之一 <a href="https://mp.weixin.qq.com/s/xr5rgSF3dOV9XH0gC5oO0w">https://mp.weixin.qq.com/s/xr5rgSF3dOV9XH0gC5oO0w</a></li>
  <li>字符串匹配算法综述:BF、RK、KMP、BM、Sunday <a href="https://mp.weixin.qq.com/s/RSnFzrmitwCCgDuB73I2QA">https://mp.weixin.qq.com/s/RSnFzrmitwCCgDuB73I2QA</a></li>
</ul>

<h4 id="参考">参考</h4>
<ul>
  <li>小灰算法2017 <a href="https://mp.weixin.qq.com/s/4kTtn_gLYQrX7JFlEJdsZg">https://mp.weixin.qq.com/s/4kTtn_gLYQrX7JFlEJdsZg</a></li>
  <li>小灰算法2018 <a href="https://mp.weixin.qq.com/s/oFQHrCZvItgc8McrZSaovw">https://mp.weixin.qq.com/s/oFQHrCZvItgc8McrZSaovw</a></li>
  <li>小灰算法2019 <a href="https://mp.weixin.qq.com/s/Ok5SjqhiQkG5sLUPNY02Mw">https://mp.weixin.qq.com/s/Ok5SjqhiQkG5sLUPNY02Mw</a></li>
  <li>小灰算法2020 <a href="https://mp.weixin.qq.com/s/dpWZ6qOvU1T9sdOzMNVyAA">https://mp.weixin.qq.com/s/dpWZ6qOvU1T9sdOzMNVyAA</a></li>
  <li>二十世纪最伟大的10大算法 <a href="https://blog.csdn.net/v_JULY_v/article/details/6127953">https://blog.csdn.net/v_JULY_v/article/details/6127953</a></li>
</ul>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/06/07/ClassicalAlgorithm.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/06/07/BitMap-BloomFilter.html">BitMap-BloomFilter</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Jun 7, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/06/07/BitMap-BloomFilter.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>数据结构与算法</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<h4 id="bitmap">BitMap</h4>
<ul>
  <li>近似的理解为用一个大数组的索引来表示数字本身，用0或1表示该数字是否存在</li>
  <li>一个32位的int，只用一个标志位来表示是否存在</li>
  <li>但是数字如果重复只会保留一个，主要用于去重类似的场景</li>
</ul>

<h4 id="bloomfilter">BloomFilter</h4>
<ul>
  <li>判断短连接是否重复、垃圾邮件等场景</li>
  <li>把url，3次不同hash，得到3个不同的hashcode，存入bitmap</li>
  <li>多次hash是为了降低hash重复的概率</li>
  <li>由于以上特性，bloomFilter算法计算出不存在的一定就是不存在，如果计算出来存在有一定几率重复（因为hash的特性）</li>
</ul>

<h4 id="参考链接">参考链接</h4>
<ul>
  <li>Bitmap算法 整合版 <a href="https://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg">https://mp.weixin.qq.com/s/xxauNrJY9HlVNvLrL5j2hg</a></li>
  <li>什么是布隆算法？<a href="https://mp.weixin.qq.com/s/RmR5XmLeMvk35vgjwxANFQ">https://mp.weixin.qq.com/s/RmR5XmLeMvk35vgjwxANFQ</a></li>
</ul>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/06/07/BitMap-BloomFilter.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/06/07/BigDataAlgorithm.html">大数据常用算法概述</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Jun 7, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/06/07/BigDataAlgorithm.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>数据结构与算法</span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>BigData</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<h4 id="决策树算法">决策树算法</h4>
<h4 id="回归算法">回归算法</h4>
<h4 id="朴素贝叶斯算法">朴素贝叶斯算法</h4>
<h4 id="聚类-knn算法">聚类-KNN算法</h4>
<h4 id="svm支持向量机">SVM支持向量机</h4>
<h4 id="推荐算法">推荐算法</h4>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/06/07/BigDataAlgorithm.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/06/06/Zookeeper.html">ZooKeeper</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Jun 6, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/06/06/Zookeeper.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>微服务</span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>分布式</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<h4 id="使用场景">使用场景</h4>
<ul>
  <li>注册中心</li>
  <li>配置中心</li>
  <li>HBase之MetaData存储</li>
  <li>分布式锁</li>
</ul>

<h4 id="常用命令">常用命令</h4>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./zkServer.sh start | stop 
./zkServer.sh status
./zkCli.sh 

<span class="nb">ls</span> /
<span class="nb">stat</span> /
ls2 /

create /node1 /node1-content
create <span class="nt">-e</span> /node1-temp /node1-content-temp
</code></pre></div></div>
<p><a href="https://blog.csdn.net/dandandeshangni/article/details/80558383">https://blog.csdn.net/dandandeshangni/article/details/80558383</a></p>

<h4 id="阿里为什么不用-zookeeper-做服务发现">阿里为什么不用 ZooKeeper 做服务发现？</h4>
<ul>
  <li>基于CP而非AP</li>
  <li>自身仅仅是主从的集群，而非分布式集群</li>
  <li>The King Of Coordination for Big Data</li>
</ul>

<p><a href="https://mp.weixin.qq.com/s/ouayPydKCWc0FfGlaSnCrg">https://mp.weixin.qq.com/s/ouayPydKCWc0FfGlaSnCrg</a></p>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/06/06/Zookeeper.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    

    <div style="text-align:center">
    
    <div class="pagination">
      

      
      
      <a href="" class="button current-page-button">1</a>
      
      
      
      <a href="/page2" class="button page-button">2</a>
      
      
      
      <a href="/page3" class="button page-button">3</a>
      
      
      
      <a href="/page4" class="button page-button">4</a>
      
      
      
      <a href="/page5" class="button page-button">5</a>
      
      
      
      <a href="/page6" class="button page-button">6</a>
      
      
      
      <a href="/page7" class="button page-button">7</a>
      
      
      
      <a href="/page8" class="button page-button">8</a>
      
      
      
      <a href="/page9" class="button page-button">9</a>
      
      
      
      <a href="/page10" class="button page-button">10</a>
      
      
      
      <a href="/page11" class="button page-button">11</a>
      
      

      
      <a href="/page2" class="button page-button">&raquo;</a>
      
    </div>
    
    </div>
  </div>

    <div class="col-md-4">
    <div class="post-contents">
      <i class="fa fa-tags">&nbsp;&nbsp; Tags</i><br />
      
      
      
      <a  href="/tag/programming">
      <span class="label label-default">programming ( 4 )</span>
      </a><br />

      
      
      
      <a  href="/tag/python">
      <span class="label label-default">python ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/云服务">
      <span class="label label-default">云服务 ( 2 )</span>
      </a><br />

      
      
      
      <a  href="/tag/工具">
      <span class="label label-default">工具 ( 3 )</span>
      </a><br />

      
      
      
      <a  href="/tag/网络">
      <span class="label label-default">网络 ( 5 )</span>
      </a><br />

      
      
      
      <a  href="/tag/构建">
      <span class="label label-default">构建 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/分布式">
      <span class="label label-default">分布式 ( 14 )</span>
      </a><br />

      
      
      
      <a  href="/tag/股票">
      <span class="label label-default">股票 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/读书笔记">
      <span class="label label-default">读书笔记 ( 4 )</span>
      </a><br />

      
      
      
      <a  href="/tag/数据库">
      <span class="label label-default">数据库 ( 6 )</span>
      </a><br />

      
      
      
      <a  href="/tag/数据结构与算法">
      <span class="label label-default">数据结构与算法 ( 10 )</span>
      </a><br />

      
      
      
      <a  href="/tag/linux">
      <span class="label label-default">Linux ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/java">
      <span class="label label-default">Java ( 8 )</span>
      </a><br />

      
      
      
      <a  href="/tag/nosql">
      <span class="label label-default">NoSQL ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/极致思考">
      <span class="label label-default">极致思考 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/架构">
      <span class="label label-default">架构 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/容器">
      <span class="label label-default">容器 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/spring">
      <span class="label label-default">Spring ( 2 )</span>
      </a><br />

      
      
      
      <a  href="/tag/微服务">
      <span class="label label-default">微服务 ( 3 )</span>
      </a><br />

      
      
      
      <a  href="/tag/bigdata">
      <span class="label label-default">BigData ( 3 )</span>
      </a><br />

      
      
      
      <a  href="/tag/mq">
      <span class="label label-default">MQ ( 1 )</span>
      </a><br />

      
    </div>
    <br />
    <div class="post-contents">
      <h3>About Me</h3>
      <img src="/img/me.jpg" style="margin:20px auto 0 auto;">
      <p style="font-size:18px;margin-top:10px">I'm Siglea,That's All.</p>
      <br />
    </div>
    </div>
</div>
      </div>
      <div class="clearfix">
    </div>

    <footer class="site-footer">

  <div class="container">

    <h2 class="footer-heading">粉笔灰杂谈</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>粉笔灰杂谈</li>
          <li><a href="mailto:siglea@sina.com">siglea@sina.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/siglea"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">siglea</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>关于产品、技术、商业的一些见解，顺便记录一下自己的生活感悟和读书笔记。</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
