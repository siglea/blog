<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>粉笔灰杂谈</title>
  <meta name="description" content="关于产品、技术、商业的一些见解，顺便记录一下自己的生活感悟和读书笔记。">
  <script src="/static/jquery-3.1.1.min.js"></script>
  <link rel="stylesheet" href="/static/bootstrap.min.css">
  <link rel="stylesheet" href="/static/font-awesome-4.6.3/css/font-awesome.min.css">
  <script src="/static/bootstrap.min.js"></script>
  <!-- should put bootstrap before main style sheet, otherwise it't hard to override  -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="canonical" href="http://localhost:4000/page6/">
  <link rel="alternate" type="application/rss+xml" title="粉笔灰杂谈" href="http://localhost:4000/feed.xml">
</head>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86140592-1', 'auto');
  ga('send', 'pageview');

</script>

  <body>

    <header class="site-header">
  <div class="container" style="text-align:center">
    <div class="navbar" style="margin-bottom:0;border:0">
    <ul class="navbar-nav nav header-nav">
    <li><a href="/index.html" class="button">首页</a></li>
      <li><a href="/category/技术" class="button">技术</a></li>
      <li><a href="/category/产品商业" class="button">产品商业</a></li>
      <li><a href="/category/随记" class="button">随记</a></li>
    </ul>
    </div>
  </div>

</header>
<div class="clearfix">


    <div class="page-content">
      <div class="container" style="padding-left:0;padding-right:0;">
        <div class="row" style="margin-bottom:30px">
  <div class="home col-md-8">
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/05/18/Netty.html">Netty</a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>May 18, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/05/18/Netty.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>网络</span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>Java</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<h4 id="netty-要点">Netty 要点</h4>
<ul>
  <li>NioEventLoopGroup、EventLoop都是集成或者实现 ScheduledExecutorService、ExecutorService，因此本质都是线程池</li>
</ul>
<p><a href="https://www.jianshu.com/p/da4398743b5a">https://www.jianshu.com/p/da4398743b5a</a></p>
<ul>
  <li>NioEventLoopGroup还提供了setIoRatio()和rebuildSelectors()两个方法，一个用来设置I/O任务和非I/O任务的执行时间比，一个用来重建线程中的selector来规避JDK的epoll 100% CPU Bug。其实现也是依次设置各线程的状态，故不再列出。</li>
  <li>Java NIO支持HeapByteBuffer与DirectByteBuffer，Netty使用DirectByteBuffer实现零拷贝
    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ByteBuffer buffer <span class="o">=</span> ByteBuffer.allocate<span class="o">(</span>int capacity<span class="o">)</span><span class="p">;</span>
ByteBuffer buffer <span class="o">=</span> ByteBuffer.allocateDirect<span class="o">(</span>int capacity<span class="o">)</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
  <li>OioServerSocketChannel 是同步阻塞 IO 的服务端实现，它接受新的客户端连接，并为它们创建 OioSocketChannel。</li>
  <li>BIO  Stream单向 与 NIO Channel双向
ChannelInboundHandler SimpleChannelInboundHandler</li>
</ul>

<h4 id="netty-reactor多种模式-reactor模式又有别名dispatcher或者notifier">Netty Reactor多种模式, Reactor模式又有别名“Dispatcher”或者“Notifier”</h4>
<ul>
  <li>Reactor 是反应堆的意思，Reactor 模型是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。
服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式，即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch 给某进程)，是编写高性能网络服务器的必备技术之一。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">crossoverjie</span><span class="o">.</span><span class="na">cim</span><span class="o">.</span><span class="na">server</span><span class="o">.</span><span class="na">server</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">com.crossoverjie.cim.common.constant.Constants</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.crossoverjie.cim.common.protocol.CIMRequestProto</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.crossoverjie.cim.server.init.CIMServerInitializer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.crossoverjie.cim.server.util.SessionSocketHolder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">com.crossoverjie.cim.server.vo.req.SendMsgReqVO</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.bootstrap.ServerBootstrap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelFuture</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelFutureListener</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelOption</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.EventLoopGroup</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.nio.NioEventLoopGroup</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.socket.nio.NioServerSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.socket.nio.NioSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.slf4j.Logger</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.slf4j.LoggerFactory</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Component</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.annotation.PreDestroy</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>

<span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CIMServer</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="c1">// 单线程Reactor配置</span>
        <span class="nc">EventLoopGroup</span> <span class="n">singleEventLoopGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NioEventLoopGroup</span><span class="o">();</span>
        <span class="nc">EventLoopGroup</span> <span class="n">singleEventLoop</span> <span class="o">=</span> <span class="n">singleEventLoopGroup</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="nc">ServerBootstrap</span> <span class="n">bootstrapSingle</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerBootstrap</span><span class="o">()</span>
                <span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">singleEventLoop</span><span class="o">,</span> <span class="n">singleEventLoop</span><span class="o">)</span>
                <span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="nc">NioServerSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                <span class="o">.</span><span class="na">localAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="n">nettyPort</span><span class="o">))</span>
                <span class="c1">//保持长连接</span>
                <span class="o">.</span><span class="na">childOption</span><span class="o">(</span><span class="nc">ChannelOption</span><span class="o">.</span><span class="na">SO_KEEPALIVE</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
                <span class="c1">// Nagle拆包算法禁用</span>
                <span class="o">.</span><span class="na">childOption</span><span class="o">(</span><span class="nc">ChannelOption</span><span class="o">.</span><span class="na">TCP_NODELAY</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
                <span class="c1">// sync-recv个数，防止sync-blood攻击</span>
                <span class="o">.</span><span class="na">childOption</span><span class="o">(</span><span class="nc">ChannelOption</span><span class="o">.</span><span class="na">SO_BACKLOG</span><span class="o">,</span><span class="mi">1024</span><span class="o">)</span>
                <span class="o">.</span><span class="na">childHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">CIMServerInitializer</span><span class="o">());</span>

        <span class="c1">// 单Boss线程，多Worker线程，Reactor配置</span>
        <span class="nc">EventLoopGroup</span> <span class="n">eventLoopGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NioEventLoopGroup</span><span class="o">();</span>
        <span class="nc">EventLoopGroup</span> <span class="n">bossEventLoop</span> <span class="o">=</span> <span class="n">eventLoopGroup</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
        <span class="nc">EventLoopGroup</span> <span class="n">workLoopGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NioEventLoopGroup</span><span class="o">();</span>
        <span class="nc">ServerBootstrap</span> <span class="n">bootstrapSingle2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerBootstrap</span><span class="o">()</span>
                <span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">bossEventLoop</span><span class="o">,</span> <span class="n">workLoopGroup</span><span class="o">)</span>
                <span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="nc">NioServerSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                <span class="o">.</span><span class="na">localAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="n">nettyPort</span><span class="o">))</span>
                <span class="o">.</span><span class="na">childOption</span><span class="o">(</span><span class="nc">ChannelOption</span><span class="o">.</span><span class="na">SO_KEEPALIVE</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
                <span class="o">.</span><span class="na">childOption</span><span class="o">(</span><span class="nc">ChannelOption</span><span class="o">.</span><span class="na">SO_BACKLOG</span><span class="o">,</span><span class="mi">1024</span><span class="o">)</span>
                <span class="o">.</span><span class="na">childHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">CIMServerInitializer</span><span class="o">());</span>

        <span class="c1">// 多Boss线程，多Worker线程，Reactor配置</span>
        <span class="nc">EventLoopGroup</span> <span class="n">boss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NioEventLoopGroup</span><span class="o">();</span>
        <span class="nc">EventLoopGroup</span> <span class="n">work</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NioEventLoopGroup</span><span class="o">();</span>
        <span class="nc">ServerBootstrap</span> <span class="n">bootstrap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerBootstrap</span><span class="o">()</span>
                <span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">boss</span><span class="o">,</span> <span class="n">work</span><span class="o">)</span>
                <span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="nc">NioServerSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
                <span class="o">.</span><span class="na">localAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="n">nettyPort</span><span class="o">))</span>
                <span class="o">.</span><span class="na">childOption</span><span class="o">(</span><span class="nc">ChannelOption</span><span class="o">.</span><span class="na">SO_KEEPALIVE</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
                <span class="o">.</span><span class="na">childOption</span><span class="o">(</span><span class="nc">ChannelOption</span><span class="o">.</span><span class="na">SO_BACKLOG</span><span class="o">,</span><span class="mi">1024</span><span class="o">)</span>
                <span class="o">.</span><span class="na">childHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">CIMServerInitializer</span><span class="o">());</span>

        <span class="nc">ChannelFuture</span> <span class="n">future</span> <span class="o">=</span> <span class="n">bootstrap</span><span class="o">.</span><span class="na">bind</span><span class="o">().</span><span class="na">sync</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">future</span><span class="o">.</span><span class="na">isSuccess</span><span class="o">())</span> <span class="o">{</span>
            <span class="no">LOGGER</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"启动 cim server 成功"</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li><a href="https://mp.weixin.qq.com/s/66TxgxynqlQ1978_qMFSwQ">https://mp.weixin.qq.com/s/66TxgxynqlQ1978_qMFSwQ</a></li>
  <li><a href="https://github.com/code4craft/netty-learning/blob/master/posts/ch4-reactor.md">https://github.com/code4craft/netty-learning/blob/master/posts/ch4-reactor.md</a></li>
  <li><a href="https://mp.weixin.qq.com/s/csslzxEGTRX1WnK5Qp8jWQ">https://mp.weixin.qq.com/s/csslzxEGTRX1WnK5Qp8jWQ</a></li>
  <li><a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=2043&amp;highlight=netty">http://www.52im.net/forum.php?mod=viewthread&amp;tid=2043&amp;highlight=netty</a></li>
</ul>

<h4 id="操作系统zero-copy">操作系统Zero-Copy</h4>
<pre>
1. ReadBuffer copyTo AppBuffer
2. AppBuffer  copyTo SocketBuffer
3. SocketBuffer  copyTo  NIC Buffer
通过transferTo()，减少了从内核态copyTo用户态，演变为
1. ReadBuffer copyTo SocketBuffer
3. SocketBuffer  copyTo  NIC Buffer
通过sendfile，去除了SocketBuffer，演变为 (Linux 2.1)
1. ReadBuffer copyTo  NIC Buffer
根据socket buffer中的位置和偏移量直接将kernel buffer的数据copy到网卡设备（protocol engine）中，演变为 (Linux 2.4)
1. 根据位置和偏移量，   NIC Buffer，直接从ReadBuffer读取
</pre>
<ul>
  <li><a href="https://www.jianshu.com/p/017f193663a0">https://www.jianshu.com/p/017f193663a0</a></li>
</ul>

<h4 id="nio本身支持dma方式的zero-copy">NIO本身支持DMA方式的Zero-Copy</h4>
<ul>
  <li>DMA(Direct Memory Access，直接存储器访问)</li>
  <li><a href="https://mp.weixin.qq.com/s/A8vc7exPDko1k1WaXuO0Og">https://mp.weixin.qq.com/s/A8vc7exPDko1k1WaXuO0Og</a></li>
</ul>

<h4 id="netty零拷贝终于讲清楚了">Netty零拷贝终于讲清楚了</h4>
<ul>
  <li>其实是靠CompositeByteBuf，把多个数组引用成同一个逻辑数组 <a href="https://cloud.tencent.com/developer/article/1488088">https://cloud.tencent.com/developer/article/1488088</a></li>
  <li>深入探秘Netty、Kafka中的零拷贝技术！ <a href="https://www.debug8.com/java/t_43617.html">https://www.debug8.com/java/t_43617.html</a></li>
</ul>

<h4 id="protocol-buffer-的序列化--反序列化简单--速度快的原因是">Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是:</h4>
<ol>
  <li>编码 / 解码 方式简单(只需要简单的数学运算 = 位移等等)</li>
  <li>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成</li>
</ol>

<h4 id="protocol-buffer-的数据压缩效果好即序列化后的数据量体积小的原因是">Protocol Buffer 的数据压缩效果好(即序列化后的数据量体积小)的原因是:</h4>
<ol>
  <li>a. 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等</li>
  <li>b. 采用 T - L - V 的数据存储方式:减少了分隔符的使用 &amp; 数据存储得紧凑</li>
</ol>

<h4 id="tcp-粘包分包的原因">TCP 粘包/分包的原因:</h4>
<ul>
  <li>应用程序写入的字节大小大于套接字发送缓冲区的大小，会发生拆包现象，而应用程序写入 数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包现 象;</li>
  <li>进行 MSS 大小的 TCP 分段，当 TCP 报文长度-TCP 头部长度&gt;MSS 的时候将发生拆包 以太网帧的 payload(净荷)大于 MTU(1500 字节)进行 ip 分片。</li>
  <li>解决方案
    <ul>
      <li>FixedLengthFrameDecoder 客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；</li>
      <li>LineBasedFrameDecoder/DelimiterBasedFrameDecoder 客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；</li>
      <li>LengthFieldBasedFrameDecoder 将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；
        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ch.pipeline<span class="o">()</span>.addLast<span class="o">(</span>new FixeLengthFrameDecoder<span class="o">(</span>31<span class="o">))</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h4 id="从零开发一个im服务端">从零开发一个IM服务端</h4>
<ul>
  <li>通俗易懂 <a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=2768&amp;highlight=netty">http://www.52im.net/forum.php?mod=viewthread&amp;tid=2768&amp;highlight=netty</a></li>
  <li>基于Netty实现海量接入的推送服务技术要点 <a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=166&amp;highlight=netty">http://www.52im.net/forum.php?mod=viewthread&amp;tid=166&amp;highlight=netty</a></li>
</ul>

<h4 id="bionioaio-有什么区别">BIO,NIO,AIO 有什么区别?</h4>
<ul>
  <li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
  <li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
  <li>
    <p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>
  </li>
  <li>BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
  <li>NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
  <li>AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>

<h4 id="必读有关为何选择netty的11个疑问及解答">必读有关“为何选择Netty”的11个疑问及解答</h4>
<ul>
  <li><a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=163&amp;highlight=netty">http://www.52im.net/forum.php?mod=viewthread&amp;tid=163&amp;highlight=netty</a></li>
</ul>

<h4 id="tcp网关">TCP网关</h4>
<p>HAProxy nginx LVS</p>
<ul>
  <li>生产环境大部分还是采用通过rest方式获取IpList，然后有客户端直接发起长连接的方式</li>
  <li>京东京麦的生产级TCP网关技术实践总结 <a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=1243&amp;highlight=netty">http://www.52im.net/forum.php?mod=viewthread&amp;tid=1243&amp;highlight=netty</a></li>
  <li>一套海量在线用户的移动端IM架构设计实践 <a href="http://www.52im.net/thread-812-1-1.html">http://www.52im.net/thread-812-1-1.html</a></li>
</ul>

<h4 id="why-nettyjdk-原生-nio-程序的问题">Why Netty?JDK 原生 NIO 程序的问题</h4>
<ul>
  <li>JDK 原生也有一套网络应用程序 API，但是存在一系列问题，主要如下：
    <ol>
      <li>NIO 的类库和 API 繁杂，使用麻烦：你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。</li>
      <li>需要具备其他的额外技能做铺垫：例如熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 NIO 程序。</li>
      <li>可靠性能力补齐，开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理等等。NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。</li>
      <li>JDK NIO 的 Bug：例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。官方声称在 JDK 1.6 版本的 update 18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 Bug 发生概率降低了一些而已，它并没有被根本解决。</li>
    </ol>
  </li>
</ul>

<h4 id="java-nio-epoll-bug-以及-netty-的解决之道">Java NIO epoll bug 以及 Netty 的解决之道</h4>
<ul>
  <li>epoll 空轮询导致 CPU 利用率 100% <a href="http://songkun.me/2019/07/26/2019-07-26-java-nio-epoll-bug-and-netty-solution/">http://songkun.me/2019/07/26/2019-07-26-java-nio-epoll-bug-and-netty-solution/</a></li>
</ul>

<h4 id="netty中的epoll实现">netty中的epoll实现</h4>
<ul>
  <li>在java中，IO多路复用的功能通过nio中的Selector提供，在不同的操作系统下jdk会通过spi的方式加载不同的实现，
比如在macos下是KQueueSelectorProvider，KQueueSelectorProvider底层使用了kqueue来进行IO多路复用；
在linux 2.6以后的版本则是EPollSelectorProvider，EPollSelectorProvider底层使用的是epoll。
虽然jdk自身提供了selector的epoll实现，netty仍实现了自己的epoll版本，根据netty开发者在StackOverflow的回答，主要原因有两个：
    <ul>
      <li>支持更多socket option，比如TCP_CORK和SO_REUSEPORT</li>
      <li>使用了边缘触发（ET）模式</li>
    </ul>
  </li>
  <li><a href="https://juejin.im/post/5d46ce64f265da03e05af722">https://juejin.im/post/5d46ce64f265da03e05af722</a></li>
  <li>ET和LT的区别在于触发事件的条件不同，LT比较符合编程思维（有满足条件的就触发），ET触发的条件更苛刻一些（仅在发生变化时才触发），对使用者的要求也更高，理论效率更高</li>
  <li>边缘触发和水平触发<a href="https://juejin.im/post/5cdaa67f518825691b4a5cc0">https://juejin.im/post/5cdaa67f518825691b4a5cc0</a></li>
</ul>

<h4 id="netty-coding">Netty Coding</h4>

<ul>
  <li>EchoServer</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">siglea</span><span class="o">.</span><span class="na">bobo</span><span class="o">.</span><span class="na">imserver</span><span class="o">.</span><span class="na">service</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">io.netty.bootstrap.ServerBootstrap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelFuture</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelInitializer</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.EventLoopGroup</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.nio.NioEventLoopGroup</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.socket.SocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.socket.nio.NioServerSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Value</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.net.InetSocketAddress</span><span class="o">;</span>

<span class="nd">@Service</span><span class="o">(</span><span class="s">"EchoServer"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EchoServer</span>
<span class="o">{</span>
    <span class="c1">// 服务器端口</span>
    <span class="nd">@Value</span><span class="o">(</span><span class="s">"${server.port}"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">port</span><span class="o">;</span>
    <span class="c1">// 通过nio方式来接收连接和处理连接</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">EventLoopGroup</span> <span class="n">boss</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NioEventLoopGroup</span><span class="o">();</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">EventLoopGroup</span> <span class="n">work</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NioEventLoopGroup</span><span class="o">();</span>

    <span class="c1">// 启动引导器</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">ServerBootstrap</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerBootstrap</span><span class="o">();</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">EchoServerHandler</span> <span class="n">echoServerHandler</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">try</span>
        <span class="o">{</span>
            <span class="n">b</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">boss</span><span class="o">,</span> <span class="n">work</span><span class="o">);</span>
            <span class="c1">// 设置nio类型的channel</span>
            <span class="n">b</span><span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="nc">NioServerSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
            <span class="c1">// 设置监听端口</span>
            <span class="n">b</span><span class="o">.</span><span class="na">localAddress</span><span class="o">(</span><span class="k">new</span> <span class="nc">InetSocketAddress</span><span class="o">(</span><span class="n">port</span><span class="o">));</span>
            <span class="c1">// 设置通道初始化</span>
            <span class="n">b</span><span class="o">.</span><span class="na">childHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">ChannelInitializer</span><span class="o">&lt;</span><span class="nc">SocketChannel</span><span class="o">&gt;()</span>
            <span class="o">{</span>
                <span class="c1">//有连接到达时会创建一个channel</span>
                <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">initChannel</span><span class="o">(</span><span class="nc">SocketChannel</span> <span class="n">ch</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>
                <span class="o">{</span>
                    <span class="c1">// pipeline管理channel中的Handler</span>
                    <span class="c1">// 在channel队列中添加一个handler来处理业务</span>
                    <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="s">"echoServerHandler"</span><span class="o">,</span><span class="n">echoServerHandler</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">});</span>
            <span class="c1">// 配置完成，开始绑定server</span>
            <span class="c1">// 通过调用sync同步方法阻塞直到绑定成功</span>

            <span class="nc">ChannelFuture</span> <span class="n">f</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="na">bind</span><span class="o">().</span><span class="na">sync</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">EchoServer</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()</span> <span class="o">+</span>
                    <span class="s">" started and listen on "</span> <span class="o">+</span> <span class="n">f</span><span class="o">.</span><span class="na">channel</span><span class="o">().</span><span class="na">localAddress</span><span class="o">());</span>

            <span class="c1">// 监听服务器关闭事件</span>
            <span class="c1">// 应用程序会一直等待，直到channel关闭</span>
            <span class="n">f</span><span class="o">.</span><span class="na">channel</span><span class="o">().</span><span class="na">closeFuture</span><span class="o">().</span><span class="na">sync</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span>
        <span class="o">{</span>
            <span class="c1">// 关闭EventLoopGroup，释放掉所有资源包括创建的线程</span>
            <span class="n">work</span><span class="o">.</span><span class="na">shutdownGracefully</span><span class="o">();</span>
            <span class="n">boss</span><span class="o">.</span><span class="na">shutdownGracefully</span><span class="o">();</span>
        <span class="o">}</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>EchoServerHandler</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">siglea</span><span class="o">.</span><span class="na">bobo</span><span class="o">.</span><span class="na">imserver</span><span class="o">.</span><span class="na">service</span><span class="o">;</span>


<span class="kn">import</span> <span class="nn">io.netty.buffer.Unpooled</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelFutureListener</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelHandlerContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelInboundHandlerAdapter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.util.CharsetUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.util.ReferenceCountUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

<span class="nd">@Service</span><span class="o">(</span><span class="s">"echoServerHandler"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EchoServerHandler</span> <span class="kd">extends</span> <span class="nc">ChannelInboundHandlerAdapter</span>
<span class="o">{</span>

    <span class="cm">/**
     * 建立连接时，发送一条消息
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">channelActive</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"连接的客户端地址:"</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">.</span><span class="na">channel</span><span class="o">().</span><span class="na">remoteAddress</span><span class="o">());</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">channelActive</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">channelRead</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">try</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"server received data :"</span> <span class="o">+</span> <span class="n">msg</span><span class="o">);</span>
<span class="c1">//            ctx.write(msg);//写回数据，</span>
            <span class="n">ctx</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">Unpooled</span><span class="o">.</span><span class="na">copiedBuffer</span><span class="o">(</span><span class="s">"I am Server"</span><span class="o">,</span> <span class="nc">CharsetUtil</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="nc">ReferenceCountUtil</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">channelReadComplete</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">//flush掉所有写回的数据</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">writeAndFlush</span><span class="o">(</span><span class="nc">Unpooled</span><span class="o">.</span><span class="na">EMPTY_BUFFER</span><span class="o">)</span>
                <span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="nc">ChannelFutureListener</span><span class="o">.</span><span class="na">CLOSE</span><span class="o">);</span> <span class="c1">//当flush完成后关闭channel</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">exceptionCaught</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="nc">Throwable</span> <span class="n">cause</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">//捕捉异常信息</span>
        <span class="n">cause</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="c1">//出现异常时关闭channel</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>EchoClient</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">siglea</span><span class="o">.</span><span class="na">bobo</span><span class="o">.</span><span class="na">imserver</span><span class="o">.</span><span class="na">service</span><span class="o">;</span>


<span class="kn">import</span> <span class="nn">io.netty.buffer.Unpooled</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelFutureListener</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelHandlerContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelInboundHandlerAdapter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.util.CharsetUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.util.ReferenceCountUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

<span class="nd">@Service</span><span class="o">(</span><span class="s">"echoServerHandler"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EchoServerHandler</span> <span class="kd">extends</span> <span class="nc">ChannelInboundHandlerAdapter</span>
<span class="o">{</span>

    <span class="cm">/**
     * 建立连接时，发送一条消息
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">channelActive</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"连接的客户端地址:"</span> <span class="o">+</span> <span class="n">ctx</span><span class="o">.</span><span class="na">channel</span><span class="o">().</span><span class="na">remoteAddress</span><span class="o">());</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">channelActive</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">channelRead</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">try</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"server received data :"</span> <span class="o">+</span> <span class="n">msg</span><span class="o">);</span>
<span class="c1">//            ctx.write(msg);//写回数据，</span>
            <span class="n">ctx</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">Unpooled</span><span class="o">.</span><span class="na">copiedBuffer</span><span class="o">(</span><span class="s">"I am Server"</span><span class="o">,</span> <span class="nc">CharsetUtil</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">){</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="nc">ReferenceCountUtil</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">channelReadComplete</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">//flush掉所有写回的数据</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">writeAndFlush</span><span class="o">(</span><span class="nc">Unpooled</span><span class="o">.</span><span class="na">EMPTY_BUFFER</span><span class="o">)</span>
                <span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="nc">ChannelFutureListener</span><span class="o">.</span><span class="na">CLOSE</span><span class="o">);</span> <span class="c1">//当flush完成后关闭channel</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">exceptionCaught</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="nc">Throwable</span> <span class="n">cause</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="c1">//捕捉异常信息</span>
        <span class="n">cause</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="c1">//出现异常时关闭channel</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<ul>
  <li>EchoClientHandler</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">siglea</span><span class="o">.</span><span class="na">bobo</span><span class="o">.</span><span class="na">imclient</span><span class="o">.</span><span class="na">service</span><span class="o">;</span>


<span class="kn">import</span> <span class="nn">io.netty.buffer.ByteBuf</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.buffer.ByteBufUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.buffer.Unpooled</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelHandlerContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.ChannelInboundHandlerAdapter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.util.CharsetUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.util.ReferenceCountUtil</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

<span class="nd">@Service</span><span class="o">(</span><span class="s">"echoClientHandler"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EchoClientHandler</span> <span class="kd">extends</span> <span class="nc">ChannelInboundHandlerAdapter</span>
<span class="o">{</span>
    <span class="cm">/**
     * 此方法会在连接到服务器后被调用
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">channelActive</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">)</span>
    <span class="o">{</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"channelActive"</span><span class="o">);</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="nc">Unpooled</span><span class="o">.</span><span class="na">copiedBuffer</span><span class="o">(</span><span class="s">"Netty rocks!"</span><span class="o">,</span> <span class="nc">CharsetUtil</span><span class="o">.</span><span class="na">UTF_8</span><span class="o">));</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 业务逻辑处理
     */</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">channelRead</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="nc">Object</span> <span class="n">msg</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"channelRead"</span><span class="o">);</span>
        <span class="c1">// 如果不是protobuf类型的数据</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">msg</span> <span class="k">instanceof</span> <span class="nc">ByteBuf</span><span class="o">))</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"未知数据!"</span> <span class="o">+</span> <span class="n">msg</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">try</span>
        <span class="o">{</span>
            <span class="nc">ByteBuf</span> <span class="n">in</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ByteBuf</span><span class="o">)</span> <span class="n">msg</span><span class="o">;</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Client received: "</span> <span class="o">+</span>
                    <span class="nc">ByteBufUtil</span><span class="o">.</span><span class="na">hexDump</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">readBytes</span><span class="o">(</span><span class="n">in</span><span class="o">.</span><span class="na">readableBytes</span><span class="o">())));</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">e</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span>
        <span class="o">{</span>
            <span class="nc">ReferenceCountUtil</span><span class="o">.</span><span class="na">release</span><span class="o">(</span><span class="n">msg</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="cm">/**
     * 捕捉到异常
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">exceptionCaught</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">ctx</span><span class="o">,</span> <span class="nc">Throwable</span> <span class="n">cause</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"exceptionCaught"</span><span class="o">);</span>
        <span class="n">cause</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="n">ctx</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h4 id="netty--protobuf">Netty &amp; Protobuf</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bootstrap</span><span class="o">.</span><span class="na">handler</span><span class="o">(</span>
        <span class="k">new</span> <span class="nc">ChannelInitializer</span><span class="o">&lt;</span><span class="nc">SocketChannel</span><span class="o">&gt;()</span>
        <span class="o">{</span>
            <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initChannel</span><span class="o">(</span><span class="nc">SocketChannel</span> <span class="n">ch</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span>
            <span class="o">{</span>
                <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">ProtobufDecoder</span><span class="o">());</span>
                <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">ProtobufEncoder</span><span class="o">());</span>
                <span class="n">ch</span><span class="o">.</span><span class="na">pipeline</span><span class="o">().</span><span class="na">addLast</span><span class="o">(</span><span class="n">chatClientHandler</span><span class="o">);</span>
<span class="err">​</span>
            <span class="o">}</span>
        <span class="o">}</span>
<span class="o">);</span>
</code></pre></div></div>

<h4 id="netty--websocket">Netty &amp; WebSocket</h4>
<p><a href="https://baijiahao.baidu.com/s?id=1654057194889667404&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1654057194889667404&amp;wfr=spider&amp;for=pc</a></p>

<h4 id="netty-分布式部署">Netty 分布式部署</h4>
<ul>
  <li>接入层同时拥有 Connect 及 Transfer作用</li>
  <li>Transfer可以通过Mq方式订阅所有消息</li>
  <li>也可以通过Tranfer之间通过rpc调用或者直接发起另一组长连接</li>
</ul>

<h4 id="再说netty-的零拷">再说Netty 的零拷⻉</h4>
<h5 id="传统意义的拷">传统意义的拷⻉</h5>
<p>是在发送数据的时候，传统的实现方式是:</p>
<ol>
  <li><code class="highlighter-rouge">File.read(bytes)</code></li>
  <li><code class="highlighter-rouge">Socket.send(bytes)</code> 这种方式需要四次数据拷⻉和四次上下文切换: 1. 数据从磁盘读取到内核的read buffer</li>
  <li>数据从内核缓冲区拷⻉到用戶缓冲区</li>
  <li>数据从用戶缓冲区拷⻉到内核的socket buffer</li>
  <li>数据从内核的socket buffer拷⻉到网卡接口(硬件)的缓冲区
    <h5 id="零拷的概念">零拷⻉的概念</h5>
    <p>明显上面的第二步和第三步是没有必要的，通过java的FileChannel.transferTo方法，可以避免上面两次多余的拷⻉(当然这需要底层操作 系统支持)</p>
  </li>
  <li>调用transferTo,数据从文件由DMA引擎拷⻉到内核read buffer 2. 接着DMA从内核read buffer将数据拷⻉到网卡接口buffer 上面的两次操作都不需要CPU参与，所以就达到了零拷⻉。 3、Netty中的零拷⻉
主要体现在三个方面:
1、bytebuffer
Netty发送和接收消息主要使用bytebuffer，bytebuffer使用对外内存(DirectMemory)直接进行Socket读写。
原因:如果使用传统的堆内存进行Socket读写，JVM会将堆内存buffer拷⻉一份到直接内存中然后再写入socket，多了一次缓冲区的内存拷 ⻉。DirectMemory中可以直接通过DMA发送到网卡接口
    <h5 id="composite-buffers">Composite Buffers</h5>
    <p>传统的ByteBuffer，如果需要将两个ByteBuffer中的数据组合到一起，我们需要首先创建一个size=size1+size2大小的新的数组，然后将两 个数组中的数据拷⻉到新的数组中。但是使用Netty提供的组合ByteBuf，就可以避免这样的操作，因为CompositeByteBuf并没有真正将多 个Buffer组合起来，而是保存了它们的引用，从而避免了数据的拷⻉，实现了零拷⻉。</p>
    <h5 id="对于filechanneltransferto的使用">对于FileChannel.transferTo的使用</h5>
    <p>Netty中使用了FileChannel的transferTo方法，该方法依赖于操作系统实现零拷⻉。</p>
  </li>
</ol>

<h4 id="netty-报文加密">Netty 报文加密</h4>
<ul>
  <li>AESencoder/AESdecoder
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyProtobufEncoder</span> <span class="kd">extends</span> <span class="nc">MessageToMessageEncoder</span><span class="o">&lt;</span><span class="nc">ByteBuf</span><span class="o">&gt;</span> <span class="o">{</span>
 
  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">encode</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">channelHandlerContext</span><span class="o">,</span> <span class="nc">ByteBuf</span> <span class="n">byteBuf</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="kt">byte</span> <span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">byteBuf</span><span class="o">.</span><span class="na">readableBytes</span><span class="o">()];</span>
      <span class="n">byteBuf</span><span class="o">.</span><span class="na">readBytes</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
      <span class="kt">byte</span> <span class="o">[]</span> <span class="n">encoded</span> <span class="o">=</span> <span class="nc">AESTest</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
      <span class="nc">ByteBuf</span> <span class="n">buf</span> <span class="o">=</span> <span class="nc">Unpooled</span><span class="o">.</span><span class="na">wrappedBuffer</span><span class="o">(</span><span class="n">encoded</span><span class="o">);</span>
      <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span>
 
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyProtobufDecoder</span> <span class="kd">extends</span> <span class="nc">MessageToMessageDecoder</span><span class="o">&lt;</span><span class="nc">ByteBuf</span><span class="o">&gt;</span> <span class="o">{</span>
 
  <span class="nd">@Override</span>
  <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">decode</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">channelHandlerContext</span><span class="o">,</span> <span class="nc">ByteBuf</span> <span class="n">byteBuf</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
      <span class="kt">byte</span> <span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">byteBuf</span><span class="o">.</span><span class="na">readableBytes</span><span class="o">()];</span>
      <span class="n">byteBuf</span><span class="o">.</span><span class="na">readBytes</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
      <span class="kt">byte</span> <span class="o">[]</span> <span class="n">encoded</span> <span class="o">=</span> <span class="nc">AESTest</span><span class="o">.</span><span class="na">decode</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
      <span class="nc">ByteBuf</span> <span class="n">buf</span> <span class="o">=</span> <span class="nc">Unpooled</span><span class="o">.</span><span class="na">wrappedBuffer</span><span class="o">(</span><span class="n">encoded</span><span class="o">);</span>
      <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>RSAencoder/RSAdecoder
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyProtobufClientEncoder</span> <span class="kd">extends</span> <span class="nc">MessageToMessageEncoder</span><span class="o">&lt;</span><span class="nc">ByteBuf</span><span class="o">&gt;</span> <span class="o">{</span>
 
 <span class="nd">@Override</span>
 <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">encode</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">channelHandlerContext</span><span class="o">,</span> <span class="nc">ByteBuf</span> <span class="n">byteBuf</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
     <span class="kt">byte</span> <span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">byteBuf</span><span class="o">.</span><span class="na">readableBytes</span><span class="o">()];</span>
     <span class="n">byteBuf</span><span class="o">.</span><span class="na">readBytes</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
     <span class="kt">byte</span> <span class="o">[]</span> <span class="n">encoded</span> <span class="o">=</span> <span class="nc">RSACoder</span><span class="o">.</span><span class="na">encryptByPublicKey</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
     <span class="nc">ByteBuf</span> <span class="n">buf</span> <span class="o">=</span> <span class="nc">Unpooled</span><span class="o">.</span><span class="na">wrappedBuffer</span><span class="o">(</span><span class="n">encoded</span><span class="o">);</span>
     <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span>
 
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyProtobufServerDecoder</span> <span class="kd">extends</span> <span class="nc">MessageToMessageDecoder</span><span class="o">&lt;</span><span class="nc">ByteBuf</span><span class="o">&gt;</span> <span class="o">{</span>
 
 <span class="nd">@Override</span>
 <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">decode</span><span class="o">(</span><span class="nc">ChannelHandlerContext</span> <span class="n">channelHandlerContext</span><span class="o">,</span> <span class="nc">ByteBuf</span> <span class="n">byteBuf</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
     <span class="kt">byte</span> <span class="o">[]</span> <span class="n">bytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="n">byteBuf</span><span class="o">.</span><span class="na">readableBytes</span><span class="o">()];</span>
     <span class="n">byteBuf</span><span class="o">.</span><span class="na">readBytes</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
     <span class="kt">byte</span> <span class="o">[]</span> <span class="n">encoded</span> <span class="o">=</span> <span class="nc">RSACoder</span><span class="o">.</span><span class="na">decryptByPrivateKey</span><span class="o">(</span><span class="n">bytes</span><span class="o">);</span>
     <span class="nc">ByteBuf</span> <span class="n">buf</span> <span class="o">=</span> <span class="nc">Unpooled</span><span class="o">.</span><span class="na">wrappedBuffer</span><span class="o">(</span><span class="n">encoded</span><span class="o">);</span>
     <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">buf</span><span class="o">);</span>
 <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li><a href="https://www.cnblogs.com/silyvin/articles/11827030.html">https://www.cnblogs.com/silyvin/articles/11827030.html</a></li>
</ul>

<h4 id="看一看">看一看</h4>
<ul>
  <li><a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=2768&amp;highlight=netty">http://www.52im.net/forum.php?mod=viewthread&amp;tid=2768&amp;highlight=netty</a></li>
  <li><a href="http://www.52im.net/thread-2775-1-1.html">http://www.52im.net/thread-2775-1-1.html</a></li>
  <li>Netty精粹之JAVA NIO开发需要知道的 <a href="https://my.oschina.net/andylucc/blog/614295">https://my.oschina.net/andylucc/blog/614295</a></li>
  <li>通俗易懂 <a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=2768&amp;highlight=netty">http://www.52im.net/forum.php?mod=viewthread&amp;tid=2768&amp;highlight=netty</a></li>
  <li>基于Netty实现海量接入的推送服务技术要点 <a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=166&amp;highlight=netty">http://www.52im.net/forum.php?mod=viewthread&amp;tid=166&amp;highlight=netty</a></li>
  <li>游戏服务 <a href="https://www.jianshu.com/p/82212eb7d76c">https://www.jianshu.com/p/82212eb7d76c</a></li>
  <li>Netty整合SpringBoot并使用Protobuf进行数据传输 <a href="https://juejin.im/post/5bb596196fb9a05d0f16f006">https://juejin.im/post/5bb596196fb9a05d0f16f006</a></li>
  <li>Netty随笔<a href="https://www.cnblogs.com/silyvin/category/1294168.html">https://www.cnblogs.com/silyvin/category/1294168.html</a></li>
</ul>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/05/18/Netty.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/05/01/BigData.html"> BigData </a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>May 1, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/05/01/BigData.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>BigData</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<p>Hadoop官方教程 <a href="http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html">http://hadoop.apache.org/docs/r1.0.4/cn/quickstart.html</a>
<img src="/img/bigdata.jpeg" width="600px" /></p>
<h4 id="hadoop基础知识">Hadoop基础知识</h4>
<ul>
  <li>HDFS
    <ul>
      <li>NameNode：FsImage、Editlog（HDFS日志文件）</li>
      <li>Secondary NameNode</li>
      <li>DataNode</li>
    </ul>
  </li>
  <li>MapReduce
    <ul>
      <li>JobTracker</li>
      <li>TaskTracker
        <ul>
          <li>MapTask</li>
          <li>ReduceTask</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>NameNodeHA方案
    <ul>
      <li>Secondary NN会定期的从NN中读取editlog，与自己存储的Image进行合并形成新的metadata image</li>
      <li>backup NN实时得到editlog，当NN宕掉后，手动切换到Backup NN；</li>
      <li>Avatar NameNode，这是Facebook提供的一种HA方案，将client访问hadoop的editlog放在NFS中，Standby NN能够实时拿到editlog；DataNode需要同时与Active NN和Standby NN report block信息；</li>
      <li>Hadoop HA 是 Hadoop 2.x 中新添加的特性，包括 NameNode HA 和 ResourceManager HA。</li>
    </ul>
  </li>
</ul>

<h4 id="storm基础知识">Storm基础知识</h4>
<ul>
  <li>Nimbus：负责在集群里面发送代码，分配工作给机器，并且监控状态。全局只有一个。相当于master的角色。</li>
  <li>Supervisor：监听分配给它那台机器的工作，根据需要启动/关闭工作进程Worker。每一个要运行Storm的机器上都要部署一个，并且，按照机器的配置设定上面分配的槽位数。</li>
  <li>zookeeper：Storm重点依赖的外部资源。Nimbus和Supervisor甚至实际运行的Worker都是把心跳保存在Zookeeper上的。Nimbus也是根据Zookeerper上的心跳和任务运行状况，进行调度和任务分配的。两者之间的调度器。</li>
  <li>Spout：在一个topology中产生源数据流的组件。通常情况下spout会从外部数据源中读取数据，然后转换为topology内部的源数据。Spout是一个主动的角色，其接口中有个nextTuple()函数，storm框架会不停地调用此函数，用户只要在其中生成源数据即可。</li>
  <li>Bolt：在一个topology中接受数据然后执行处理的组件。Bolt可以执行过滤、函数操作、合并、写数据库等任何操作。Bolt是一个被动的角色，其接口中有个execute(Tuple input)函数,在接受到消息后会调用此函数，用户可以在其中执行自己想要的操作。</li>
  <li>Topology：storm中运行的一个实时应用程序，因为各个组件间的消息流动形成逻辑上的一个拓扑结构。</li>
  <li>Worker：具体处理组建逻辑的进程，</li>
  <li>Task：不再与物理进程对应，是处理任务的线程，</li>
  <li>Stream：源源不断传递的tuple就组成了stream。</li>
  <li>Tuple:一次消息传递的基本单元。本来应该是一个key-value的map，但是由于各个组件间传递的tuple的字段名称已经事先定义好，所以tuple中只要按序填入各个value就行了，所以就是一个value list.</li>
  <li>一个 spout 向拓扑提供数据，多个 bolt 完成统计任务</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="n">storm</span><span class="o">.</span><span class="na">analytics</span><span class="o">;</span>
<span class="o">...</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TopologyStarter</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Logger</span><span class="o">.</span><span class="na">getRootLogger</span><span class="o">().</span><span class="na">removeAllAppenders</span><span class="o">();</span>
        <span class="nc">TopologyBuilder</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TopologyBuilder</span><span class="o">();</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">setSpout</span><span class="o">(</span><span class="s">"read-feed"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">UsersNavigationSpout</span><span class="o">(),</span><span class="mi">3</span><span class="o">);</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"get-categ"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">GetCategoryBolt</span><span class="o">(),</span><span class="mi">3</span><span class="o">)</span>
               <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"read-feed"</span><span class="o">);</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"user-history"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">UserHistoryBolt</span><span class="o">(),</span><span class="mi">5</span><span class="o">)</span>
               <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"get-categ"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Fields</span><span class="o">(</span><span class="s">"user"</span><span class="o">));</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"product-categ-counter"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">ProductCategoriesCounterBolt</span><span class="o">(),</span><span class="mi">5</span><span class="o">)</span>
               <span class="o">.</span><span class="na">fieldsGrouping</span><span class="o">(</span><span class="s">"user-history"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Fields</span><span class="o">(</span><span class="s">"product"</span><span class="o">));</span>
        <span class="n">builder</span><span class="o">.</span><span class="na">setBolt</span><span class="o">(</span><span class="s">"news-notifier"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">NewsNotifierBolt</span><span class="o">(),</span><span class="mi">5</span><span class="o">)</span>
               <span class="o">.</span><span class="na">shuffleGrouping</span><span class="o">(</span><span class="s">"product-categ-counter"</span><span class="o">);</span>

        <span class="nc">Config</span> <span class="n">conf</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Config</span><span class="o">();</span>
        <span class="n">conf</span><span class="o">.</span><span class="na">setDebug</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
        <span class="n">conf</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"redis-host"</span><span class="o">,</span><span class="no">REDIS_HOST</span><span class="o">);</span>
        <span class="n">conf</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"redis-port"</span><span class="o">,</span><span class="no">REDIS_PORT</span><span class="o">);</span>
        <span class="n">conf</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"webserver"</span><span class="o">,</span> <span class="no">WEBSERVER</span><span class="o">);</span>

        <span class="nc">LocalCluster</span> <span class="n">cluster</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LocalCluster</span><span class="o">();</span>
        <span class="n">cluster</span><span class="o">.</span><span class="na">submitTopology</span><span class="o">(</span><span class="s">"analytics"</span><span class="o">,</span> <span class="n">conf</span><span class="o">,</span> <span class="n">builder</span><span class="o">.</span><span class="na">createTopology</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>  
</code></pre></div></div>
<ul>
  <li>Storm教程 <a href="https://www.w3cschool.cn/storm/qk761jzb.html">https://www.w3cschool.cn/storm/qk761jzb.html</a></li>
</ul>

<h4 id="storm命名方式">Storm命名方式</h4>
<ul>
  <li>Storm暴风雨：其组件大多也以气象名词命名</li>
  <li>spout龙卷：形象的理解是把原始数据卷进Storm流式计算中</li>
  <li>bolt雷电：从spout或者其他bolt中接收数据进行处理或者输出</li>
  <li>nimbus雨云：主控节点，存在单点问题，不过可以用watchdog来保证其可用性，fast-fail后马上就启动</li>
  <li>topology拓扑：Storm的任务单元，形象的理解拓扑的点是spout或者bolt，之间的数据流是线，整个构成一个拓扑</li>
</ul>

<h4 id="storm为什么接kafka">storm为什么接Kafka</h4>
<ul>
  <li>系统解耦</li>
  <li>storm没有自己的存储只负责计算</li>
  <li>可以通过kafka控制流量</li>
</ul>

<h4 id="storm应用场景">Storm应用场景</h4>
<ul>
  <li>日志分析，例如应用系统产生大量的业务日志，这些例如网关系统的API调用情况日志，这些日志，不太适合马上存入数据库，需要进行加工，日志文件的量又非常大，所以没法直接统计，这时候可以通过Storm来进行分析。</li>
  <li>大数据实时统计，互联网的数据量是海量的时候，没有办法在数据库层面直接SQL来进行统计，需要对于产生的数据，进行二次加工，然后产出结果，正好把实时变化的数据流到storm中处理一遍。</li>
  <li>一淘-实时分析系统pora：实时分析用户的属性，并反馈给搜索引擎。最初，用户属性分析是通过每天在云梯上定时运行的MR job来完成的。为了满足实时性的要求，希望能够实时分析用户的行为日志，将最新的用户属性反馈给搜索引擎，能够为用户展现最贴近其当前需求的结果。</li>
  <li>携程-网站性能监控：实时分析系统监控携程网的网站性能。利用HTML5提供的performance标准获得可用的指标，并记录日志。Storm集群实时分析日志和入库。使用DRPC聚合成报表，通过历史数据对比等判断规则，触发预警事件。</li>
  <li>收集游戏中的数据，运营或者开发者可以在上线后几秒钟得到持续不断更新的游戏监控报告和分析结果，然后马上针对游戏的参数和平衡性进行调整。这样就能够大大缩短游戏迭代周期，加强游戏的生命力（实际上，zynga就是这么干的！虽然使用的不是Storm……Zynga研发之道探秘：用数据说话）</li>
  <li>推荐系统：有时候在实时处理时会从mysql及hadoop中获取数据库中的信息，例如在电影推荐系统中，传入数据为：用户当前点播电影信息，从数据库中获取的是该用户之前的一些点播电影信息统计，例如点播最多的电影类型、最近点播的电影类型，及其社交关系中点播信息，结合本次点击及从数据库中获取的信息，生成推荐数据，推荐给该用户。并且该次点击记录将会更新其数据库中的参考信息，这样就是实现了简单的智能推荐。</li>
</ul>

<h4 id="hdfshive-与-hbasephoenix的区别">HDFS+Hive 与 HBase+Phoenix的区别</h4>
<ul>
  <li>Hive中的表是纯逻辑表，就只是表的定义等，即表的元数据。Hive本身不存储数据，它完全依赖HDFS和MapReduce。这样就可以将结构化的数据文件映射为为一张数据库表，并提供完整的SQL查询功能，并将SQL语句最终转换为MapReduce任务进行运行。 而HBase表是物理表，适合存放非结构化的数据。
    <ol>
      <li>两者分别是什么？
        <ul>
          <li>Apache Hive是数据仓库。通过Hive可以使用HQL语言查询存放在HDFS上的数据。HQL是一种类SQL语言，这种语言最终被转化为Map/Reduce. 虽然Hive提供了SQL查询功能，但是Hive不能够进行交互查询–因为它是基于MapReduce算法。</li>
          <li>Apache Hbase Key/Value，基础单元是cell，它运行在HDFS之上。和Hive不一样，Hbase的能够在它的数据库上实时运行，而不是运行MapReduce任务。</li>
        </ul>
      </li>
      <li>两者的特点
        <ul>
          <li>Hive帮助熟悉SQL的人运行MapReduce任务。因为它是JDBC兼容的。运行Hive查询会花费很长时间，因为它会默认遍历表中所有的数据。但可以通过Hive的分区来控制。因为这样一来文件大小是固定的，就这么大一块存储空间，从固定空间里查数据是很快的。</li>
          <li>HBase通过存储key/value来工作。注意版本的功能。你可以用Hadoop作为静态数据仓库，HBase作为数据存储，放那些进行一些操作会改变的数据。</li>
        </ul>
      </li>
      <li>限制
        <ul>
          <li>Hive目前不支持更新操作。另外，由于hive在hadoop上运行批量操作，它需要花费很长的时间，通常是几分钟到几个小时才可以获取到查询的结果。Hive必须提供预先定义好的schema将文件和目录映射到列，并且Hive与ACID不兼容。</li>
          <li>HBase查询是通过特定的语言来编写的，这种语言需要重新学习。类SQL的功能可以通过Apache Phonenix实现，但这是以必须提供schema为代价的。另外，Hbase也并不是兼容所有的ACID特性，虽然它支持某些特性。最后但不是最重要的–为了运行Hbase，Zookeeper是必须的，zookeeper是一个用来进行分布式协调的服务，这些服务包括配置服务，维护元信息和命名空间服务。</li>
        </ul>
      </li>
      <li>应用场景
        <ul>
          <li>Hive适合用来对一段时间内的数据进行分析查询，例如，用来计算趋势或者网站的日志。Hive不应该用来进行实时的查询。因为它需要很长时间才可以返回结果。</li>
          <li>Hbase非常适合用来进行大数据的实时查询。Facebook用Hbase进行消息和实时的分析。它也可以用来统计Facebook的连接数。</li>
        </ul>
      </li>
      <li>两者关系
        <ul>
          <li>Hive和Pig都可以与HBase组合使用，Hive和Pig还为HBase提供了高层语言支持，使得在HBase上进行数据统计处理变的非常简单</li>
          <li>Hive与HBase，都是在Hadoop体系使用</li>
        </ul>
      </li>
      <li>总结
        <ul>
          <li>Hive和Hbase是两种基于Hadoop的不同技术–Hive是一种类SQL的引擎，并且运行MapReduce任务，Hbase是一种在Hadoop之上的NoSQL 的Key/vale数据库。当然，这两种工具是可以同时使用的。就像用Google来搜索，用FaceBook进行社交一样，Hive可以用来进行统计查询，HBase可以用来进行实时查询，数据也可以从Hive写到Hbase，设置再从Hbase写回Hive。</li>
        </ul>
      </li>
      <li>其他
        <ul>
          <li>Pig是接近脚本方式去描述MapReduce，Hive则用的是SQL。近似理解为SQL ON Hadoop</li>
        </ul>
      </li>
      <li>Hive &amp; Mysql数据互导 sqoop</li>
    </ol>
  </li>
</ul>

<h4 id="hadoop--spark--storm">Hadoop &amp; Spark &amp; Storm</h4>
<ul>
  <li>Hadoop，是实现了MapReduce的思想，将数据切片计算来处理大量的离线数据。Hadoop处理的数据必须是已经存放在HDFS上或者类似HBase的数据库中，所以Hadoop实现的时候是通过移动计算到这些存放数据的机器上来提高效率。
适合于离线的批量数据处理适用于对实时性要求极低的场景。</li>
  <li>Storm，可以用来处理源源不断流进来的消息，处理之后将结果写入到某个存储中去。实时性方面做得极好。(可以脱离Hadoop体系单独使用)</li>
  <li>Spark，是一个基于内存计算的开源集群计算系统，目的是更快速的进行数据分析。Spark由加州伯克利大学AMP实验室Matei为主的小团队使用Scala开发，类似于Hadoop MapReduce的通用并行计算框架，Spark基于Map Reduce算法实现的分布式计算，拥有Hadoop MapReduce所具有的优点，但不同于MapReduce的是Job中间输出和结果可以保存在内存中，从而不再需要读写HDFS，因此Spark能更好地适用于数据挖掘与机器学习等需要迭代的Map Reduce的算法。
(可以简单理解为”另一种形式的MapReduce”或者是第二代”引擎”，需要在Hadoop体系使用)</li>
</ul>

<h4 id="flume--kafka--storm">flume &amp; kafka &amp; storm</h4>
<ul>
  <li>flume收集日志，推到kafka缓冲一下，storm消费计算，最终结果存储</li>
  <li>基于Flume的美团日志收集系统 <a href="https://tech.meituan.com/2013/12/09/meituan-flume-log-system-architecture-and-design.html">https://tech.meituan.com/2013/12/09/meituan-flume-log-system-architecture-and-design.html</a></li>
  <li>流式数据采集和计算 <a href="https://blog.csdn.net/yezonggang/article/details/85034069">https://blog.csdn.net/yezonggang/article/details/85034069</a></li>
  <li>Flume+Kafka+Storm+Redis构建大数据实时处理系统：实时统计网站PV、UV+展示 <a href="https://blog.51cto.com/xpleaf/2104160">https://blog.51cto.com/xpleaf/2104160</a></li>
</ul>

<h4 id="搭建单机hadoop">搭建单机Hadoop</h4>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. 配置环境变量</span>
<span class="nb">export </span><span class="nv">JAVA_HOME</span><span class="o">=</span>/home/java/jdk1.8
<span class="nb">export </span><span class="nv">JRE_HOME</span><span class="o">=</span>/home/java/jdk1.8/jre
<span class="nb">export </span><span class="nv">CLASSPATH</span><span class="o">=</span>.:<span class="nv">$JAVA_HOME</span>/lib/dt.jar:<span class="nv">$JAVA_HOME</span>/lib/tools.jar:<span class="nv">$JRE_HOME</span>/lib

<span class="nb">export </span><span class="nv">HADOOP_HOME</span><span class="o">=</span>/home/hadoop/hadoop2.8
<span class="nb">export </span><span class="nv">HADOOP_COMMON_LIB_NATIVE_DIR</span><span class="o">=</span><span class="nv">$HADOOP_HOME</span>/lib/native
<span class="nb">export </span><span class="nv">HADOOP_OPTS</span><span class="o">=</span><span class="s2">"-Djava.library.path=</span><span class="nv">$HADOOP_HOME</span><span class="s2">/lib"</span>
<span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span>.:<span class="k">${</span><span class="nv">JAVA_HOME</span><span class="k">}</span>/bin:<span class="k">${</span><span class="nv">HADOOP_HOME</span><span class="k">}</span>/bin:<span class="nv">$PATH</span>

<span class="c"># 2. 创建目录</span>
<span class="nb">mkdir</span>  /root/hadoop  
<span class="nb">mkdir</span>  /root/hadoop/tmp  
<span class="nb">mkdir</span>  /root/hadoop/var  
<span class="nb">mkdir</span>  /root/hadoop/dfs  
<span class="nb">mkdir</span>  /root/hadoop/dfs/name  
<span class="nb">mkdir</span>  /root/hadoop/dfs/data

<span class="c"># 3. 修改配置文件</span>
vim core-site.xml
vim hadoop-env.sh
vim hdfs-site.xml
vim mapred-site.xml

<span class="c"># 4. 启动</span>
bin/hadoop  namenode  <span class="nt">-format</span>
start-dfs.sh
start-yarn.sh
</code></pre></div></div>

<h4 id="搭建单机hbase">搭建单机HBase</h4>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. 搭建好Hadoop</span>
<span class="c"># 2. 创建目录</span>
<span class="nb">mkdir</span>  /root/hbase  
<span class="nb">mkdir</span>  /root/hbase/tmp  
<span class="nb">mkdir</span>  /root/hbase/pids
<span class="c"># 3. 启动</span>
./start-hbase.sh
<span class="c"># 4. 常用命令</span>
<span class="c"># 进入shell</span>
hbase shell
status
version
list <span class="c"># 列出HBase的所有的表</span>
exists <span class="s1">'test'</span> <span class="c"># 是否存在test表</span>
disable <span class="s1">'test'</span>
drop <span class="s1">'test'</span>
describe <span class="s1">'t_user'</span>

create <span class="s1">'&lt;table name&gt;'</span>,<span class="s1">'&lt;column family&gt;'</span>   <span class="c"># 其中column family 就是列族的意思</span>
create <span class="s1">'Student'</span>,<span class="s1">'Num'</span>,<span class="s1">'Name'</span>,<span class="s1">'Sex'</span>,<span class="s1">'Age'</span> <span class="c"># 列族可以指定 Version 及 TTL</span>

put &lt;table&gt;,&lt;rowkey&gt;,&lt;family:column&gt;,&lt;value&gt;,&lt;timestamp&gt;
put <span class="s1">'Student'</span>,<span class="s1">'1001'</span>,<span class="s1">'ZhangSan'</span>,male<span class="s1">','</span>23<span class="s1">'
put '</span>t1<span class="s1">','</span>rowkey001<span class="s1">','</span>f1:col1<span class="s1">','</span>value01<span class="s1">' #可以指定列族及列
delete '</span>Student<span class="s1">','</span>1001<span class="s1">','</span>Age<span class="s1">' # 删除1001的年龄列
delete '</span>Student<span class="s1">','</span>1001<span class="s1">' # 删除1001所有列

scan '</span>Student<span class="s1">' # 查询该表所有数据
scan '</span>t1<span class="s1">',{LIMIT=&gt;5} # 扫描表t1的前5条数据
scan  '</span>stu2<span class="s1">',{COLUMNS =&gt; '</span>cf1:age<span class="s1">', LIMMIT 10, STARTROW =&gt; '</span>xx<span class="s1">'} # 分页查询

count '</span>t1<span class="s1">', {INTERVAL =&gt; 100, CACHE =&gt; 500} # 查询表t1中的行数，每100条显示一次，缓存区为500

get '</span>Student<span class="s1">','</span>1001<span class="s1">' # 查看1001的数据
get '</span>t1<span class="s1">','</span>rowkey001<span class="s1">', '</span>f1:col1<span class="s1">' # 查询表t1，rowkey001中的f1下的col1的值

create '</span>Student<span class="s1">',{NAME=&gt;'</span>username<span class="s1">',VERSIONS=&gt;5} # 创建表的时候指定版本数
get '</span>Student<span class="s1">','</span>1001<span class="s1">',{COLUMN=&gt;'</span>username<span class="s1">',VERSIONS=&gt;5} # 查询指定版本的数据

alter '</span>test1<span class="s1">',{NAME=&gt;'</span>body<span class="s1">',TTL=&gt;'</span>15552000<span class="s1">'},{NAME=&gt;'</span>meta<span class="s1">', TTL=&gt;'</span>15552000<span class="s1">'} #指定TTL

</span></code></pre></div></div>
<h4 id="本地存储结构">本地存储结构</h4>
<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># /hbase/data/default/stu/8ca25fe0d49972b2efb4c36537daf1a2/cf1/d89f620da4754e1092402b577f589f8a</span>
data：目录即是Hbase自动生成的用来存储所有表数据的一个目录
default：默认的一个namespace
stu：就是一张表，其实就是一个文件夹
8ca25fe0d49972b2efb4c36537daf1a2：就是stu这张表中的一个region
cf1：就是这个region中第一个列簇所对应的一个store
d89f620da4754e1092402b577f589f8a：这就是用来存储真实数据的hfile
</code></pre></div></div>
<h4 id="hbase二级索引方案">HBase二级索引方案</h4>
<ul>
  <li>基于Coprocessor方案
    <ul>
      <li>华为的hindex</li>
      <li>Apache Phoenix</li>
      <li>Phoenix二级索引特点：
        <ul>
          <li>Covered Indexes(覆盖索引) ：把关注的数据字段也附在索引表上，只需要通过索引表就能返回所要查询的数据（列）， 所以索引的列必须包含所需查询的列(SELECT的列和WHERE的列)。</li>
          <li>Functional indexes(函数索引)： 索引不局限于列，支持任意的表达式来创建索引。</li>
          <li>Global indexes(全局索引)：适用于读多写少场景。通过维护全局索引表，所有的更新和写操作都会引起索引的更新，写入性能受到影响。 在读数据时，Phoenix SQL会基于索引字段，执行快速查询。</li>
          <li>Local indexes(本地索引)：适用于写多读少场景。 在数据写入时，索引数据和表数据都会存储在本地。在数据读取时， 由于无法预先确定region的位置，所以在读取数据时需要检查每个region（以找到索引数据），会带来一定性能（网络）开销。</li>
        </ul>
      </li>
      <li>Lily HBase Indexer</li>
      <li>Solr/es</li>
    </ul>
  </li>
</ul>

<h4 id="只能基于rowkey查询关键看如何设计">只能基于rowkey查询，关键看如何设计</h4>
<ul>
  <li>不支持where条件查询只能按照rowkey来查询</li>
  <li>RowFilter</li>
</ul>

<h4 id="hadoop-region寻址方式通过zookeepermeta">Hadoop Region寻址方式(通过zookeeper.META)</h4>
<p>第 1 步:Client 请求 ZK 获取.META.所在的 RegionServer 的地址。
第 2 步:Client 请求.META.所在的 RegionServer 获取访问数据所在的 RegionServer 地 址，client 会将.META.的相关信息 cache 下来，以便下一次快速访问。
第 3 步:Client 请求数据所在的 RegionServer，获取所需要的数据。</p>

<h4 id="hbase的写入流程">HBase的写入流程</h4>
<ul>
  <li>获取 RegionServer
第 1 步:Client 获取数据写入的 Region 所在的 RegionServer
请求写 Hlog</li>
  <li>第 2 步:请求写 Hlog, Hlog 存储在 HDFS，当 RegionServer 出现异常，需要使用 Hlog 来
恢复数据。
请求写 MemStore</li>
  <li>第 3 步:请求写 MemStore,只有当写 Hlog 和写 MemStore 都成功了才算请求写入完成。
MemStore 后续会逐渐刷到 HDFS 中。 14.1.5.2. MemStore刷盘
为了提高 Hbase 的写入性能，当写请求写入 MemStore 后，不会立即刷盘。而是会等到一 定的时候进行刷盘的操作。具体是哪些场景会触发刷盘的操作呢?总结成如下的几个场景:</li>
</ul>

<h4 id="hbase全局内存控制">HBase全局内存控制</h4>
<ol>
  <li>这个全局的参数是控制内存整体的使用情况，当所有 memstore 占整个 heap 的最大比 例的时候，会触发刷盘的操作。这个参数是 hbase.regionserver.global.memstore.upperLimit，默认为整个 heap 内存的 40%。 但这并不意味着全局内存触发的刷盘操作会将所有的 MemStore 都进行输盘，而是通过 另外一个参数 hbase.regionserver.global.memstore.lowerLimit 来控制，默认是整个 heap 内存的 35%。当 flush 到所有 memstore 占整个 heap 内存的比率为 35%的时 候，就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响，实现平滑系统负载的 目的。
MemStore 达到上限</li>
  <li>当 MemStore 的大小达到 hbase.hregion.memstore.flush.size 大小的时候会触发刷
盘，默认 128M 大小
RegionServer 的 Hlog 数量达到上限</li>
  <li>前面说到 Hlog 为了保证 Hbase 数据的一致性，那么如果 Hlog 太多的话，会导致故障 恢复的时间太长，因此 Hbase 会对 Hlog 的最大个数做限制。当达到 Hlog 的最大个数 的时候，会强制刷盘。这个参数是 hase.regionserver.max.logs，默认是 32 个。
手工触发</li>
  <li>可以通过 hbase shell 或者 java api 手工触发 flush 的操作。
关闭 RegionServer 触发</li>
  <li>在正常关闭 RegionServer 会触发刷盘的操作，全部数据刷盘后就不需要再使用 Hlog 恢
复数据。
Region 使用 HLOG 恢复完数据后触发</li>
  <li>:当 RegionServer 出现故障的时候，其上面的 Region 会迁移到其他正常的 RegionServer 上，在恢复完 Region 的数据后，会触发刷盘，当刷盘完成后才会提供给 业务访问。</li>
</ol>

<h4 id="参考">参考</h4>
<ul>
  <li>用HBase实现亿级Feed <a href="https://mp.weixin.qq.com/s/kY2hYTuE1tR6HmgdfnmyiQ">https://mp.weixin.qq.com/s/kY2hYTuE1tR6HmgdfnmyiQ</a></li>
  <li>HBase案例 <a href="https://mp.weixin.qq.com/s/ieGZq3rZ-guIsm4hIRtHDw">https://mp.weixin.qq.com/s/ieGZq3rZ-guIsm4hIRtHDw</a></li>
  <li>HBase面试题 <a href="https://www.jianshu.com/p/9ecd4367e6d0">https://www.jianshu.com/p/9ecd4367e6d0</a></li>
  <li>es结合Hbase <a href="https://zhuanlan.zhihu.com/p/87563468">https://zhuanlan.zhihu.com/p/87563468</a></li>
  <li>Hbase和Cassandra比较 <a href="https://blog.csdn.net/aa5305123/article/details/83142514">https://blog.csdn.net/aa5305123/article/details/83142514</a></li>
  <li>白话大数据 <a href="https://www.zhihu.com/question/27974418/answer/156227565">https://www.zhihu.com/question/27974418/answer/156227565</a></li>
  <li>一步步搭建Hadoop体系 <a href="https://blog.csdn.net/qazwsxpcm/article/list/2?t=1">https://blog.csdn.net/qazwsxpcm/article/list/2?t=1</a></li>
</ul>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/05/01/BigData.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/05/01/Java-SPI.html"> Java SPI </a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>May 1, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/05/01/Java-SPI.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>Java</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<p>SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。
Java SPI其实内部实现原理还是基于ClassLoader。我们可以自定义ClassLoader，结合SPI技术，就能做到接口和具体实现解耦，还能做到类隔离和对业务代码无感知的升级。
在jar包内 /META-INF/services/java.sql.Driver寻找类名（约束优于配置）。</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span>
    <span class="kd">implements</span> <span class="nc">Iterable</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span>
<span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">PREFIX</span> <span class="o">=</span> <span class="s">"META-INF/services/"</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="nc">ServiceLoader</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="nf">load</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">S</span><span class="o">&gt;</span> <span class="n">service</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">ClassLoader</span> <span class="n">cl</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">().</span><span class="na">getContextClassLoader</span><span class="o">();</span>
            <span class="k">return</span> <span class="nc">ServiceLoader</span><span class="o">.</span><span class="na">load</span><span class="o">(</span><span class="n">service</span><span class="o">,</span> <span class="n">cl</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><a href="https://blog.csdn.net/sweatOtt/article/details/83055191">https://blog.csdn.net/sweatOtt/article/details/83055191</a></p>

<p><a href="https://juejin.im/post/5af952fdf265da0b9e652de3">https://juejin.im/post/5af952fdf265da0b9e652de3</a></p>

<p><a href="https://www.jianshu.com/p/46b42f7f593c">https://www.jianshu.com/p/46b42f7f593c</a></p>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/05/01/Java-SPI.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/05/01/Dubbo.html"> Dubbo </a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>May 1, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/05/01/Dubbo.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>微服务</span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>分布式</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<h3 id="dubbo">Dubbo</h3>
<ul>
  <li>官网 <a href="http://dubbo.apache.org/">http://dubbo.apache.org/</a></li>
  <li>start <a href="http://start.dubbo.io/">http://start.dubbo.io/</a></li>
  <li>Dubbo实践 <a href="https://www.cnblogs.com/warehouse/tag/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/">https://www.cnblogs.com/warehouse/tag/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/</a></li>
  <li>通俗易懂的 Dubbo 教程 <a href="https://blog.csdn.net/Geffin/category_9931110.html">https://blog.csdn.net/Geffin/category_9931110.html</a></li>
  <li>Java RMI &amp; Dubbo <a href="http://dubbo.apache.org/zh-cn/blog/dubbo-101.html">http://dubbo.apache.org/zh-cn/blog/dubbo-101.html</a></li>
</ul>

<h4 id="dubbo是什么">Dubbo是什么？</h4>
<ul>
  <li>dubbo是一个分布式框架，远程服务调用的分布式框架，其核心部分包含:
    <ul>
      <li>自动发现:基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li>
      <li>远程通讯:提供对多种基于⻓连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li>
      <li>集群容错:提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li>
    </ul>
  </li>
</ul>

<h4 id="dubbo组成">Dubbo组成</h4>
<ul>
  <li>provider:暴露服务的服务提供方</li>
  <li>consumer:调用远程服务的服务消费方</li>
  <li>registry:服务注册于发现的注册中心</li>
  <li>monitor:统计服务调用次数和调用时间的监控中心</li>
  <li>container:服务运行容器</li>
</ul>

<h4 id="dubbo架构4大层10小层">Dubbo架构4大层10小层</h4>
<p><img src="/img/dubbo1.jpg" width="600px" /></p>
<ol>
  <li>服务接口层（Service）</li>
  <li>配置代理层（配置层、服务代理层、服务注册层）</li>
  <li>路由监控（集群层、监控层）</li>
  <li>
    <p>传输层 （协议层由invoker转变为exporter、信息交换 异步/同步转、网络传输、序列化）
<img src="/img/dubbo2.jpg" width="600px" /></p>
  </li>
  <li>服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</li>
  <li>配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。</li>
  <li>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。</li>
  <li>服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。</li>
  <li>集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。</li>
  <li>监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。</li>
  <li>远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</li>
  <li>信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。</li>
  <li>网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。</li>
  <li>数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。</li>
</ol>

<p><img src="/img/dubbo3.jpg" width="600px" /></p>

<h4 id="dubbo-exporter是真正的发布">Dubbo Exporter是真正的发布</h4>
<ul>
  <li>Invoker经过协议层变成真正的服务暴露exporter
<img src="/img/exporter.jpg" width="600px" /></li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exporter&lt;?&gt; exporter <span class="o">=</span> protocol.export<span class="o">(</span>wrapperInvoker<span class="o">)</span>
</code></pre></div></div>
<ul>
  <li>Dubbo 会在 Spring 实例化完 bean 之后，在刷新容器最后一步发布 ContextRefreshEvent 事件的时候，
通知实现了 ApplicationListener 的 ServiceBean 类进行回调 onApplicationEvent 事件方法，
Dubbo 会在这个方法中调用 ServiceBean 父类 ServiceConfig 的 export 方法，而该方法真正实现了服务的(异步或者非异步)发 布。</li>
</ul>

<h4 id="dubbo27新特性">Dubbo2.7新特性</h4>
<ul>
  <li>异步化改造
    <ul>
      <li>请求调用方式
        <ul>
          <li>oneway 指的是客户端发送消息后，不需要接受响应。对于那些不关心服务端响应的请求，比较适合使用 oneway 通信。</li>
          <li>sync 是最常用的通信方式，也是默认的通信方法。</li>
          <li>异步 future 在接收响应时，future.get() 会导致线程的阻塞;</li>
          <li>异步 callback 通常会设置一个回调线程，当接收到响应时，自动执行，不会对当前线程造成阻塞。</li>
        </ul>

        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  AsyncService.sayHello<span class="o">(</span><span class="s2">"Han Meimei"</span><span class="o">)</span><span class="p">;</span>
  Future&lt;String&gt; fooFuture <span class="o">=</span> RpcContext.getContext<span class="o">()</span>.getFuture<span class="o">()</span><span class="p">;</span>
  fooFuture.get<span class="o">()</span><span class="p">;</span>
  <span class="c"># 2.7 前后</span>
  CompletableFuture&lt;String&gt; future <span class="o">=</span> asyncService.sayHiAsync<span class="o">(</span><span class="s2">"Han MeiMei"</span><span class="o">)</span><span class="p">;</span>
  future.whenComplete<span class="o">((</span>retValue, exception<span class="o">)</span> -&gt; <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span>exception <span class="o">==</span> null<span class="o">)</span> <span class="o">{</span>
          System.out.println<span class="o">(</span>retValue<span class="o">)</span><span class="p">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          exception.printStackTrace<span class="o">()</span><span class="p">;</span>
      <span class="o">}</span>
  <span class="o">})</span><span class="p">;</span>
  <span class="c"># Dubbo 2.7 中使用了 JDK1.8 提供的 CompletableFuture 原生接口对自身的异步化做了改进。</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>三大中心改造
    <ul>
      <li>注册中心
        <ul>
          <li>简化到只做服务注册</li>
        </ul>
      </li>
      <li>元数据中心
        <ul>
          <li>生产者端注册 30+ 参数，有接近一半是不需要作为注册中心进行传递；消费者端注册 25+ 参数，只有个别需要传递给注册中心。有了以上的理论分析，Dubbo 2.7 进行了大刀阔斧的改动，只将真正属于服务治理的数据发布到注册中心之中，大大降低了注册中心的负荷。
同时，将全量的元数据发布到另外的组件中：元数据中心。元数据中心目前支持 redis（推荐），zookeeper。</li>
        </ul>
      </li>
      <li>配置中心
        <ul>
          <li>衡量配置中心的必要性往往从三个角度出发：
            <ul>
              <li>分布式配置统一管理</li>
              <li>动态变更推送</li>
              <li>安全性</li>
            </ul>
          </li>
          <li>Spring Cloud Config, Apollo, Nacos 等分布式配置中心组件都对上述功能有不同程度的支持。在 2.7 之前的版本中，在 zookeeper 中设置了部分节点：configurators，routers，用于管理部分配置和路由信息，它们可以理解为 Dubbo 配置中心的雏形。在 2.7 中，Dubbo 正式支持了配置中心，目前支持的几种注册中心 Zookeeper，Apollo，Nacos（2.7.1-release 支持）。</li>
          <li>在 Dubbo 中，配置中心主要承担了两个作用
            <ul>
              <li>外部化配置。启动配置的集中式存储</li>
              <li>服务治理。服务治理规则的存储与通知</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>服务治理增强，我更倾向于将 Dubbo 当做一个服务治理框架，而不仅仅是一个 RPC 框架。在 2.7 中，Dubbo 对其服务治理能力进行了增强，增加了标签路由的能力，并抽象出了应用路由和服务路由的概念。</li>
  <li><a href="http://dubbo.apache.org/zh-cn/blog/dubbo-27-features.html">http://dubbo.apache.org/zh-cn/blog/dubbo-27-features.html</a></li>
</ul>

<h4 id="dubbo-哪些坑">Dubbo 哪些坑</h4>
<ul>
  <li>超时重试</li>
  <li>子类继承父类的属性，反序列化丢失</li>
  <li>首先需要说明的是，出现这个问题有一定的条件。如果Provider中的api和自定义Exception定义都是在一个api.jar中，那么是不会有任何问题的。但是如果自定义Exception是在一个单独的比如common.jar包中就会出现这个问题（此时api和model在另一个api.jar中）。</li>
  <li><a href="https://www.jianshu.com/p/1a281eb505df?tdsourcetag=s_pctim_aiomsg">https://www.jianshu.com/p/1a281eb505df?tdsourcetag=s_pctim_aiomsg</a></li>
  <li><a href="https://www.cnblogs.com/coding-night/articles/10656806.html">https://www.cnblogs.com/coding-night/articles/10656806.html</a></li>
  <li><a href="https://blog.csdn.net/u013256816/article/details/102674846">https://blog.csdn.net/u013256816/article/details/102674846</a></li>
</ul>

<h4 id="dubbo-哪些漏洞">Dubbo 哪些漏洞？</h4>
<ul>
  <li>Apache Dubbo存在反序列化漏洞，当网站安装了Apache Dubbo并且启用http协议进行通信时，
  攻击者可以向网站发送POST请求，在请求里可以执行一个反序列化的操作，由于没有任何安全校验，这个反序列化过程可以执行任意代码。
  <a href="https://baijiahao.baidu.com/s?id=1658423152369425625&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1658423152369425625&amp;wfr=spider&amp;for=pc</a></li>
</ul>

<h4 id="限流降级熔断方式">限流降级熔断方式</h4>
<ul>
  <li>限流
    <ul>
      <li>漏桶</li>
      <li>令牌桶</li>
    </ul>
  </li>
  <li>Dubbo服务之RPC扩展和本地Mock <a href="https://www.cnblogs.com/hyry/p/12067497.html">https://www.cnblogs.com/hyry/p/12067497.html</a></li>
  <li>Dubbo Mock原理分析 <a href="https://mp.weixin.qq.com/s/T-4xS2LruSaBRxR8LhcrjQ">https://mp.weixin.qq.com/s/T-4xS2LruSaBRxR8LhcrjQ</a></li>
  <li>Dubbo与断路器 Hystrix 的集成 <a href="https://blog.csdn.net/Geffin/article/details/105808745">https://blog.csdn.net/Geffin/article/details/105808745</a></li>
  <li>限流降级神器-哨兵(sentinel)原理分析 <a href="https://mp.weixin.qq.com/s/g2hyp9CquEAvTe8QmPO-3g">https://mp.weixin.qq.com/s/g2hyp9CquEAvTe8QmPO-3g</a></li>
  <li>Sentinel-与-Hystrix-的对比 <a href="https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94">https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%8E-Hystrix-%E7%9A%84%E5%AF%B9%E6%AF%94</a></li>
  <li>Sentinel 为 Dubbo服务保驾护航 <a href="http://dubbo.apache.org/zh-cn/blog/sentinel-introduction-for-dubbo.html">http://dubbo.apache.org/zh-cn/blog/sentinel-introduction-for-dubbo.html</a></li>
  <li>Hystrix两种隔离模式分析 <a href="https://www.jianshu.com/p/e1a4d3bdf7c4">https://www.jianshu.com/p/e1a4d3bdf7c4</a></li>
</ul>

<h4 id="通过qos对服务进行动态控制">通过QoS对服务进行动态控制</h4>
<p>在Dubbo中，QoS Quality of Service 这个概念被用于动态的对服务进行查询和控制。
例如对获取当前提供和消费的所有服务，以及对服务进行动态的上下线，即从注册中心上进行注册和反注册操作。
<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-qos.html">http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-qos.html</a></p>

<h4 id="当一个服务接口有多种实现时怎么做">当一个服务接口有多种实现时怎么做?</h4>
<p>当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dubbo:reference</span> <span class="na">interface=</span><span class="s">"com.xxx.MenuService"</span> <span class="na">group=</span><span class="s">"*"</span> <span class="na">merger=</span><span class="s">"true"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;dubbo:method</span> <span class="na">name=</span><span class="s">"getMenuItems"</span> <span class="na">merger=</span><span class="s">"false"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/dubbo:reference&gt;</span>
</code></pre></div></div>

<h4 id="服务上线怎么兼容旧版本">服务上线怎么兼容旧版本?</h4>
<p>可以用版本号(version)过渡，多个不同版本的服务注册到注册中心，版本号不同的服务 相互间不引用。这个和服务分组的概念有一点类似。</p>
<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">version=</span><span class="s">"2.0.0"</span> <span class="nt">/&gt;</span>

<span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"barService"</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">version=</span><span class="s">"1.0.0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"barService"</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">version=</span><span class="s">"2.0.0"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;dubbo:reference</span> <span class="na">id=</span><span class="s">"barService"</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">version=</span><span class="s">"*"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>
<p><a href="https://blog.csdn.net/taojin12/article/details/106869343">https://blog.csdn.net/taojin12/article/details/106869343</a></p>

<h4 id="dubbo-的管理控制台能做什么">Dubbo 的管理控制台能做什么?</h4>
<p>管理控制台主要包含:路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡， 等管理功能。</p>

<h4 id="dubbo-内置了四种负载均衡策略分别如下">Dubbo 内置了四种负载均衡策略，分别如下：</h4>
<ul>
  <li>RandomLoadBalance：随机负载均衡，随机负载均衡是 Dubbo 默认的负载均衡策略，顾名思义，就是从多个服务提供者中随机选择一个。
  需要注意的是，Dubbo 的随机负载均衡并非是完全的随机，它有一个权重的概念，会按照权重来设置随机概率，举个例子，我们现在有两个服务提供者，一个的权重是100，另一个的权重是300，那么前者被分配的概率就为 25%，后者被分配的概率为 75%。
  我们可以对服务提供者设置不同的权重，例如对性能较好的机器设置大权重，对差一点的机器设置小一点的权重。</li>
  <li>RoundRobinLoadBalance：轮询负载均衡，即会轮询每一个服务提供者，依次对其进行调用。
  轮询负载均衡也有权重的概念，可以严格按照我们设置的比例进行分配，这个是该算法的优点，不过，该算法的缺点也很明显，可能会存在较慢的机器，那么请求会在这台机器上进行累积，很容易导致整个系统变慢。</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChangeServiceImpl</span> <span class="kd">implements</span> <span class="nc">ChangeService</span> <span class="o">{</span>

    <span class="nd">@Reference</span><span class="o">(</span><span class="n">loadbalance</span> <span class="o">=</span> <span class="s">"roundrobin"</span><span class="o">)</span>
    <span class="nc">NameService</span> <span class="n">nameService</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">change</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">nameService</span><span class="o">.</span><span class="na">updateName</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<ul>
  <li>LeastActiveLoadBalance：最少活跃调用数负载均衡，最少活跃调用数负载均衡会将请求转发至活跃调用数最少的机器上，如果有两台机器活跃数相同，会采取随机负载均衡的策略。
  什么是活跃调用数呢？每个服务维护一个活跃数计数器，该计数器存放机器未处理完的请求。当有请求产生时，会选择活跃数最小的机器去执行。
  最少活跃调用数负载均衡可以令慢的机器收到更少的请求。</li>
  <li>ConsistentHashLoadBalance：一致性哈希负载均衡，要了解这种负载均衡策略，我们首先得学习一下一致性哈希算法。不会一致性哈希算法的同学可以看一下我之前写的这篇博客，质量保证过硬：一致性哈希算法详解
                                    一致性哈希可以保证相同参数的请求一定会发送到同一台机器上，即使有机器崩溃，由于一致性哈希算法的特性与虚拟节点的存在，发往该机器的请求会被发送到其它机器上，并不会引发剧烈变动。</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>缺省只对第一个参数Hash，如果要修改，请配置
<span class="nt">&lt;dubbo:parameter</span> <span class="na">key=</span><span class="s">"hash.arguments"</span> <span class="na">value=</span><span class="s">"0,1"</span> <span class="nt">/&gt;</span>
 
缺省用160份虚拟节点，如果要修改，请配置
<span class="nt">&lt;dubbo:parameter</span> <span class="na">key=</span><span class="s">"hash.nodes"</span> <span class="na">value=</span><span class="s">"320"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<ul>
  <li><a href="http://dubbo.apache.org/zh-cn/blog/dubbo-loadbalance.html">http://dubbo.apache.org/zh-cn/blog/dubbo-loadbalance.html</a></li>
</ul>

<h4 id="dubbo集群容错">Dubbo集群容错</h4>
<p>Dubbo默认内置了一些容错策略，如果还不能满足用户需求，我们可以自定义容错策略进行配置。Dubbo 内置了以下几种容错策略：</p>
<ul>
  <li>Failover(失败自动切换)，Failover 是 Dubbo 默认的容错策略。
                 其实，Failover 是高可用的一个常用概念，服务器通常拥有主备两套机器配置，当主服务器出现故障时，会自动切换到备服务器中，从而保证了整体的高可用性。
                 当调用失败时，会根据配置的重试次数，自动从其他可用地址中重新选择一个可用的地址进行调用，直到调用成功，或者是达到重试的上限位置。
                 Failover 会自动对失败进行重试，但它也带来了一些副作用。首先，重试会增加开销，再者，重试会增加调用的响应时间，最后，在某些情况下，重试会造成资源的浪费。</li>
  <li>Failsafe(失败安全)，Failsafe 在调用失败时，会忽略此错误，并记录一条日志，同时返回一个空结果，在上游看来调用是成功的。
               Failsafe 即使失败了也不会影响整个调用流程，它的失败不影响核心业务的正确性，通常用于旁路系统或流程中，一般用于写入审计日志等操作。</li>
  <li>Failfast(快速失败)，有一些业务场景中，其操作是非幂等的，不能重复调用。这种情况下，重试并不是一个好办法，需要用到 Failfast，调用失败立即报错，让调用方来决定下一步的操作并保证业务的幂等性。</li>
  <li>Failback(失败自动恢复)，在 Failback 中，如果调用失败，则此次失败相当于 Failsafe，将返回一个空结果，但与 Failsafe 不同的是，Failback 策略会将这次调用加入内存中的失败列表中，对于这个列表中的失败调用，会在另一个线程中进行异步重试，重试如果再发生失败，则会忽略，即使重试调用成功，原来的调用方也感知不到了。因此它通常适合于对于实时性要求不高，且不需要返回值的一些异步操作。</li>
  <li>Forking(并行调用)，Forking 在第一次调用就同时发起多个调用，只要其中一个调用成功，就认为成功。在资源充足，且对于失败的容忍度较低的场景下，可以采用此策略。</li>
  <li>Broadcast(广播调用)，在某些场景下，我们可能需要对所有服务提供者进行操作，我们可以采用广播调用策略，会逐个调用所有提供者，只要任意有一个提供者出错，则认为此次调用出错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li>
</ul>

<h4 id="dubbo异步转同步">Dubbo异步转同步</h4>
<ol>
  <li>调用方请求远程服务之后，需要等待结果，此刻，请求线程应该阻塞</li>
  <li>远程服务返回结果后，唤醒请求线程，调用方得到结果</li>
</ol>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="nc">Object</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">timeout</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">RemotingException</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">timeout</span> <span class="o">=</span> <span class="nc">Constants</span><span class="o">.</span><span class="na">DEFAULT_TIMEOUT</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// isDone()方法就是判断Response是否有值(即是否有返回结果)</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">isDone</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">while</span> <span class="o">(!</span><span class="n">isDone</span><span class="o">())</span> <span class="o">{</span>
                    <span class="c1">// 超时等待</span>
                    <span class="n">done</span><span class="o">.</span><span class="na">await</span><span class="o">(</span><span class="n">timeout</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
                    <span class="c1">// 如果有返回结果了，或者，超时了，就退出循环</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">isDone</span><span class="o">()</span> <span class="o">||</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">timeout</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="c1">// 如果是超时了，就抛出异常</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">isDone</span><span class="o">())</span> <span class="o">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">TimeoutException</span><span class="o">(</span><span class="n">sent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">channel</span><span class="o">,</span> <span class="n">getTimeoutMessage</span><span class="o">(</span><span class="kc">false</span><span class="o">));</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="c1">// 远程服务正常返回结果，则返回给调用方</span>
        <span class="k">return</span> <span class="nf">returnFromResponse</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">doReceived</span><span class="o">(</span><span class="nc">Response</span> <span class="n">res</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">response</span> <span class="o">=</span> <span class="n">res</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">done</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 唤醒阻塞的线程</span>
                <span class="n">done</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">callback</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">invokeCallback</span><span class="o">(</span><span class="n">callback</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
</code></pre></div></div>
<h4 id="dubbo之令牌验证">dubbo之令牌验证</h4>
<ul>
  <li>防止消费者绕过注册中心访问提供者</li>
  <li>在注册中心控制权限，以决定要不要下发令牌给消费者</li>
  <li>注册中心可灵活改变授权方式，而不需修改或升级提供者</li>
</ul>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!--可以全局设置开启令牌验证--&gt;</span>

<span class="c">&lt;!--随机token令牌，使用UUID生成--&gt;</span>
<span class="nt">&lt;dubbo:provider</span> <span class="na">token=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
<span class="c">&lt;!--固定token令牌，相当于密码--&gt;</span>
<span class="nt">&lt;dubbo:provider</span>  <span class="na">token=</span><span class="s">"123456"</span> <span class="nt">/&gt;</span>
<span class="c">&lt;!--也可在服务级别设置：--&gt;</span>

<span class="c">&lt;!--随机token令牌，使用UUID生成--&gt;</span>
<span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">token=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
<span class="c">&lt;!--固定token令牌，相当于密码--&gt;</span>
<span class="nt">&lt;dubbo:service</span> <span class="na">interface=</span><span class="s">"com.foo.BarService"</span> <span class="na">token=</span><span class="s">"123456"</span> <span class="nt">/&gt;</span>
<span class="c">&lt;!--还可在协议级别设置：--&gt;</span>

<span class="c">&lt;!--随机token令牌，使用UUID生成--&gt;</span>
<span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">token=</span><span class="s">"true"</span> <span class="nt">/&gt;</span>
<span class="c">&lt;!--固定token令牌，相当于密码--&gt;</span>
<span class="nt">&lt;dubbo:protocol</span> <span class="na">name=</span><span class="s">"dubbo"</span> <span class="na">token=</span><span class="s">"123456"</span> <span class="nt">/&gt;</span>
</code></pre></div></div>

<h4 id="负载均衡-集群容错-服务路由">负载均衡 集群容错 服务路由</h4>
<ul>
  <li>这3个概念容易混淆。他们都描述了怎么从多个 Provider 中选择一个来进行调用。那他们到底有什么区别呢?下面我来举一个简单的例子，把这几个概念阐述清楚吧。</li>
  <li>有一个Dubbo的用户服务，在北京部署了10个，在上海部署了20个。一个杭州的服务消费方发起了一次调用，然后发生了以下的事情:</li>
  <li>根据配置的路由规则，如果杭州发起的调用，会路由到比较近的上海的20个 Provider。</li>
  <li>根据配置的随机负载均衡策略，在20个 Provider 中随机选择了一个来调用，假设随机到了第7个 Provider。</li>
  <li>结果调用第7个 Provider 失败了。</li>
  <li>根据配置的Failover集群容错模式，重试其他服务器。</li>
  <li>重试了第13个 Provider，调用成功。</li>
  <li>上面的第1，2，4步骤就分别对应了路由，负载均衡和集群容错。 Dubbo中，先通过路由，从多个 Provider 中按照路由规则，选出一个子集。再根据负载均衡从子集中选出一个 Provider 进行本次调用。如果调用失败了，根据集群容错策略，进行重试或定时重发或快速失败等。 可以看到Dubbo中的路由，负载均衡和集群容错发生在一次RPC调用的不同阶段。最先是路由，然后是负载均衡</li>
</ul>

      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/05/01/Dubbo.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    
    <div class="post-contents">
      <h2>
        <a class="post-link" href="/%E6%8A%80%E6%9C%AF/2020/04/04/SpringCloud.html"> SpringCloud </a>
      </h2>
      <span class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i>Apr 4, 2020</span>
      <span class="post-meta" style="margin-left:50px;margin-right:50px;"><i class="fa fa-comment-o">&nbsp;&nbsp;</i><a style="color:#828282" href="/%E6%8A%80%E6%9C%AF/2020/04/04/SpringCloud.html#disqus_thread"></a></span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>微服务</span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>分布式</span>
      
      <span class="post-meta" ><i class="fa fa-tags">&nbsp;&nbsp;</i>Spring</span>
      

      <div class="post-content truncate" itemprop="articleBody" style="max-height:300px;margin-top:20px;">
	<p><img src="/img/springcloud.jpg" width="600px" /></p>

<h4 id="spring">Spring</h4>
<ul>
  <li>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
    <ul>
      <li>Eureka Server的高可用实际上就是将自己作为服务向其他注册中心注册自己，这样就可以形成一组互相注册的服务注册中 心，以实现服务清单的互相同步，达到高可用效果
        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 定义服务续约任务的调用间隔时间，默认30秒</span>
eureka.instance.lease-renewal-interval-in-seconds<span class="o">=</span>30
<span class="c"># 定义服务失效的时间，默认90秒 eureka.instance.lease-expiration-duration-in-seconds=90</span>
</code></pre></div>        </div>
      </li>
      <li>该警告就是触发了Eureka Server的自我保护机制。Eureka Server在运行期间，会统计心跳失败的比例在15分钟之内是否低于 85%，如果出现低于的情况，Eureka Server会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信 息。但是，在这段保护期间内实例若出现问题，那么客戶端很容易拿到实际已经不存在的服务实例，会出现调用失败的情况，所 以客戶端必须要有容错机制，比如可以使用请求重试、断路器等机制
        <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 关闭保护机制，以确保注册中心可以将不用的实例正确剔除(本地调试可以使用，线上不推荐)</span>
eureka.server.enable-self-preservation<span class="o">=</span><span class="nb">false</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；</li>
  <li>Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；</li>
  <li>Feign：基于Ribbon和Hystrix的声明式服务调用组件；</li>
  <li>Zuul：API网关组件，对请求提供路由及过滤功能。</li>
  <li>Spring Cloud Bus
用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。
Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点/总线/刷新来实现对任何单个实例的刷新。</li>
  <li>Spring Cloud Consul
基于Hashicorp Consul的服务治理组件。</li>
  <li>Spring Cloud Security
安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</li>
  <li>Spring Cloud Sleuth
Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</li>
  <li>Spring Cloud Stream
轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。</li>
  <li>Spring Cloud Task
用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</li>
  <li>Spring Cloud Zookeeper
基于Apache Zookeeper的服务治理组件。</li>
  <li>Spring Cloud Gateway
API网关组件，对请求提供路由及过滤功能。Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。
使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。</li>
  <li>Spring Cloud OpenFeign
基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。</li>
  <li>什么是Spring Cloud Config?
    <ul>
      <li>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。
  使用：（1）添加pom依赖（2）配置文件添加相关配置（3）启动类添加注解@EnableConfigServer</li>
    </ul>

    <p><img src="/img/springconfig.jpg" width="600px" /></p>
  </li>
  <li>Spring中使用@Autowired注解静态实例对象 <a href="https://blog.csdn.net/RogueFist/article/details/79575665">https://blog.csdn.net/RogueFist/article/details/79575665</a></li>
  <li>多个ApplicationRunner，可以用@Order指定优先级串行执行的，如果优先级高的block了，后面的需要等着</li>
</ul>

<h3 id="关于微服务">关于微服务</h3>
<ul>
  <li>SOA(ESB)与微服务
    <ul>
      <li><a href="https://zhuanlan.zhihu.com/p/30477325">https://zhuanlan.zhihu.com/p/30477325</a></li>
      <li><a href="https://www.cnblogs.com/guanghe/p/10978349.html">https://www.cnblogs.com/guanghe/p/10978349.html</a></li>
      <li><a href="https://mp.weixin.qq.com/s/9YxdCkl98kZq_Bh_DqwCmA">https://mp.weixin.qq.com/s/9YxdCkl98kZq_Bh_DqwCmA</a></li>
    </ul>
  </li>
  <li>微服务哪些事
    <ul>
      <li><a href="https://windmt.com/2018/04/14/spring-cloud-0-microservices/">https://windmt.com/2018/04/14/spring-cloud-0-microservices/</a></li>
      <li><a href="https://windmt.com/2018/04/14/spring-cloud-1-services-governance/">https://windmt.com/2018/04/14/spring-cloud-1-services-governance/</a></li>
    </ul>
  </li>
  <li>SpringCloud &amp; Dubbo
    <ul>
      <li><a href="https://mp.weixin.qq.com/s/qDiSn29uqSpA0yaM07nmbQ">https://mp.weixin.qq.com/s/qDiSn29uqSpA0yaM07nmbQ</a></li>
      <li><a href="https://mp.weixin.qq.com/s/GSLXRnl0pg5ynVwbQcon7A">https://mp.weixin.qq.com/s/GSLXRnl0pg5ynVwbQcon7A</a></li>
      <li><a href="http://www.ityouknow.com/springcloud/2017/11/20/dubbo-update-again.html">阿里Dubbo与Spring Cloud</a></li>
    </ul>
  </li>
  <li>RPC之thrift/gRPC
    <ul>
      <li><a href="https://blog.csdn.net/kesonyk/article/details/50924489">https://blog.csdn.net/kesonyk/article/details/50924489</a></li>
      <li><a href="https://developer.51cto.com/art/201908/601617.htm">https://developer.51cto.com/art/201908/601617.htm</a></li>
      <li><a href="https://segmentfault.com/a/1190000011478469">https://segmentfault.com/a/1190000011478469</a></li>
      <li><a href="https://zhuanlan.zhihu.com/p/136112210">https://zhuanlan.zhihu.com/p/136112210</a></li>
      <li>RPC与HTTP的关系 <a href="https://mp.weixin.qq.com/s/0RXTUWHXDmMddsPVWej2Qg">https://mp.weixin.qq.com/s/0RXTUWHXDmMddsPVWej2Qg</a></li>
      <li>快速理解RPC技术——基本概念、原理和用途 <a href="http://www.52im.net/forum.php?mod=viewthread&amp;tid=2620">http://www.52im.net/forum.php?mod=viewthread&amp;tid=2620</a></li>
    </ul>
  </li>
  <li>WebService某种程度上也是一种RPC
    <ul>
      <li>WebService的历史 <a href="https://www.iteye.com/blog/andot-662787">https://www.iteye.com/blog/andot-662787</a></li>
      <li>WebService的demo<a href="https://blog.csdn.net/weixin_42672054/article/details/81708464">https://blog.csdn.net/weixin_42672054/article/details/81708464</a></li>
      <li>2000年左右出现xml，借此微软等联盟推出了基于XML的SOAP协议，实现各系统之间的通信</li>
      <li>thrift/webservice等可以生成客户端代码，隐藏了底层通信细节，对象化了数据（否则需要自行解析）</li>
      <li>thrift、dobbo等方式基于TCP实现，主要是性能方面的考虑吧</li>
    </ul>
  </li>
  <li>hessian / sofa</li>
</ul>

<h3 id="just-do-springcloud">Just Do SpringCloud</h3>
<ul>
  <li>首选 <a href="https://windmt.com/tags/Spring-Cloud/">https://windmt.com/tags/Spring-Cloud/</a></li>
  <li><a href="https://www.springcloud.cc/">springcloud.cc</a></li>
  <li><a href="http://springcloud.fun">springcloud.fun</a></li>
  <li><a href="https://www.zhihu.com/question/283286745/answer/763040709">大话SpringCloud</a></li>
  <li><a href="https://www.geekdigging.com">https://www.geekdigging.com</a></li>
</ul>

<h3 id="常见组件">常见组件</h3>
<ul>
  <li>服务配置中心（注册发现）：Netflix的Eureka、Apache的zookeeper、Spring家族的Spring Cloud Consul、携程apollo
    <ul>
      <li><a href="https://www.jianshu.com/p/5c5753d2aeb0">Zookeeper保证的是CP，Eureka保证的是AP</a></li>
    </ul>
  </li>
  <li>客户端负载均衡：Netflix Ribbon (提供云端负载均衡，有多种负载均衡策略可供选择，可配合服务发现和断路器使用。)
    <ul>
      <li>客户端负载均衡(Ribbon)服务实例的清单在客户端，客户端进行负载均衡算法分配。(从上面的知识我们已经知道了：客户端可以从Eureka Server中得到一份服务清单，在发送请求时通过负载均衡算法，在多个服务器之间选择一个进行访问)
Zuul路由的业务，对业务进行了归类，并交给了对应的微服务。</li>
      <li>服务端负载均衡(Nginx)服务实例的清单在服务端，服务器进行负载均衡算法分配,
Nginx路由请求的压力，对请求进行平均后，交给了服务器处理。</li>
      <li><a href="https://www.cnblogs.com/kongxianghai/p/8477781.html">撸一撸Spring Cloud Ribbon的原理-负载均衡策略</a></li>
      <li>可以使用Ribbon + resetTemplate 或者直接使用 Feign（已经内置Ribbon）来实现客户端侧的负载均衡</li>
    </ul>
  </li>
  <li>熔断器：Netflix Hystrix（Envoy)</li>
  <li>Spring Cloud Feign：它基于 Netflix Feign 实现，整合了 Spring Cloud Ribbon 与 Spring Cloud Hystrix, 除了整合这两者的强大功能之外，它还提 供了声明式的服务调用(不再通过RestTemplate)。
  生产环境一般使用restTemplate + ribbon</li>
  <li>服务网关: Netflix Zuul  、 Spring Cloud GateWay
    <ul>
      <li>Zuul相当于一个分布式的大Servlet+Filter入口可进行路由及过滤等</li>
      <li>Zuul也可以近似的理解为是SOA里的ESB，统一入口调用</li>
      <li>Zuul也默认集成了Hystrix与Ribbon</li>
    </ul>
  </li>
  <li>分布式配置：Spring Cloud Config (Chef)</li>
  <li>时间消息总线：Spring Cloud Bus</li>
  <li>链路追踪：Spring Cloud Sleuth 与 Twitter Zipkin</li>
  <li>数据流：Spring Cloud Stream (数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。)</li>
  <li>服务监控：Zabbix、Nagios、Metrics、Spectator</li>
</ul>

<h3 id="相关组件">相关组件</h3>
<h4 id="zookeeper">zookeeper</h4>
<ul>
  <li>简单理解，zk就是一套简单的文件系统结构，本目录(节点)可以设置value及subNode,
并且该节点可以设置不同的权限（默认/用户名+密码/ip/秘钥，这4种)</li>
  <li>zk集群简单理解就是，基于ZAB一致性算法的变种keep alived集群</li>
  <li>zk集群是CP模型，强一致性的，也就是说数据出现了不一致性（通常是节点挂了），整个服务集群就会Hold住等待数据一致，
所以，这个缺点导致zk并不是最佳的注册中心，因为服务注册中心AP模型最好，部分服务有问题并不表示所有服务不可用。</li>
  <li>zookeeper 命令 <a href="https://blog.csdn.net/feixiang2039/article/details/79810102">https://blog.csdn.net/feixiang2039/article/details/79810102</a></li>
  <li>Curator实现的zk分布式锁 <a href="https://www.sohu.com/a/341386202_315839">https://www.sohu.com/a/341386202_315839</a></li>
</ul>

<h3 id="基于springcloud的开源项目">基于SpringCloud的开源项目</h3>


      </div>
      <div style="height:50px;">
	<a href="/%E6%8A%80%E6%9C%AF/2020/04/04/SpringCloud.html" class="button readmore-button">Read More</a>
      </div>
    </div>
    <br />
    

    <div style="text-align:center">
    
    <div class="pagination">
      
      <a href="/page5" class="button page-button">&laquo;</a>
      

      
      
      <a href="/page5" class="button page-button">1</a>
      
      
      
      <a href="/page2" class="button page-button">2</a>
      
      
      
      <a href="/page3" class="button page-button">3</a>
      
      
      
      <a href="/page4" class="button page-button">4</a>
      
      
      
      <a href="/page5" class="button page-button">5</a>
      
      
      
      <a href="/page5" class="button current-page-button">6</a>
      
      
      
      <a href="/page7" class="button page-button">7</a>
      
      
      
      <a href="/page8" class="button page-button">8</a>
      
      
      
      <a href="/page9" class="button page-button">9</a>
      
      
      
      <a href="/page10" class="button page-button">10</a>
      
      
      
      <a href="/page11" class="button page-button">11</a>
      
      
      
      <a href="/page12" class="button page-button">12</a>
      
      
      
      <a href="/page13" class="button page-button">13</a>
      
      
      
      <a href="/page14" class="button page-button">14</a>
      
      

      
      <a href="/page7" class="button page-button">&raquo;</a>
      
    </div>
    
    </div>
  </div>

    <div class="col-md-4">
    <div class="post-contents">
      <i class="fa fa-tags">&nbsp;&nbsp; Tags</i><br />
      
      
      
      <a  href="/tag/programming">
      <span class="label label-default">programming ( 4 )</span>
      </a><br />

      
      
      
      <a  href="/tag/python">
      <span class="label label-default">python ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/云服务">
      <span class="label label-default">云服务 ( 2 )</span>
      </a><br />

      
      
      
      <a  href="/tag/工具">
      <span class="label label-default">工具 ( 3 )</span>
      </a><br />

      
      
      
      <a  href="/tag/网络">
      <span class="label label-default">网络 ( 9 )</span>
      </a><br />

      
      
      
      <a  href="/tag/构建">
      <span class="label label-default">构建 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/分布式">
      <span class="label label-default">分布式 ( 14 )</span>
      </a><br />

      
      
      
      <a  href="/tag/股票">
      <span class="label label-default">股票 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/读书笔记">
      <span class="label label-default">读书笔记 ( 4 )</span>
      </a><br />

      
      
      
      <a  href="/tag/数据库">
      <span class="label label-default">数据库 ( 7 )</span>
      </a><br />

      
      
      
      <a  href="/tag/数据结构与算法">
      <span class="label label-default">数据结构与算法 ( 10 )</span>
      </a><br />

      
      
      
      <a  href="/tag/linux">
      <span class="label label-default">Linux ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/java">
      <span class="label label-default">Java ( 12 )</span>
      </a><br />

      
      
      
      <a  href="/tag/nosql">
      <span class="label label-default">NoSQL ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/极致思考">
      <span class="label label-default">极致思考 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/架构">
      <span class="label label-default">架构 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/容器">
      <span class="label label-default">容器 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/spring">
      <span class="label label-default">Spring ( 2 )</span>
      </a><br />

      
      
      
      <a  href="/tag/微服务">
      <span class="label label-default">微服务 ( 3 )</span>
      </a><br />

      
      
      
      <a  href="/tag/bigdata">
      <span class="label label-default">BigData ( 2 )</span>
      </a><br />

      
      
      
      <a  href="/tag/mq">
      <span class="label label-default">MQ ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/安全">
      <span class="label label-default">安全 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/用户">
      <span class="label label-default">用户 ( 3 )</span>
      </a><br />

      
      
      
      <a  href="/tag/tob">
      <span class="label label-default">toB ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/策略">
      <span class="label label-default">策略 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/方法论">
      <span class="label label-default">方法论 ( 1 )</span>
      </a><br />

      
      
      
      <a  href="/tag/java">
      <span class="label label-default">java ( 2 )</span>
      </a><br />

      
    </div>
    <br />
    <div class="post-contents">
      <h3>About Me</h3>
      <img src="/img/me.jpg" style="margin:20px auto 0 auto;">
      <p style="font-size:18px;margin-top:10px">I'm Siglea,That's All.</p>
      <br />
    </div>
    </div>
</div>
      </div>
      <div class="clearfix">
    </div>

    <footer class="site-footer">

  <div class="container">

    <h2 class="footer-heading">粉笔灰杂谈</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>粉笔灰杂谈</li>
          <li><a href="mailto:siglea@sina.com">siglea@sina.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/siglea"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">siglea</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>关于产品、技术、商业的一些见解，顺便记录一下自己的生活感悟和读书笔记。</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
