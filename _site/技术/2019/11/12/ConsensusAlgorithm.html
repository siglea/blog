<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>一致性（Consistency）与 共识（Consensus）</title>
  <meta name="description" content="Byzantine Fault Tolerance 分类在分布式系统中，这种不听指挥的坏节点，就被称为“拜占庭错误节点”。一般来说，按照对“拜占庭错误节点”的容忍程度（简称BFT，Byzantine Fault Tolerance），分布式系统可以分为以下三类：  非BFT类：完全无法容忍“拜占庭错误节点”，但可...">
  <script src="/static/jquery-3.1.1.min.js"></script>
  <link rel="stylesheet" href="/static/bootstrap.min.css">
  <link rel="stylesheet" href="/static/font-awesome-4.6.3/css/font-awesome.min.css">
  <script src="/static/bootstrap.min.js"></script>
  <!-- should put bootstrap before main style sheet, otherwise it't hard to override  -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/syntax.css">
  <link rel="canonical" href="http://localhost:4000/%E6%8A%80%E6%9C%AF/2019/11/12/ConsensusAlgorithm.html">
  <link rel="alternate" type="application/rss+xml" title="粉笔灰杂谈" href="http://localhost:4000/feed.xml">
</head>

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-86140592-1', 'auto');
  ga('send', 'pageview');

</script>

  <body>

    <header class="site-header">
  <div class="container" style="text-align:center">
    <div class="navbar" style="margin-bottom:0;border:0">
    <ul class="navbar-nav nav header-nav">
    <li><a href="/index.html" class="button">首页</a></li>
      <li><a href="/category/技术" class="button">技术</a></li>
      <li><a href="/category/产品商业" class="button">产品商业</a></li>
      <li><a href="/category/随记" class="button">随记</a></li>
    </ul>
    </div>
  </div>

</header>
<div class="clearfix">


    <div class="page-content">
      <div class="container" style="padding-left:0;padding-right:0;">
        <div class="row">
  <div class="col-md-1 col-xs-0"></div>
    <div class="col-md-10 col-xs-12">
<article class="post post-contents" style="margin-bottom:30px;" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">一致性（Consistency）与 共识（Consensus）</h1>
    <p class="post-meta"><i class="fa fa-calendar">&nbsp;&nbsp;</i><time datetime="2019-11-12T10:25:00+08:00" itemprop="datePublished">Nov 12, 2019</time></p>
  </header>

  <div class="post-content" style="margin:15px;" itemprop="articleBody">
    <h4 id="byzantine-fault-tolerance-分类">Byzantine Fault Tolerance 分类</h4>
<p>在分布式系统中，这种不听指挥的坏节点，就被称为“拜占庭错误节点”。一般来说，按照对“拜占庭错误节点”的容忍程度（简称BFT，Byzantine Fault Tolerance），分布式系统可以分为以下三类：</p>
<ul>
  <li>非BFT类：完全无法容忍“拜占庭错误节点”，但可以容忍其他错误的系统。（包括Pasox、SOLO、RAFT等。）</li>
  <li>BFT类：可以容忍“拜占庭错误节点”的系统。（包括PBFT、SBFT、VBFT、DBFT等。）</li>
  <li>区块链类：不仅可以容忍“拜占庭错误节点”，还可以容忍节点的自由进出，这才是我们真正意义上的、狭义上的“区块链”。
 （包括我们熟悉的POW、POS、DPOS等等。）</li>
  <li>其实与git的版本分支管理思想是一致的</li>
</ul>

<p><a href="https://www.cnblogs.com/X-knight/p/9157814.html">https://www.cnblogs.com/X-knight/p/9157814.html</a></p>

<h4 id="一致性consistency和共识consensus">“一致性（Consistency）”和“共识（Consensus）”</h4>
<p>Paxos、Raft等通常被误称为“一致性算法”。但是“一致性（Consistency）”和“共识（Consensus）”并不是同一个概念。Paxos、Raft等其实都是共识（Consensus）算法。
从专业的角度来讲，我们通常所说的一致性（Consistency）在分布式系统中指的是对于同一个数据的多个副本，其对外表现的数据一致性，如强一致性、顺序一致性、最终一致性等，都是用来描述副本问题中的一致性的。而共识（Consensus）则不同，简单来说，共识问题是要经过某种算法使多个节点达成相同状态的一个过程。一致性强调结果，共识强调过程。
<a href="https://mp.weixin.qq.com/s/2v2E3Ls8BO1tZhv9qz5vPg">https://mp.weixin.qq.com/s/2v2E3Ls8BO1tZhv9qz5vPg</a></p>

<h4 id="一致性分类">一致性分类</h4>
<ul>
  <li>弱一致性（最终一致性）
    <ol>
      <li>DNS（Domain Name System）</li>
      <li>Gossip（Cassandra、Redis的通信协议）<a href="https://www.jianshu.com/p/54eab117e6ae">https://www.jianshu.com/p/54eab117e6ae</a></li>
    </ol>
  </li>
  <li>强一致性
    <ul>
      <li>主从同步</li>
      <li>多数一致，每次写都保证写入大于N/2个节点，每次读保证从大于N/2个节点中读。
Paxos、Raft（multi-paxos）、ZAB（multi-paxos，Zookeeper atomic broadcast protocol，是Zookeeper内部用到的一致性协议。基本与Raft相同）</li>
    </ul>
  </li>
</ul>

<h4 id="pasox">Pasox</h4>
<p>Paxos算法是莱斯利·兰伯特(Leslie Lamport)1990年提出的一种基于消息传递的一致性算法。
Paxos的发展分类：Basic Paxos、Multi Paxos、Fast Paxos</p>

<h4 id="basic-paxos-忽然发现这个过程与3pc很相似需要2次多数投票">Basic Paxos （忽然发现这个过程与3PC很相似，需要2次多数投票）</h4>
<ul>
  <li>一阶段，Proposer发出prepare()，Acceptor给出承诺promise()
    <ul>
      <li>Proposer生成全局唯一且递增的Proposal ID (可使用时间戳加Server ID)，向所有Acceptors发送Prepare请求，这里无需携带提案内容，只携带Proposal ID即可。</li>
      <li>Acceptor承诺一：不再接受Proposal ID小于等于（注意：这里是&lt;= ）当前请求的Prepare请求。</li>
      <li>Acceptor承诺二：不再接受Proposal ID小于（注意：这里是&lt; ）当前请求的Propose请求。</li>
      <li>Acceptor应答一：不违背以前作出的承诺下，回复已经Accept过的提案中Proposal ID最大的那个提案的Value和Proposal ID，没有则返回空值。</li>
    </ul>
  </li>
  <li>二阶段，Proposer发出提议propose()，Acceptor接受accept()
    <ul>
      <li>Proposer提案：Proposer收到多数Acceptors的Promise应答后，从应答中选择Proposal ID最大的提案的Value，作为本次要发起的提案。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptors发送Propose请求。</li>
      <li>Acceptor接受：Acceptor收到Propose请求后，在不违背自己之前作出的承诺下，接受并持久化当前Proposal ID和提案Value。</li>
    </ul>
  </li>
  <li>三阶段，Proposer发送最终决议
    <ul>
      <li>Proposer收到多数Acceptors的Accept后，决议形成，将形成的决议发送给所有Learners。
        <ol>
          <li><a href="https://zhuanlan.zhihu.com/p/31780743">https://zhuanlan.zhihu.com/p/31780743</a></li>
          <li><a href="https://mp.weixin.qq.com/s/j_08HupjHGHHwdyM8fsmfg">https://mp.weixin.qq.com/s/j_08HupjHGHHwdyM8fsmfg</a></li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h4 id="活锁可能会存在一种情况假定有2个proposer先后向acceptor发送请求acceptor在接收到proposer1的prepare请求后更新编号为proposer1的编号">活锁，可能会存在一种情况：假定有2个proposer先后向acceptor发送请求，acceptor在接收到proposer1的prepare请求后更新编号为proposer1的编号；</h4>
<p>此时，proposer2接着向acceptor发送比proposer1编号更大的prepare请求，acceptor会立刻更新成proposer2的编号，那么当proposer1发送accept请求时由于编号不满足要求就会被accept给拒绝掉，则重新获取编号再次回到第一阶段发送prepare请求；
从此2个proposer之间不断重复发送prepare请求，导致系统出现活锁</p>

<h4 id="如何解决split-brain问题">如何解决split brain问题</h4>
<ul>
  <li>分布式协议一个著名问题就是 split brain 问题。
简单说，就是比如当你的 cluster 里面有两个结点，它们都知道在这个 cluster 里需要选举出一个 master。那么当它们两之间的通信完全没有问题的时候，就会达成共识，选出其中一个作为 master。
但是如果它们之间的通信出了问题，那么两个结点都会觉得现在没有 master，所以每个都把自己选举成 master。于是 cluster 里面就会有两个 master。
区块链的分叉其实类似分布式系统的split brain。
一般来说，Zookeeper会默认设置：
    <ul>
      <li>zookeeper cluster的节点数目必须是奇数。</li>
      <li>zookeeper 集群中必须超过半数节点(Majority)可用，整个集群才能对外可用。</li>
    </ul>
  </li>
  <li>Majority(大多数) 就是一种 Quorum(法定代表人) 的方式来支持Leader选举，可以防止 split brain出现。奇数个节点可以在相同容错能力的情况下节省资源。</li>
</ul>

<h4 id="multi-paxos之raft-reliable-replicated-redundant-and-fault-tolerant">Multi Paxos之Raft (Reliable, Replicated, Redundant, And Fault-Tolerant)</h4>
<ul>
  <li>多个follower变身为candidate，同时term++，投票给自己同时向其他节点发送RequestVote RPC</li>
  <li>节点(N)会投票给term是最新的，log至少和自身(N)一样新的candidate</li>
  <li>candidate收到多数投票，然后发送自己已经是leader的HeartBeat，接受者转变为follower，选举结束</li>
  <li>一段时间后依然没有胜者。该种情况下会开启新一轮的选举。（Raft中使用随机选举超时时间来解决当票数相同无法确定leader的问题。）</li>
  <li>日志复制（Log Replication）主要作用是用于保证节点的一致性，这阶段所做的操作也是为了保证一致性与高可用性。
当Leader选举出来后便开始负责客户端的请求，所有事务（更新操作）请求都必须先经过Leader处理，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作。
在Raft中当接收到客户端的日志（事务请求）后先把该日志追加到本地的Log中，然后通过heartbeat把该Entry同步给其他Follower，Follower接收到日志后记录日志然后向Leader发送ACK，当Leader收到大多数（n/2+1）Follower的ACK信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个heartbeat中Leader将通知所有的Follower将该日志存储在自己的本地磁盘中。</li>
</ul>
<p><a href="https://www.cnblogs.com/binyue/p/8647733.html">https://www.cnblogs.com/binyue/p/8647733.html</a></p>

<h4 id="zab协议4阶段">ZAB协议4阶段</h4>
<ol>
  <li>Leader election(选举阶段):节点在一开始都处于选举阶段，只要有一个节点得到超半数 节点的票数，它就可以当选准 leader。只有到达 广播阶段(broadcast) 准 leader 才会成 为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。</li>
  <li>Discovery(发现阶段-接受提议、生成 epoch、接受 epoch):在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且 准 leader 生成新的 epoch，让 followers 接受，更新它们的 accepted Epoch
 一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入重新选举阶段。</li>
  <li>Synchronization(同步阶段):同步阶段主要是利用 leader 前一阶段获得的最新提议历史， 同步集群中所有的副本。只有当 大多数节点都同步完成，准 leader 才会成为真正的 leader。 follower 只会接收 zxid 比自己的 lastZxid 大的提议。</li>
  <li>Broadcast(广播阶段-leader 消息广播) Broadcast(广播阶段):到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，
    <ul>
      <li>两大阶段：让大家投票，告诉大家投票结果</li>
    </ul>
  </li>
</ol>

<h4 id="zab算法-zookeeper-atomic-broadcast-protocol">ZAB算法 Zookeeper atomic broadcast protocol</h4>
<ul>
  <li>基本与Raft相同，在一些名词叫起来是有区别的</li>
  <li>ZAB将Leader的一个生命周期叫做epoch，而Raft称之为term</li>
  <li>实现上也有些许不同，如raft保证日志的连续性，心跳是Leader向Follower发送，而ZAB方向与之相反</li>
  <li>ZAB选举阶段只接受比自己大的zxid，意味着经过多次之后，拥有最新数据的节点才有可能成为leader</li>
</ul>

<h4 id="raft-协议和-zab-协议区别">raft 协议和 zab 协议区别</h4>
<ul>
  <li>相同点
    <ul>
      <li>采用quorum来确定整个系统的一致性,这个quorum一般实现是集群中半数以上的服务器,  zookeeper里还提供了带权重的quorum实现.</li>
      <li>都由leader来发起写操作.</li>
      <li>都采用心跳检测存活性</li>
      <li>leader election都采用先到先得的投票方式</li>
    </ul>
  </li>
  <li>不同点
    <ul>
      <li>zab用的是epoch和count的组合来唯一表示一个值,而raft用的是term和index</li>
      <li>zab的follower在投票给一个leader之前必须和leader的日志达成一致,而raft的follower则简单地说是谁的 term 高就投票给谁</li>
      <li>raft协议的心跳是从leader到follower,而zab协议则相反</li>
      <li>raft协议数据只有单向地从leader到follower(成为leader的条件之一就是拥有最新的log),
  而 zab 协议在 discovery 阶段, 一个 prospective leader 需要将自己的 log 更新为 quorum 里面 最新的 log,然后才好在 synchronization 阶段将 quorum 里的其他机器的 log 都同步到一致.</li>
    </ul>
  </li>
</ul>

<p><a href="https://www.cnblogs.com/think90/p/11443428.html">https://www.cnblogs.com/think90/p/11443428.html</a></p>

<h4 id="一致性算法的实践">一致性算法的实践</h4>
<ul>
  <li>使用Paxos的组件，Chubby(Google首次运用Multi Paxos算法到工程领域)</li>
  <li>使用Raft的组件，Redis-Cluster、etcd</li>
  <li>使用ZAB的组件，Zookeeper（Yahoo开源）</li>
</ul>

  </div>
</article>

</div>
<div class="col-md-1 col-xs-0"></div>
</div>

<div class="clearfix"></div>
	

      </div>
      <div class="clearfix">
    </div>

    <footer class="site-footer">

  <div class="container">

    <h2 class="footer-heading">粉笔灰杂谈</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>粉笔灰杂谈</li>
          <li><a href="mailto:siglea@sina.com">siglea@sina.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/siglea"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">siglea</span></a>

          </li>
          

          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>关于产品、技术、商业的一些见解，顺便记录一下自己的生活感悟和读书笔记。</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
