<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>粉笔灰杂谈</title>
    <description>关于产品、技术、商业的一些见解，顺便记录一下自己的生活感悟和读书笔记。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 28 Jul 2020 11:58:12 +0800</pubDate>
    <lastBuildDate>Tue, 28 Jul 2020 11:58:12 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>DotDot2</title>
        <description>&lt;p&gt;DDD&lt;/p&gt;

&lt;p&gt;jmap dump&lt;/p&gt;
</description>
        <pubDate>Tue, 28 Jul 2020 08:44:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/28/DotDot3.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/28/DotDot3.html</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>高可用高并发</title>
        <description>&lt;h4 id=&quot;高可用&quot;&gt;高可用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;负载均衡
    &lt;ul&gt;
      &lt;li&gt;Consul + Consul-template 动态配置 Nginx upstream&lt;/li&gt;
      &lt;li&gt;Nginx + lua 动态负载均衡&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;限流，限制总并发数（池化）、排队或等待、降级
    &lt;ul&gt;
      &lt;li&gt;接入层限流：
        &lt;ul&gt;
          &lt;li&gt;ngx_http_limit_conn_mode(连接数限制)&lt;/li&gt;
          &lt;li&gt;ngx_http_limit_req_module(漏桶算法)&lt;/li&gt;
          &lt;li&gt;openResty提供的Lua动态限流模块(lua-resty-limit-traffic)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;应用层限流：Redis+Lua 、Nginx+Lua&lt;/li&gt;
      &lt;li&gt;节流，相同的事件特定窗口内只处理一次&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;降级，主要是当服务出问题或影响到核心流程的性能，需要暂时屏蔽掉一些非核心流程
    &lt;ul&gt;
      &lt;li&gt;缓存是离用户越近越高效，而降级是离用户越近对系统的保护越好&lt;/li&gt;
      &lt;li&gt;超时降级、故障降级&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;隔离
    &lt;ul&gt;
      &lt;li&gt;线程隔离，通过不同线程池实现&lt;/li&gt;
      &lt;li&gt;进程隔离，拆分子系统单独部署&lt;/li&gt;
      &lt;li&gt;爬虫隔离，区分正常请求与Spider请求&lt;/li&gt;
      &lt;li&gt;热点隔离，热点活动等&lt;/li&gt;
      &lt;li&gt;集群隔离、机房隔离、读写隔离、动静隔离、资源隔离（CPU绑定等）&lt;/li&gt;
      &lt;li&gt;Hystrix隔离&lt;/li&gt;
      &lt;li&gt;Servlet3，基于NIO的线程池及异步化
```shell
HystrixComand.Setter.
  .withGroupKey(groupKey) # 全局服务分组
  .andCommandKey(commandKey) # 全局服务
  .andThreadPoolKey(threadPookKey) # 全局线程名称
  .andThreadPoolPropertiesDefaults(threadPoolPropDefaults)
  .andCommandPropertiesDefaults();&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;超时与重试&lt;/li&gt;
  &lt;li&gt;回滚&lt;/li&gt;
  &lt;li&gt;压测与预案
    &lt;ul&gt;
      &lt;li&gt;JMeter/Apache ab/TCPCopy&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;高并发&quot;&gt;高并发&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;缓存，缓存主要是提高系统吞吐量
    &lt;ul&gt;
      &lt;li&gt;分层缓存
        &lt;ul&gt;
          &lt;li&gt;本地缓存(GuavaCache、Ehcache堆内外、MapDB堆内外)、应用将缓存、分布式缓存&lt;/li&gt;
          &lt;li&gt;客户端缓存、浏览器缓存&lt;/li&gt;
          &lt;li&gt;Nginx代理层缓存&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缓存回收策略：基于时间、基于容量、基于Java对象应用&lt;/li&gt;
      &lt;li&gt;Java缓存类型：堆内缓存、堆外缓存、磁盘缓存&lt;/li&gt;
      &lt;li&gt;缓存使用的模式
        &lt;ul&gt;
          &lt;li&gt;Cache-Aside：业务直接维护缓存&lt;/li&gt;
          &lt;li&gt;Cache-As-SoR(system of record)：面向缓存，不CareDB
            &lt;ul&gt;
              &lt;li&gt;read-through、write-through、write-behind&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;HTTP缓存
        &lt;ul&gt;
          &lt;li&gt;Age/Vary/Via一般用于代理层CDN，比如代理层是否命中、使用什么协议&lt;/li&gt;
          &lt;li&gt;Etag/Last-Modified，服务器用于判断本次请求与上次请求资源是否修改了&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;池化
    &lt;ul&gt;
      &lt;li&gt;数据库连接池&lt;/li&gt;
      &lt;li&gt;HTTPClient连接池&lt;/li&gt;
      &lt;li&gt;线程池&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异步并发
    &lt;ul&gt;
      &lt;li&gt;微服务情况下，请求合并&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;扩容
    &lt;ul&gt;
      &lt;li&gt;系统拆分&lt;/li&gt;
      &lt;li&gt;数据拆分
        &lt;ul&gt;
          &lt;li&gt;JIMDB，京东内存KV&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;任务拆分
        &lt;ul&gt;
          &lt;li&gt;Quartz&lt;/li&gt;
          &lt;li&gt;当当开源 Elastic-Job-Lite&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;数据异构
        &lt;ul&gt;
          &lt;li&gt;Canal是阿里开源的一款基于MySQL数据库binlog的增量订阅和消费组件&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;队列&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;openresty&quot;&gt;openresty&lt;/h4&gt;
&lt;p&gt;https://www.jianshu.com/p/09c17230e1ae
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/37102791&quot;&gt;https://zhuanlan.zhihu.com/p/37102791&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 26 Jul 2020 13:36:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/26/HighAvailabilityConcurrency.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/26/HighAvailabilityConcurrency.html</guid>
        
        <category>分布式</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>DotDot2</title>
        <description>&lt;h4 id=&quot;分布式控制方案&quot;&gt;分布式控制方案&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;中心化的副本控制协议，也就是主从模式&lt;/li&gt;
  &lt;li&gt;primary-secondary协议，也就是leader/follower（数据切片分段存储）&lt;/li&gt;
  &lt;li&gt;去中心化的副本控制协议，也就是Gossip或者zk选举阶段&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;高可用一致性扩展性性能&quot;&gt;高可用、一致性、扩展性、性能&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;由于存储分散切片存储，实现了高可用，
    &lt;ol&gt;
      &lt;li&gt;物理机broker分主从&lt;/li&gt;
      &lt;li&gt;物理机broker不分主从，但是数据切片的存储分主从&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;存储分片实现一致性，通过不同的协议
    &lt;ol&gt;
      &lt;li&gt;主从同步协议&lt;/li&gt;
      &lt;li&gt;去中心化gossip协议&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;节点是否对等？写入是否同步副本？写入是代理还是直连？读取是读主还是读副？读取是代理还是直连？扩容自动数据迁移？&lt;/li&gt;
  &lt;li&gt;zk分leader/follower，是，写入代理给leader，读任意，直连，扩容自动数据迁移，选举CP广播AP
  (zk的follower有可能数据不是最新的，如果需要最新的可以调用sync()方法，
  zk数据结构是DataTree，也就是以path为key的Map)&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;redis-cluster master节点无主次master负责不同的slot，从节点从主节点同步数据，写入直连或者被Move，
  读Master而slave只是热备，读取直连或者被Move，扩容使用redis-trib.rb，CP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;kafka分leader/follower，是，写入直接给leader，读leader，直连leader，扩容需要使用kafka-reassign-partitions.sh完成reblance
  (区别理解kafka中的leader/follower，本质是Partition数据的leader与follower会分布在不同的broker机器上，不会造成机器资源的不平衡
  kafka client通过向任意broker发送metadata req来获取partition得leader)&lt;/li&gt;
  &lt;li&gt;rocketMq分主/次，异步复制/同步双写，写入直连Master，对任意，直连，扩容通过updateTopic进行
  (物理机broker有主从，物理机是主就是分片message的主)&lt;/li&gt;
  &lt;li&gt;es分primary/replica，是，写入协调节给primary，读任意，协调节点协调，扩容自动数据迁移，CA
  (此处的primary是指根据document路由而得到的primary shard，不是指单独的机器)&lt;/li&gt;
  &lt;li&gt;cassandra不分主次，写入多数quorum，写任意节点，读任意，读多个节点返回最新数据，扩容自动数据迁移，AP
  (一致性hash确定分区，依靠协调节点）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/biu.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cassandra&quot;&gt;cassandra&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Gossip协议 &lt;a href=&quot;https://www.jianshu.com/p/f1c251614bad?tdsourcetag=s_pcqq_aiomsg&quot;&gt;https://www.jianshu.com/p/f1c251614bad?tdsourcetag=s_pcqq_aiomsg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;raidredundant-array-of-independent-disks独立冗余磁盘阵列&quot;&gt;RAID(Redundant Array of Independent Disks,独立冗余磁盘阵列)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;磁盘本地的互备容错高可用 &lt;a href=&quot;https://blog.csdn.net/Mr_Yang__/article/details/85228465&quot;&gt;https://blog.csdn.net/Mr_Yang__/article/details/85228465&lt;/a&gt;
    &lt;h4 id=&quot;dubbo-monitor-实现原理&quot;&gt;Dubbo Monitor 实现原理?&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;Consumer 端在发起调用之前会先走 filter 链;provider 端在接收到请求时也是 先走 filter 链，然后才进行真正的业务逻辑处理。
默认情况下，在 consumer 和 provider 的 filter 链中都会有 Monitorfilter。
    &lt;ol&gt;
      &lt;li&gt;MonitorFilter 向 DubboMonitor 发送数据&lt;/li&gt;
      &lt;li&gt;DubboMonitor 将数据进行聚合后(默认聚合 1min 中的统计数据)暂存到 ConcurrentMap&amp;lt;Statistics, AtomicReference&amp;gt; statisticsMap，然后使用一个 含有 3 个线程(线程名字:DubboMonitorSendTimer)的线程池每隔 1min 钟， 调用 SimpleMonitorService 遍历发送 statisticsMap 中的统计数据，每发送完毕 一个，就重置当前的 Statistics 的 AtomicReference&lt;/li&gt;
      &lt;li&gt;SimpleMonitorService 将这些聚合数据塞入 BlockingQueue queue 中(队 列大写为 100000)&lt;/li&gt;
      &lt;li&gt;SimpleMonitorService 使用一个后台线程(线程名为: DubboMonitorAsyncWriteLogThread)将 queue 中的数据写入文件(该线程以 死循环的形式来写)&lt;/li&gt;
      &lt;li&gt;SimpleMonitorService 还会使用一个含有 1 个线程(线程名字: DubboMonitorTimer)的线程池每隔 5min 钟，将文件中的统计数据画成图表
        &lt;h4 id=&quot;dubbo-spi-和-java-spi-区别&quot;&gt;Dubbo SPI 和 Java SPI 区别?&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;JDK SPI
JDK 标准的 SPI 会一次性加载所有的扩展实现，如果有的扩展吃实话很耗时，但 也没用上，很浪费资源。
所以只希望加载某个的实现，就不现实了&lt;/li&gt;
  &lt;li&gt;DUBBO SPI
    &lt;ol&gt;
      &lt;li&gt;对 Dubbo 进行扩展，不需要改动 Dubbo 的源码&lt;/li&gt;
      &lt;li&gt;延迟加载，可以一次只加载自己想要加载的扩展实现。&lt;/li&gt;
      &lt;li&gt;增加了对扩展点 IOC 和 AOP 的支持，一个扩展点可以直接 setter 注入其 它扩展点。&lt;/li&gt;
      &lt;li&gt;Dubbo 的扩展机制能很好的支持第三方 IoC 容器，默认支持 Spring Bean。
        &lt;h4 id=&quot;dubbo-如何优雅停机&quot;&gt;Dubbo 如何优雅停机?&lt;/h4&gt;
        &lt;p&gt;Dubbo 是通过 JDK 的 ShutdownHook 来完成优雅停机的，所以如果使用 kill -9 PID 等强制关闭指令，是不会执行优雅停机的，只有通过 kill PID 时，才 会执行。&lt;/p&gt;
        &lt;h4 id=&quot;rabbitmq-消息基于什么传输&quot;&gt;RabbitMQ 消息基于什么传输?&lt;/h4&gt;
        &lt;p&gt;由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶 颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的 虚拟连接，且每条 TCP 连接上的信道数量没有限制。&lt;/p&gt;
        &lt;h4 id=&quot;zookeeper-对于-kafka-的作用是什么&quot;&gt;Zookeeper 对于 Kafka 的作用是什么?&lt;/h4&gt;
        &lt;p&gt;Zookeeper 是一个开放源码的、高性能的协调服务，它用于 Kafka 的分布式应用。 Zookeeper 主要用于在集群中不同节点之间进行通信
在 Kafka 中，它被用于提交偏移量，因此如果节点在任何情况下都失败了，它都 可以从之前提交的偏移量中获取
除此之外，它还执行其他活动，如: leader 检测、分布式同步、配置管理、识别新 节点何时离开或连接、集群、节点实时状态等等。&lt;/p&gt;
        &lt;h4 id=&quot;kafka-消费者如何不自动提交偏移量由应用提交&quot;&gt;kafka 消费者如何不自动提交偏移量，由应用提交?&lt;/h4&gt;
        &lt;p&gt;将 auto.commit.offset 设为 false，然后在处理一批消息后 commitSync() 或者 异步提交 commitAsync()&lt;/p&gt;
        &lt;h4 id=&quot;pipeline-有什么好处为什么要用-pipeline&quot;&gt;Pipeline 有什么好处，为什么要用 pipeline?&lt;/h4&gt;
        &lt;p&gt;答:可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有 因果相关性。使用 redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS 峰值的一个重要因素是 pipeline 批次指令的数目。&lt;/p&gt;
        &lt;h4 id=&quot;jedis-与-redisson-对比有什么优缺点&quot;&gt;Jedis 与 Redisson 对比有什么优缺点?&lt;/h4&gt;
        &lt;p&gt;答:Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令 的支持;Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能 较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。 Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更 集中地放在处理业务逻辑上。&lt;/p&gt;
        &lt;h4 id=&quot;说说-redis-哈希槽的概念&quot;&gt;说说 Redis 哈希槽的概念?&lt;/h4&gt;
        &lt;p&gt;答:Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽， 集群的每个节点负责一部分 hash 槽。&lt;/p&gt;
        &lt;h4 id=&quot;假如-redis-里面有-1-亿个-key其中有-10w-个-key-是以-某个固定的已知的前缀开头的如果将它们全部找出来&quot;&gt;假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以 某个固定的已知的前缀开头的，如果将它们全部找出来?&lt;/h4&gt;
        &lt;p&gt;答:使用 keys 指令可以扫出指定模式的 key 列表。
对方接着追问:如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会 有什么问题?
这个时候你要回答 redis 关键的一个特性:redis 的单线程的。keys 指令会导致线 程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时 候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但 是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间 会比直接用 keys 指令长。&lt;/p&gt;
        &lt;h4 id=&quot;mysql-blob-和-text-有什么区别&quot;&gt;Mysql BLOB 和 TEXT 有什么区别?&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;BLOB 是一个二进制对象，可以容纳可变数量的数据。TEXT 是一个不区分大小写 的 BLOB。&lt;/li&gt;
  &lt;li&gt;BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小 写，对 TEXT 值不区分大小写。
    &lt;h4 id=&quot;可以使用多少列创建索引&quot;&gt;可以使用多少列创建索引?&lt;/h4&gt;
    &lt;p&gt;任何标准表最多可以创建 16 个索引列。&lt;/p&gt;
    &lt;h4 id=&quot;now和-current_date有什么区别&quot;&gt;NOW()和 CURRENT_DATE()有什么区别?&lt;/h4&gt;
    &lt;p&gt;NOW()命令用于显示当前年份，月份，日期，小时，分钟和秒。 CURRENT_DATE()仅显示当前年份，月份和日期。&lt;/p&gt;
    &lt;h4 id=&quot;完整性约束包括哪些&quot;&gt;完整性约束包括哪些?&lt;/h4&gt;
    &lt;p&gt;数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。
分为以下四类:&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;实体完整性:规定表的每一行在表中是惟一的实体。&lt;/li&gt;
      &lt;li&gt;域完整性:是指表中的列必须满足某种特定的数据类型约束，其中约束又包括 取值范围、精度等规定。&lt;/li&gt;
      &lt;li&gt;参照完整性:是指两个表的主关键字和外关键字的数据应一致，保证了表之间 的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。&lt;/li&gt;
      &lt;li&gt;用户定义的完整性:不同的关系数据库系统根据其应用环境的不同，往往还需 要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束 条件，它反映某一具体应用必须满足的语义要求。
与表有关的约束:包括列约束(NOT NULL(非空约束))和表约束(PRIMARY KEY、 foreign key、check、UNIQUE) 。
        &lt;h4 id=&quot;说说对-sql-语句优化有哪些方法选择几条&quot;&gt;说说对 SQL 语句优化有哪些方法?(选择几条)&lt;/h4&gt;
      &lt;/li&gt;
      &lt;li&gt;Where 子句中:where 表之间的连接必须写在其他 Where 条件之前，那些可 以过滤掉最大数量记录的条件必须写在 Where 子句的末尾.HAVING 最后。&lt;/li&gt;
      &lt;li&gt;用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。&lt;/li&gt;
      &lt;li&gt;避免在索引列上使用计算&lt;/li&gt;
      &lt;li&gt;避免在索引列上使用 IS NULL 和 IS NOT NULL&lt;/li&gt;
      &lt;li&gt;对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉 及的列上建立索引。&lt;/li&gt;
      &lt;li&gt;应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃 使用索引而进行全表扫描&lt;/li&gt;
      &lt;li&gt;应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用 索引而进行全表扫描
####活锁:
任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试， 失败，尝试，失败。
活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而 处于死锁的实体表现为等待;活锁有可能自行解开，死锁则不能。
        &lt;h4 id=&quot;饥饿&quot;&gt;饥饿:&lt;/h4&gt;
        &lt;p&gt;一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执 行的状态。
Java 中导致饥饿的原因:
1、高优先级线程吞噬所有的低优先级线程的 CPU 时间。 
2、线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前 持续地对该同步块进行访问。 
3、线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方 法)，因为其他线程总是被持续地获得唤醒。&lt;/p&gt;
        &lt;h4 id=&quot;java-concurrency-api-中的-lock-接口lock-interface-是什么对比同步它有什么优势&quot;&gt;Java Concurrency API 中的 Lock 接口(Lock interface) 是什么?对比同步它有什么优势?&lt;/h4&gt;
        &lt;p&gt;Lock 接口比同步方法和同步块提供了更具扩展性的锁操作。 他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的 条件对象。
它的优势有:
可以使锁更公平
可以使线程在等待锁的时候响应中断 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 可以在不同的范围，以不同的顺序获取和释放锁
整体上来说 Lock 是 synchronized 的扩展版，Lock 提供了无条件的、可轮询的 (tryLock 方法)、定时的(tryLock 带参方法)、可中断的(lockInterruptibly)、可多 条件队列的(newCondition 方法)锁操作。另外 Lock 的实现类基本都支持非公平 锁(默认)和公平锁，synchronized 只支持非公平锁，当然，在大部分情况下，非 公平锁是高效的选择。&lt;/p&gt;
        &lt;h4 id=&quot;synchronizedmap-和-concurrenthashmap-有什么区-别&quot;&gt;SynchronizedMap 和 ConcurrentHashMap 有什么区 别?&lt;/h4&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来 访为 map。&lt;/li&gt;
  &lt;li&gt;ConcurrentHashMap 使用分段锁来保证在多线程下的性能。 ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。 这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提 升是显而易见的。&lt;/li&gt;
  &lt;li&gt;另外 ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而 不影响原有的数据 ，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。
    &lt;h4 id=&quot;你如何确保-main方法所在的线程是-java-程序最后结束-的线程&quot;&gt;你如何确保 main()方法所在的线程是 Java 程序最后结束 的线程?&lt;/h4&gt;
    &lt;p&gt;我们可以使用 Thread 类的 join()方法来确保所有程序创建的线程在 main()方法退 出前结束。&lt;/p&gt;
    &lt;h4 id=&quot;为什么-wait-notify和-notifyall-必须在同步方法或-者同步块中被调用&quot;&gt;为什么 wait(), notify()和 notifyAll ()必须在同步方法或 者同步块中被调用?&lt;/h4&gt;
    &lt;p&gt;当一个线程需要调用对象的 wait()方法的时候，这个线程必须拥有该对象的锁，接 着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify() 方法。同样的，当一个线程需要调用对象的 notify()方法时，它会释放这个对象的 锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要 线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者 同步块中被调用。&lt;/p&gt;
    &lt;h4 id=&quot;为什么-thread-类的-sleep和-yield-方法是静态的&quot;&gt;为什么 Thread 类的 sleep()和 yield ()方法是静态的?&lt;/h4&gt;
    &lt;p&gt;Thread 类的 sleep()和 yield()方法将在当前正在执行的线程上运行。所以在其他 处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静 态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在 其他非运行线程调用这些方法。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;spring-security&quot;&gt;Spring Security&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.imooc.com/article/305184&quot;&gt;https://www.imooc.com/article/305184&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;对账 &lt;a href=&quot;http://www.woshipm.com/it/1262137.html&quot;&gt;http://www.woshipm.com/it/1262137.html&lt;/a&gt;
如何做一个对账系统，纯洁的微笑 &lt;a href=&quot;https://www.cnblogs.com/ityouknow/p/7015879.html&quot;&gt;https://www.cnblogs.com/ityouknow/p/7015879.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Jul 2020 09:46:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/20/DotDot2.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/20/DotDot2.html</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>  Jvm（三）参数一览</title>
        <description>&lt;h4 id=&quot;usecompressedoop&quot;&gt;UseCompressedOop&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CompressedOops原理：
64位地址分为堆的基地址+偏移量，当堆内存&amp;lt;32GB时候，在压缩过程中，把偏移量/8后保存到32位地址。在解压再把32位地址放大8倍，所以启用CompressedOops的条件是堆内存要在4GB*8=32GB以内。
CompressedOops，可以让跑在64位平台下的JVM，不需要因为更宽的寻址，而付出Heap容量损失的代价。 不过它的实现方式是在机器码中植入压缩与解压指令，可能会给JVM增加额外的开销。&lt;/li&gt;
  &lt;li&gt;零基压缩优化(Zero Based Compressd Oops)
零基压缩是针对压解压动作的进一步优化。 它通过改变正常指针的随机地址分配特性，强制堆地址从零开始分配（需要OS支持），进一步提高了压解压效率。要启用零基压缩，你分配给JVM的内存大小必须控制在4G以上，32G以下。&lt;/li&gt;
  &lt;li&gt;总结：
    &lt;ul&gt;
      &lt;li&gt;如果GC堆大小在4G以下，直接砍掉高32位，避免了编码解码过程；&lt;/li&gt;
      &lt;li&gt;如果GC堆大小在4G以上32G以下，则启用UseCompressedOop；&lt;/li&gt;
      &lt;li&gt;如果GC堆大小大于32G，压指失效，使用原来的64位（所以说服务器内存太大不好……）。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/liuxiao723846/article/details/91981757&quot;&gt;https://blog.csdn.net/liuxiao723846/article/details/91981757&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;-Xms2g&lt;/span&gt;：初始化推大小为 2g；
&lt;span class=&quot;nt&quot;&gt;-Xmx2g&lt;/span&gt;：堆最大内存为 2g；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:NewRatio&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4：设置年轻的和老年代的内存比例为 1:4；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:SurvivorRatio&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8：设置新生代 Eden 和 Survivor 比例为 8:2；
–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:+PrintGC：开启打印 gc 信息；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:+PrintGCDetails：打印 gc 详细信息。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/jp1.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp2.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp3.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp4.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp5.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp6.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp7.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Jul 2020 10:10:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/18/JVM-Param.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/18/JVM-Param.html</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title> Jvm（四）Note</title>
        <description>&lt;h4 id=&quot;class文件&quot;&gt;Class文件&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/class.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Magic Number：4字节，0xCAFEBABE&lt;/li&gt;
  &lt;li&gt;minor_version/major_version：JDK版本号，向下兼容&lt;/li&gt;
  &lt;li&gt;constant_pool_count/constant_pool：常量池（javap -verbose可以输出.class内容)&lt;/li&gt;
  &lt;li&gt;access_flags：表示class是类或者接口、是否public、是否abstract、是否final&lt;/li&gt;
  &lt;li&gt;this_class/super_class/interfaces_count/interfaces：&lt;/li&gt;
  &lt;li&gt;fields/fields_count，methods/methods_count&lt;/li&gt;
  &lt;li&gt;attributes/attributes_count：属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；如果出现在fileds的某一项里，那么它就是对该字段额外信息的描述；如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。
    &lt;ol&gt;
      &lt;li&gt;Code：使用在方法表里，Java代码编译成的字节码指令。
        &lt;ul&gt;
          &lt;li&gt;可以查看虚拟机字节码指令表 &lt;a href=&quot;https://www.cnblogs.com/magexi/p/11822910.html&quot;&gt;https://www.cnblogs.com/magexi/p/11822910.html&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;虚拟机规范一个方法不允许超过 65535条字节码指令&lt;/li&gt;
          &lt;li&gt;如果把一个Java程序中的信息分为代码(Code，方法体里面的Java代码)和元数据(Metadata，包括类、字段、方法定义及其他信息)，
  那么在整个Class文件中，Code属性用于描述代码，所有的其他属性用于描述元数据。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Exception&lt;/li&gt;
      &lt;li&gt;LineNumberTable：Java源码的行号与字节码指令的对应关系&lt;/li&gt;
      &lt;li&gt;LocalVariableTable属性：用于描述栈帧中局部变量表中的变量与Java源代码中定义的变量之间的关系。&lt;/li&gt;
      &lt;li&gt;SourceFile：源代码名字&lt;/li&gt;
      &lt;li&gt;ConstantValue属性：通知虚拟机自动为静态变量赋值&lt;/li&gt;
      &lt;li&gt;InnerClasses属性&lt;/li&gt;
      &lt;li&gt;Synthetic属性：代表此字段或方法并不是由Java源代码直接产生的，而是由编译器自行添加的（如:init)&lt;/li&gt;
      &lt;li&gt;StackMapTable属性：会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用。&lt;/li&gt;
      &lt;li&gt;Signature：泛型&lt;/li&gt;
      &lt;li&gt;BootstrapMethods属性：用于保存invokeDynamic指令引用的引导方法限定符。&lt;/li&gt;
      &lt;li&gt;RuntimeVisibleAnnotations：为动态注解提供支持&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;案例看下
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;/img/class_code.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/class_javap.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;字节码指令集200多个不超过256&quot;&gt;字节码指令集（200多个，不超过256）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;加载和存储指令：iload、istore、bipush等&lt;/li&gt;
  &lt;li&gt;运算指令：iadd、isub、imul、idiv、ior、iand等&lt;/li&gt;
  &lt;li&gt;类型转换指令：i2b、i2c、i2s等&lt;/li&gt;
  &lt;li&gt;对象创建与访问指令：new、newarray、putfield、getfield、arraylength等&lt;/li&gt;
  &lt;li&gt;操作栈管理指令：pop、dup、 swap等&lt;/li&gt;
  &lt;li&gt;控制转移指令：ifeq、iflt、ifle等&lt;/li&gt;
  &lt;li&gt;方法调用和返回指令：
    &lt;ul&gt;
      &lt;li&gt;invokevirtual：抽象/虚拟方法&lt;/li&gt;
      &lt;li&gt;invokeinterface：接口方法&lt;/li&gt;
      &lt;li&gt;invokespecial：init、私有、父类方法&lt;/li&gt;
      &lt;li&gt;invokestatic：静态方法&lt;/li&gt;
      &lt;li&gt;invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，
  前4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑由用户所设定的引导方法决定的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异常处理指令：throw（catch用异常表来实现）&lt;/li&gt;
  &lt;li&gt;同步指令：monitorenter 、monitorexit&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;类加载机制&quot;&gt;类加载机制&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;加载
    &lt;ul&gt;
      &lt;li&gt;加载时机：new、invocke static；反射调用；子类依赖的父类；main类；jdk1.7后的动态语言支持REF_getStatic&lt;/li&gt;
      &lt;li&gt;除了上述5种场景，其他的方式都是被动引用（如：访问类常量、创建对象数组等），不会触发初始化。&lt;/li&gt;
      &lt;li&gt;加载渠道：zip包类(Jar/Ear/War)；网络类(Applet)；动态代理生成；JSP等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;验证
    &lt;ul&gt;
      &lt;li&gt;文件格式验证：版本号、类型、常量类型等&lt;/li&gt;
      &lt;li&gt;元数据验证：类继承实现是否正确完整等Java语言规范&lt;/li&gt;
      &lt;li&gt;字节码验证：字节码语义验证、安全验证、类型推断验证（StackMapTable优化了类型推断）&lt;/li&gt;
      &lt;li&gt;符号引用验证：为确保解析动作能正常运行，类名、访问权限等核实&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;准备
    &lt;ul&gt;
      &lt;li&gt;为类变量分配内存，并设置初始化”零值”（final直接赋值）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;解析
    &lt;ul&gt;
      &lt;li&gt;把符号引用替换为直接引用&lt;/li&gt;
      &lt;li&gt;正式解析类、字段、方法，解析失败会出现IllegalAccessError、NoSuchFieldError、NoSuchMethodError&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化
    &lt;ul&gt;
      &lt;li&gt;clinit()方法执行、虚拟机保证该方法现成安全&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;破坏双亲委派&quot;&gt;破坏双亲委派&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;JDK1.2通过覆盖loadClass实现自定义加载器，之后应是把自己的加载逻辑放到findClass中&lt;/li&gt;
  &lt;li&gt;SPI机制通过 ThreadContextClassLoader的方式，父加载器可以实现委派下级进行加载。比如BootstrapClassLoader
  需要使用到了classpath下的class，但是自己只能加载固定目录下，就需要委派AppClassLoader来替它加载&lt;/li&gt;
  &lt;li&gt;OSGI动态热部署等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;虚拟机字节码执行引擎&quot;&gt;虚拟机字节码执行引擎&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在不同的虚拟机实现里会有解释执行（解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种方式。&lt;/li&gt;
  &lt;li&gt;运行时栈帧结构
    &lt;ul&gt;
      &lt;li&gt;每个线程包含多个栈帧&lt;/li&gt;
      &lt;li&gt;局部变量表
        &lt;ul&gt;
          &lt;li&gt;局部变量表的容量以变量槽(Variable Slot)为最小单位(32位/64位)&lt;/li&gt;
          &lt;li&gt;第0位，表示this&lt;/li&gt;
          &lt;li&gt;Slot可以被复用一变节省空间，比如把不用的对象=null，就可以把该对象占用的空间让出来，但是=null有可能被编译器优化擦出掉或者jvm会优化这种操作&lt;/li&gt;
          &lt;li&gt;局部变量需要明确初始化，不会给初始化”零值”&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;操作栈&lt;/li&gt;
      &lt;li&gt;动态连接
        &lt;ul&gt;
          &lt;li&gt;Class文件中的符号引用在运行期间转换为直接引用，就是指动态连接&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;返回地址
        &lt;ul&gt;
          &lt;li&gt;方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：
  恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，
  调整PC计时器的值以指向方法调用指令后面的一条指令等。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;方法调用
    &lt;ul&gt;
      &lt;li&gt;方法调用阶段唯一的任务就是确定被调用的方法的版本，暂时还不涉及方法内部的具体运行过程。
在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class文件的编译过程中
不包含传统编译中的连接步骤，一起方法调用在Class文件里面存储的都只是符号引用，而不是方法
在实际运行时内存布局中的入口地址（直接引用）。这个特性给Java带来了更强大的动态扩展能力，
但也使得Java方法调用过程变得相对复杂起来，需要再类加载期间，甚至到运行期间才能确定目标方法的直接引用。&lt;/li&gt;
      &lt;li&gt;编译器可知，运行期不可变&lt;/li&gt;
      &lt;li&gt;2大类方法
        &lt;ol&gt;
          &lt;li&gt;非虚方法：通过invokestatic/invokespecial调用的诸如静态、私有、构造、父类方法这4类，在解析阶段就确定了&lt;/li&gt;
          &lt;li&gt;虚方法：抽象，多态。
            &lt;ul&gt;
              &lt;li&gt;静态分派：方法重载&lt;/li&gt;
              &lt;li&gt;动态分派：方法重写
                &lt;ul&gt;
                  &lt;li&gt;动态单分派&lt;/li&gt;
                  &lt;li&gt;通过方法表来优化查找性能&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动态性
    &lt;ul&gt;
      &lt;li&gt;何为动态语言？变量无类型而变量值才有类型。&lt;/li&gt;
      &lt;li&gt;Java动态性实现从JDK1.7开始 &lt;a href=&quot;https://blog.csdn.net/zero__007/article/details/107304054&quot;&gt;https://blog.csdn.net/zero__007/article/details/107304054&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;java.lang.invoke包MethodHandler&lt;/li&gt;
          &lt;li&gt;invokedynamic字节码指令&lt;/li&gt;
          &lt;li&gt;Reflection与MethodHandle机制都是在模拟方法调用，Reflection是在Java代码层次，而MethodHandl是在模拟字节码层次&lt;/li&gt;
          &lt;li&gt;Reflection是重量级的能映射整个方法相关的信息，MethoudHandle仅仅是方法调用&lt;/li&gt;
          &lt;li&gt;Reflection是为Java语言服务的，MethodHandle是为所有Java虚拟机之上的语言服务&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 通过MethodType的静态工厂方法构造 MethodType&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MethodType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MethodType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;methodType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 获取方法句柄&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MethodHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodHandle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MethodHandles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findVirtual&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;say&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;methodHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zero&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// invoke和invokeExact方法, invokeExact方法与直接调用底层方法是一样的&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;methodHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invokeExact&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zero&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;useConstantCallSite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;MethodHandles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Lookup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lookup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MethodHandles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;MethodType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MethodType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;methodType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;MethodHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findVirtual&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;substring&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;n&quot;&gt;ConstantCallSite&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callSite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConstantCallSite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;MethodHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invoker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callSite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dynamicInvoker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invoker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;执行引擎
    &lt;ul&gt;
      &lt;li&gt;编译执行/解释执行&lt;/li&gt;
      &lt;li&gt;JIT编译(just-in-time compilation)狭义来说是当某段代码即将第一次被执行时进行编译,因而叫“即时编译”&lt;/li&gt;
      &lt;li&gt;基于栈的指令集 与 基于寄存器的指令集 （Android Dalvik VM)
  &lt;img src=&quot;/img/exec.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;类加载及执行子系统案例&quot;&gt;类加载及执行子系统案例&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;tomcat
    &lt;ul&gt;
      &lt;li&gt;放置在 /common 目录中：类库可被 Tomcat 和所有的 Web 应用程序共同使用。CommonClassLoader&lt;/li&gt;
      &lt;li&gt;放置在 /server 目录中：类库可被 Tomcat 使用，对所有的 Web 应用程序都不可见。CatalinaClassLoader&lt;/li&gt;
      &lt;li&gt;放置在 /shared 目录中：类库可被所有的 Web 应用程序共同使用，但对 Tomcat 自己不可见。SharedClassLoader&lt;/li&gt;
      &lt;li&gt;放置在 /WebApp/WEB-INF 目录中：类库仅仅可以被此 Web 应用程序使用，对 Tomcat 和其他 Web 应用程序都不可见 WebAppClassLoader&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OSGi：灵活的类加载器架构
    &lt;ul&gt;
      &lt;li&gt;OSGi（Open Service Gateway Initiative） 是 OSGi 联盟（OSGi Alliance）制定的一个基于 Java 语言的动态模块化规范&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;字节码生成技术与动态代理的实现
    &lt;ul&gt;
      &lt;li&gt;javac、Javassit、CGlib、ASM&lt;/li&gt;
      &lt;li&gt;JDK Proxy，也是生成字节码，用完删除了而已
        &lt;ul&gt;
          &lt;li&gt;Proxy.newProxyInstance()&lt;/li&gt;
          &lt;li&gt;sun.misc.ProxyGenerator.generateProxyClass()&lt;/li&gt;
          &lt;li&gt;System.getProperties().put(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”);&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Retrotranslator 的作用是将 JDK 1.5 编译出来的 Class 文件转变为可以在 JDK 1.4 或 1.3 上部署的版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013678930/article/details/51995251&quot;&gt;https://blog.csdn.net/u013678930/article/details/51995251&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;早期编译期优化&quot;&gt;早期（编译期）优化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;编译器类型
    &lt;ul&gt;
      &lt;li&gt;前端编译器：把java变为class，如Sun的Javac、Eclipse JDT中的增量式编译器(ECJ)&lt;/li&gt;
      &lt;li&gt;JIT编译器：运行时把 class字节码转变成机器码，如HotSpot VM的 C1、C2编译器&lt;/li&gt;
      &lt;li&gt;AOT编译器：直接把java编译成本地机器码，如GNU Compiler for the Java (GCJ)、Excelsior JET&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编译过程
    &lt;ul&gt;
      &lt;li&gt;解析与填充符号表过程&lt;/li&gt;
      &lt;li&gt;插入式注解处理器的注解处理过程&lt;/li&gt;
      &lt;li&gt;分析与字节码生成过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;泛型与类型擦除(Signature、LocalVariableTypeTable从JDK1.6之后用于解决此特性带来的问题)&lt;/li&gt;
  &lt;li&gt;自动装箱、拆箱与遍历循环&lt;/li&gt;
  &lt;li&gt;Annotation Processor是javac的一个工具，它用来在编译时扫描和处理注解，通过Annotation Processor可以获取到注解和被注解类的相关信息，
  然后根据注解自动生成Java代码，省去了手动编写，提高了编码效率。(javac -processor)
    &lt;ul&gt;
      &lt;li&gt;Hibernate Validator Annotation Processor&lt;/li&gt;
      &lt;li&gt;Project Lombok&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;晚期运行期优化&quot;&gt;晚期运行期优化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;主流的虚拟机采用解释器与编译器并存的架构 (java -version  mixed mode)，为了再启动响应速度和运行效率之间达到最佳平衡，
  hotSpot虚拟机还会逐渐启用分层编译（Tiered Compilation）的策略。
    &lt;ul&gt;
      &lt;li&gt;解释器，一遍运行一遍把字节码解释为本地机器码 [0层]&lt;/li&gt;
      &lt;li&gt;编译器，把字节码编译成为本地机器码并缓存起来
        &lt;ul&gt;
          &lt;li&gt;C1（Client Compiler），更高的编译速度   [1层]&lt;/li&gt;
          &lt;li&gt;C2 (Server Compiler)，更好的编译质量   [2层]&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;热点代码：在运行过程中会被即时编译器编译的代码 也就是HotSpot的名称来源
    &lt;ul&gt;
      &lt;li&gt;被多次调用的方法：由方法调用触发编译，也是标准的JIT编译方式
        &lt;ul&gt;
          &lt;li&gt;Invocation Counter，超过阈值触发JIT编译&lt;/li&gt;
          &lt;li&gt;C1默认：1500次 C2：10000次&lt;/li&gt;
          &lt;li&gt;-XX：CompileThreshold&lt;/li&gt;
          &lt;li&gt;可以设置衰减周期：CounterHalfLifeTime&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;被对此执行的循环体：由循环体，关联出所在的方法，发生在方法执行过程中，因此被称为栈上替换OSR (On Stack Replacement)
        &lt;ul&gt;
          &lt;li&gt;Back Edge Counter，字节码遇到控制流向后跳转的指令后统计次数，为了触发OSR&lt;/li&gt;
          &lt;li&gt;CompileThreshold * OnStackReplacePercentage / 100&lt;/li&gt;
          &lt;li&gt;C1: 13995,C2：10700&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;热点探测的判断方法
    &lt;ul&gt;
      &lt;li&gt;基于采样（Sample Based Hot Spot Detection)，周期性检查各个线程的栈顶。缺点是受线程阻塞等因素影响会不准&lt;/li&gt;
      &lt;li&gt;基于计数器（Counter Based Hot Spot Detection)，统计方法的执行次数。缺点是无法知道调用关系。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编译过程
    &lt;ul&gt;
      &lt;li&gt;C1
        &lt;ul&gt;
          &lt;li&gt;字节码 -&amp;gt;方法内联、常量传播 -&amp;gt; HIR High level Intermediate Representation (SSA Static Single Assignment形式)&lt;/li&gt;
          &lt;li&gt;HIR -&amp;gt; 空置检查消除、范围检查消除 -&amp;gt; LLR Low-Level Intermediate Representation&lt;/li&gt;
          &lt;li&gt;LIR -&amp;gt; 寄存器分配、窥孔优化 -&amp;gt; 本地机器码&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;C2,相对于C1更加缓慢，提高代码质量，进一步减少本地代码的执行时间
        &lt;ul&gt;
          &lt;li&gt;无用代码消除 Dead Code Elimination&lt;/li&gt;
          &lt;li&gt;循环展开 Loop Unrolling&lt;/li&gt;
          &lt;li&gt;循环表达式外提 Loop Expression Hoisting&lt;/li&gt;
          &lt;li&gt;消除公共子表达式 Common Subexpression Elimination&lt;/li&gt;
          &lt;li&gt;常量传播 Constant Propagation&lt;/li&gt;
          &lt;li&gt;基本块重排序 Basic Block Reordering&lt;/li&gt;
          &lt;li&gt;范围检查消除 Range Check Elimiation&lt;/li&gt;
          &lt;li&gt;数组边界检查消除 Array Bounds Checking Elimination：JAVA数组的方位不是通过裸指针，所以每次都需要检查是否越界
  可以通过数据流分析推断出取值范围，就可以把检查消除&lt;/li&gt;
          &lt;li&gt;逃逸分析 Escape Analysis
            &lt;ul&gt;
              &lt;li&gt;当一个对象在方法中被定义后，它可能被外部方法所引用
                &lt;ul&gt;
                  &lt;li&gt;JVM判断新创建的对象是否逃逸的依据有：一、对象被赋值给堆中对象的字段和类的静态变量。
  二、对象被传进了不确定的代码中去运行。如果满足了以上情况的任意一种，那这个对象JVM就会判定为逃逸。
  对于第一种情况，因为对象被放进堆中，则其它线程就可以对其进行访问，所以对象的使用情况，编译器就无法再进行追踪。
  第二种情况相当于JVM在解析普通的字节码的时候，如果没有发生JIT即时编译，编译器是不能事先完整知道这段代码会对对象做什么操作。
  保守一点，这个时候也只能把对象是当作是逃逸来处理。&lt;/li&gt;
                  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/59215831&quot;&gt;https://zhuanlan.zhihu.com/p/59215831&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;逃逸分析带来的好处：栈上分配，同步消除、标量替换
                &lt;ol&gt;
                  &lt;li&gt;同步消除。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。&lt;/li&gt;
                  &lt;li&gt;将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。&lt;/li&gt;
                  &lt;li&gt;分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。&lt;/li&gt;
                &lt;/ol&gt;
              &lt;/li&gt;
              &lt;li&gt;缺点：不确定逃逸对象的比例，反而会浪费性能&lt;/li&gt;
              &lt;li&gt;-XX:+DoEscapeAnalysis 开启逃逸分析，JDK1.7默认开启&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/w372426096/article/details/80333657&quot;&gt;https://blog.csdn.net/w372426096/article/details/80333657&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/hollis_chuang/article/details/80922794&quot;&gt;https://blog.csdn.net/hollis_chuang/article/details/80922794&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java 与 C++ 编译器对比
    &lt;ul&gt;
      &lt;li&gt;Java编译器占用用户时间&lt;/li&gt;
      &lt;li&gt;Java语言是动态的类型安全语言，意味值需要频繁检测空指针、数字越界、类型转换，总体耗时&lt;/li&gt;
      &lt;li&gt;运行时多态选择频率远远大于C/C++&lt;/li&gt;
      &lt;li&gt;Java对象内存分配在只能再堆上，造成局部对象不能随之栈消失被回收&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;线程与内存模型&quot;&gt;线程与内存模型&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;缓存一致性 Cache Coherence，解决CPU高速缓存与主内存数据一致性。如MSI、FireFly等协议&lt;/li&gt;
  &lt;li&gt;指令重排 Instruction Reorder，与处理器乱序执行OutOfOrder Execution类似，使得处理器内部的运算单元尽可能被充分利用&lt;/li&gt;
  &lt;li&gt;Java内存模型：所有变量储存在主内存Main Memory、每条线程还有自己的工作内存Working Memory
    &lt;ul&gt;
      &lt;li&gt;read/load : 从主内存读取到工作内存&lt;/li&gt;
      &lt;li&gt;store/write ：从工作内存写入主内存&lt;/li&gt;
      &lt;li&gt;use：从工作内存传递给执行引擎&lt;/li&gt;
      &lt;li&gt;assign：工作引擎赋值给工作内存&lt;/li&gt;
      &lt;li&gt;lock/unlock：在主内存锁定或解锁变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;volatile：
    &lt;ul&gt;
      &lt;li&gt;保证可见性：本质上volatile变量也可以存在不一致的情况，但由于每次使用前都要先刷新，执行引擎看不到不一致的情况&lt;/li&gt;
      &lt;li&gt;禁止指令重排：通过插入内存屏障指令来实现，因此写操作会比普通变量慢&lt;/li&gt;
      &lt;li&gt;非原子性的i++之类的操作仍然会出现问题&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;long/double这种64位的数据，几乎所有虚拟机厂商都实现读写原子性，所以可以不需要声明为volatile&lt;/li&gt;
  &lt;li&gt;先行发生原则 happen before，只要遵循以下几个原则就是有顺序保障的，否则可能被重排。也就是说我们考虑并发问题
  不要看先后发生的时间顺序，而一切以先行发生原则为准
    &lt;ul&gt;
      &lt;li&gt;程序次序规则 Program Order Rule&lt;/li&gt;
      &lt;li&gt;管程锁定规则 Monitor Lock Rule&lt;/li&gt;
      &lt;li&gt;volatile变量规则 Volatile Variable Rule&lt;/li&gt;
      &lt;li&gt;线程启动、终止、中断规则&lt;/li&gt;
      &lt;li&gt;对象终结规则 init 先于 finalize&lt;/li&gt;
      &lt;li&gt;传递性 Transitivity&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java线程实现
    &lt;ul&gt;
      &lt;li&gt;JDK1.2之前，是用用户线程&lt;/li&gt;
      &lt;li&gt;JDK1.2及之后，是用操作系统的线程来实现&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java线程调度
    &lt;ul&gt;
      &lt;li&gt;协同式线程调度 Cooperative Thread-Scheduling，线程执行时间由自己控制，会造成各种阻塞不让出资源&lt;/li&gt;
      &lt;li&gt;抢占式线程调度 Preemptive Threads Scheduling，由操作系统分配执行时间，Java使用该方式，可以指定线程优先级但是不一定起作用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;线程状态
    &lt;ul&gt;
      &lt;li&gt;新建 New：尚未启动的状态&lt;/li&gt;
      &lt;li&gt;运行 Runable，对应操作系统中的Running和Ready，可以是正在执行也可以是等待CPU分配时间&lt;/li&gt;
      &lt;li&gt;等待 Waiting
        &lt;ul&gt;
          &lt;li&gt;无限期等待：Object.wait/Thread.join/LockSupport.park&lt;/li&gt;
          &lt;li&gt;限期等待：Thread.sleep/Object.wait timeout/Thread.join timeout/LockSupport.parkNanos timeout/LockSupport.parkUntil timeout&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;阻塞 Blocked
        &lt;ul&gt;
          &lt;li&gt;阻塞与等待的区别：阻塞是在等待这获取到一个排他锁，等待状态是在等待时间或者被唤醒&lt;/li&gt;
          &lt;li&gt;在程序等待进入同步区域的时候会进入该状态&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;结束 Terminated&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;线程安全的实现方法
    &lt;ul&gt;
      &lt;li&gt;互斥同步&lt;/li&gt;
      &lt;li&gt;非阻塞同步/乐观锁，乐观锁的实现依赖于”硬件指令集的发展”
      - 测试并设置 Test-and-Set
      - 获取并增加 Fetch-and-Increment
      - 交换 Swap
      - 比较并交换 CAS
      - 加载链接/条件存储&lt;/li&gt;
      &lt;li&gt;无同步&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;自旋锁，单纯自旋等待前面的锁定释放&lt;/li&gt;
  &lt;li&gt;偏向锁、轻量级锁、重量级锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/lock_optimize.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;总览&quot;&gt;总览&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/linghu-java/category/855958.html&quot;&gt;https://www.cnblogs.com/linghu-java/category/855958.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 15 Jul 2020 13:40:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/15/JVM-Note.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/15/JVM-Note.html</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Tree</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/tree.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;各种树&quot;&gt;各种树&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AVL 树具有以下特点：
    &lt;ul&gt;
      &lt;li&gt;每个结点的平衡因子只可能是 -1、0、1（如果绝对值超过 1，则认为是失衡）&lt;/li&gt;
      &lt;li&gt;每个结点的左右子树高度差不超过 1&lt;/li&gt;
      &lt;li&gt;搜索、插入、删除的时间复杂度是 O(logn)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;二叉搜索树（Binary Search Tree）是二叉树的一种，英文简称 BST。又称为二叉查找树、二叉排序树。
    &lt;ul&gt;
      &lt;li&gt;它的特点是任何一个结点的值都大于其左子树的所有结点的值，任何一个结点的值都小于其右子树的所有结点的值。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;红黑树是一种含有红黑结点并能自平衡的二叉搜索树。
    &lt;ul&gt;
      &lt;li&gt;为了保证平衡，红黑树必须满足以下性质：
        &lt;ol&gt;
          &lt;li&gt;每个结点是要么是红色或黑色&lt;/li&gt;
          &lt;li&gt;根结点必须是黑色&lt;/li&gt;
          &lt;li&gt;叶结点（外部结点、空结点）是黑色&lt;/li&gt;
          &lt;li&gt;红色结点不能连续（也就是，红色结点的孩子和父亲都是黑色）&lt;/li&gt;
          &lt;li&gt;对于每个结点，从该点至 nil（树尾端，Java 中为 null 的结点）的任何路径都包含所相同个数的黑色结点&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;B 树（Balanced Tree）是一种平衡的多路搜索树，多用于文件系统、数据库的实现。
    &lt;ul&gt;
      &lt;li&gt;1个结点可以存储超过 2 个元素，可以拥有超过 2 个子结点&lt;/li&gt;
      &lt;li&gt;拥有二叉搜索树的一些性质&lt;/li&gt;
      &lt;li&gt;平衡，每个结点的所有子树高度一致&lt;/li&gt;
      &lt;li&gt;比较矮&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数据库为什么用b树不用二叉树&quot;&gt;数据库为什么用B树不用二叉树&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;二叉树的高度以及建数过程，决定了磁盘的存储是分散的，导致读取时IO次数要远远高于B树&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;b树相对b-树的优点&quot;&gt;B+树相对B-树的优点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。&lt;/li&gt;
  &lt;li&gt;所以从Mysql（Inoodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别。&lt;/li&gt;
  &lt;li&gt;所以为了减少内存的占用，索引也会被存储在磁盘上。那么Mysql如何衡量查询效率呢？– 磁盘IO次数。&lt;/li&gt;
  &lt;li&gt;B-树/B+树 的特点就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，增加了磁盘IO次数，磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;所以我们可以看到B+树的优点：
    &lt;ol&gt;
      &lt;li&gt;B+树的层级更少。
  相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；&lt;/li&gt;
      &lt;li&gt;B+树查询速度更稳定。
  B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;&lt;/li&gt;
      &lt;li&gt;B+树天然具备排序功能。
  B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。&lt;/li&gt;
      &lt;li&gt;B+树全节点遍历更快。
  B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;树 &lt;a href=&quot;https://mp.weixin.qq.com/s/sq8rJBtT5mcDYh2ycBuX4g&quot;&gt;https://mp.weixin.qq.com/s/sq8rJBtT5mcDYh2ycBuX4g&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;为什么Mysql用B+树做索引而不用B-树或红黑树？&lt;a href=&quot;http://www.coder55.com/question/139&quot;&gt;http://www.coder55.com/question/139&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 15 Jul 2020 10:47:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/15/Tree.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/15/Tree.html</guid>
        
        <category>数据结构与算法</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Case of online system</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/arch1.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;电商秒杀系统&quot;&gt;电商秒杀系统&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;流量削峰前置
    &lt;ul&gt;
      &lt;li&gt;库存数量判断，直接走缓存，挡掉大部分请求（可以用lua在nginx层做）&lt;/li&gt;
      &lt;li&gt;只接受拥有合法token的等于库存数量的用户（需要考虑超时未支付的）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异步化，轮询秒杀状态及下单&lt;/li&gt;
  &lt;li&gt;redis压力转移
    &lt;ul&gt;
      &lt;li&gt;本地应用服务器可以存储库存&lt;/li&gt;
      &lt;li&gt;商品id_分片的方式分开存储库存&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/tx_ZfE3rqbED0pteYEkdkQ&quot;&gt;https://mp.weixin.qq.com/s/tx_ZfE3rqbED0pteYEkdkQ&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;今日头条系统&quot;&gt;今日头条系统&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;业务数据：2015年 3000万日活、30亿PV、1亿VV、7000台机器&lt;/li&gt;
  &lt;li&gt;技术组件：Scribe、Flume、Kafka、Hadoop、Storm&lt;/li&gt;
  &lt;li&gt;在线存储-abase：QPS读360万、QPS写40万、延时avg 1ms、99%用户不会超过pct99 4ms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mucaoyx/article/details/84498468&quot;&gt;https://blog.csdn.net/mucaoyx/article/details/84498468&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;100亿次的挑战如何实现一个有把握的春晚摇一摇系统&quot;&gt;100亿次的挑战：如何实现一个“有把握”的春晚摇一摇系统&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;指标：QPS1400、全程110亿次、638台接入机器、支撑14.6亿同时在线&lt;/li&gt;
  &lt;li&gt;接入层能支撑200万同时在线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DLbaiSiH15QBkrB_i0imEw&quot;&gt;https://mp.weixin.qq.com/s/DLbaiSiH15QBkrB_i0imEw&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;基于token的多平台身份认证架构设计&quot;&gt;基于token的多平台身份认证架构设计&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/token.png&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/beer/p/6029861.html&quot;&gt;https://www.cnblogs.com/beer/p/6029861.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;框架图&quot;&gt;框架图&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可视化架构设计-C4 &lt;a href=&quot;https://www.jianshu.com/p/33c6a7ed126f&quot;&gt;https://www.jianshu.com/p/33c6a7ed126f&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;语境图、容器图、组件图、类图&lt;/li&gt;
      &lt;li&gt;系统景观图、部署图、动态图&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UML &lt;a href=&quot;https://blog.csdn.net/qq_35495763/article/details/80764914&quot;&gt;https://blog.csdn.net/qq_35495763/article/details/80764914&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;用例图、活动图、序列图、类图、状态机&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;im系统存储设计&quot;&gt;IM系统（存储设计）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;单聊、小群使用写扩散，也就是推模式
    &lt;ul&gt;
      &lt;li&gt;优点：
        &lt;ul&gt;
          &lt;li&gt;消除了拉模式（读扩散）的IO集中点，每个用户都读自己的数据，高并发下锁竞争少&lt;/li&gt;
          &lt;li&gt;拉取朋友圈feed流列表的业务流程异常简单，速度很快&lt;/li&gt;
          &lt;li&gt;拉取朋友圈feed流列表，不需要进行大量的内存计算，网络传输，性能很高&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缺点：
        &lt;ul&gt;
          &lt;li&gt;极大的消耗存储资源，feed数据会存储很多份，例如杨幂5KW粉丝，她每次一发博文，消息会冗余5KW份&lt;/li&gt;
          &lt;li&gt;新增关注，取消关注，发布feed的业务流会更复杂&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;群聊、大VFeed使用写读扩散，也就是拉模式（可以先拉有更新的索引，然后触发服务器推）
    &lt;ul&gt;
      &lt;li&gt;优点：
        &lt;ul&gt;
          &lt;li&gt;存储结构简单，数据存储量较小，关系数据与feed数据都只存一份&lt;/li&gt;
          &lt;li&gt;取消关注，发布feed的业务流程非常简单&lt;/li&gt;
          &lt;li&gt;存储结构，业务流程都比较容易理解，非常适合项目早期用户量、数据量、并发量不大时的快速实现&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缺点：
        &lt;ul&gt;
          &lt;li&gt;拉取朋友圈feed流列表的业务流程非常复杂&lt;/li&gt;
          &lt;li&gt;有多次数据访问，并且要进行大量的内存计算，大量数据的网络传输，性能较低&lt;/li&gt;
          &lt;li&gt;在拉模式中，系统的瓶颈容易出现在“用户所发布feed列表”的读取上，而每个用户发布feed的频率其实是很低的，此时，架构优化的核心是通过缓存降低数据存储磁盘IO。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;现代IM系统中消息推送和存储架构的实现 &lt;a href=&quot;https://developer.aliyun.com/article/253242&quot;&gt;https://developer.aliyun.com/article/253242&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;IM群聊消息的已读回执功能该怎么实现 &lt;a href=&quot;http://www.52im.net/thread-1611-1-1.html&quot;&gt;http://www.52im.net/thread-1611-1-1.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;IM群聊消息的已读未读功能在存储空间方面的实现思路探讨 &lt;a href=&quot;http://www.52im.net/forum.php?mod=viewthread&amp;amp;tid=3054&amp;amp;highlight=%B4%E6%B4%A2&quot;&gt;http://www.52im.net/forum.php?mod=viewthread&amp;amp;tid=3054&amp;amp;highlight=%B4%E6%B4%A2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;微信后台基于时间序的海量数据冷热分级架构设计实践 &lt;a href=&quot;http://www.52im.net/thread-895-1-1.html&quot;&gt;http://www.52im.net/thread-895-1-1.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;微信后台基于时间序的新一代海量数据存储架构的设计实践 &lt;a href=&quot;http://www.52im.net/forum.php?mod=viewthread&amp;amp;tid=2970&amp;amp;highlight=%B4%E6%B4%A2&quot;&gt;http://www.52im.net/forum.php?mod=viewthread&amp;amp;tid=2970&amp;amp;highlight=%B4%E6%B4%A2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;亿级用户中心设计&quot;&gt;亿级用户中心设计&lt;/h4&gt;
&lt;p&gt;用户中心，是典型的“单KEY”类业务，这一类业务，都可以使用上述架构方案。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常见的数据库水平切分方式有两种：
    &lt;ol&gt;
      &lt;li&gt;范围法；&lt;/li&gt;
      &lt;li&gt;哈希法；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;水平切分后碰到的问题是：
    &lt;ol&gt;
      &lt;li&gt;通过uid属性查询能直接定位到库，通过非uid属性查询不能定位到库；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;非uid属性查询，有两类典型的业务：
    &lt;ol&gt;
      &lt;li&gt;用户侧，前台访问，单条记录的查询，访问量较大，服务需要高可用，并且对一致性的要求较高；&lt;/li&gt;
      &lt;li&gt;运营侧，后台访问，根据产品、运营需求，访问模式各异，基本上是批量分页的查询，由于是内部系统，访问量很低，对可用性的要求不高，对一致性的要求也没这么严格；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;针对这两类业务，架构设计的思路是：
    &lt;ol&gt;
      &lt;li&gt;用户侧，采用“建立非uid属性到uid的映射关系”的架构方案；&lt;/li&gt;
      &lt;li&gt;运营侧，采用“前台与后台分离”的架构方案；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;前台用户侧，“建立非uid属性到uid的映射关系”，有四种常见的实践：
    &lt;ol&gt;
      &lt;li&gt;索引表法：数据库中记录login_name与uid的映射关系；&lt;/li&gt;
      &lt;li&gt;缓存映射法：缓存中记录login_name与uid的映射关系；&lt;/li&gt;
      &lt;li&gt;生成uid法：login_name生成uid；&lt;/li&gt;
      &lt;li&gt;基因法：login_name基因融入uid；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;后台运营侧，“前台与后台分离”的最佳实践是：
    &lt;ol&gt;
      &lt;li&gt;前台、后台系统 web/service/db 分离解耦，避免后台低效查询引发前台查询抖动；&lt;/li&gt;
      &lt;li&gt;可以采用数据冗余的设计方式；&lt;/li&gt;
      &lt;li&gt;可以采用“外置索引”（例如ES搜索系统）或者“大数据处理”（例如HIVE）来满足后台变态的查询需求；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/8KTK_Bz8netP6R5MNSKeFw&quot;&gt;https://mp.weixin.qq.com/s/8KTK_Bz8netP6R5MNSKeFw&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;直播系统架构&quot;&gt;直播系统架构&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wintersun/p/5860437.html&quot;&gt;https://www.cnblogs.com/wintersun/p/5860437.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 13 Jul 2020 11:45:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/13/Cases.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/13/Cases.html</guid>
        
        <category>分布式</category>
        
        <category>网络</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Netty In Action</title>
        <description>&lt;h4 id=&quot;其他&quot;&gt;其他&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Netty实战 &lt;a href=&quot;https://mp.weixin.qq.com/s/OFG6tD9YRbII3BgjF4IKRg&quot;&gt;https://mp.weixin.qq.com/s/OFG6tD9YRbII3BgjF4IKRg&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Java网络编程与NIO，多看几遍 &lt;a href=&quot;https://www.cnblogs.com/itxiaok/category/1395489.html&quot;&gt;https://www.cnblogs.com/itxiaok/category/1395489.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;jemalloc之arena、chunk、page、subpage &lt;a href=&quot;https://www.jianshu.com/p/f1988cc08dfd&quot;&gt;https://www.jianshu.com/p/f1988cc08dfd&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;内存规格、缓存&amp;amp;结构、chunk、arena、page、subpage等概念介绍 &lt;a href=&quot;https://blog.csdn.net/qq_33347239/article/details/104270629&quot;&gt;https://blog.csdn.net/qq_33347239/article/details/104270629&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;Arena
        &lt;ul&gt;
          &lt;li&gt;简单来说，Arena就是一个内存分配器，所有分配的内存都是由Arena维护的，并且一般会有多个，目的是减少锁竞争。
而netty则是对jemalloc的Arena进行能更加具体的实现，也就是netty中的PoolArena。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Chunk
        &lt;ul&gt;
          &lt;li&gt;chunk是Netty向操作系统申请内存的最小调度单位，根据上图，chunk大小固定为16mB，也就是说，Netty每次向操作系统申请内存最小为16mB。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Page
        &lt;ul&gt;
          &lt;li&gt;上面说了一个chunk大小是16mb，如果Netty每次分配一个ByteBuf，都用掉一个chunk的大小，那显然太浪费了。&lt;/li&gt;
          &lt;li&gt;于是设计者们就决定将一个chunk划分为2048个Page，每个Page大小为8kb，Page是给ByteBuf分配内存的最小调度单位，尽管还有更小的subpage级别，但是分配subpage时，仍然需要先拿到一个page。&lt;/li&gt;
          &lt;li&gt;当ByteBuf需要申请的内存大小（必定是2的幂次方） &amp;gt;= 8kb时，会先取一个chunk，然后会以page级别分配内存，最后将当前chunk标记为“使用了一个部分”，然后放进对应占用率的chunkList。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;SubPage
        &lt;ul&gt;
          &lt;li&gt;当ByteBuf需要申请的内存大小（必定是2的幂次方）&amp;lt; 8kb时，比如现在需要size=2kb，则会先取一个chunk，然后再取一个page，然后将page分成4份（pageSize/size），每一份为2kb，然后取其中一份给ByteBuf初始化。&lt;/li&gt;
          &lt;li&gt;之后就是一个自底向上标记的过程了，将当前使用的一份subpage标记为“已使用”，上一层page标记为“部分使用”，再上一级chunk标记为“部分使用”，最终也是将chunk放进对应占用率的chunkList。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;关于OS Page Cache的简单介绍，同时再一次介绍了kafka的零拷贝 &lt;a href=&quot;https://www.cnblogs.com/leadership/p/12349486.html&quot;&gt;https://www.cnblogs.com/leadership/p/12349486.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;netty的零拷贝体现在多个方面&quot;&gt;Netty的零拷贝体现在多个方面&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;NIO 的基于mmap的DirectMemory&lt;/li&gt;
  &lt;li&gt;FileRegion 的基于sendFile的transferTo&lt;/li&gt;
  &lt;li&gt;CompositeByteBuf的wrap数组合并与slice数组分拆&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;nio-selector&quot;&gt;NIO Selector&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;linux系统下sun.nio.ch.DefaultSelectorProvider.create(); 会生成一个sun.nio.ch.EPollSelectorProvider类型的SelectorProvider。
或者在META-INF/services包含有一个java.nio.channels.spi.SelectorProvider提供类配置文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SelectorProvider provider&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    synchronized &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;lock&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;provider &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; null&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;provider&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;AccessController.doPrivileged&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
            new PrivilegedAction&amp;lt;&lt;span class=&quot;o&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                public SelectorProvider run&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;loadProviderFromProperty&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;provider&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;loadProviderAsService&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;provider&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        provider &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sun.nio.ch.DefaultSelectorProvider.create&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;provider&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;EPollSelectorImpl中初始化epoll相关方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EPollSelectorImpl&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;SelectorProvider sp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; throws IOException &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        super&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;sp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        long pipeFds &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; IOUtil.makePipe&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        fd0 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pipeFds &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; 32&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        fd1 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; pipeFds&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        try &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            pollWrapper &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; new EPollArrayWrapper&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            pollWrapper.initInterrupt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;fd0, fd1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            fdToKey &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; new HashMap&amp;lt;&lt;span class=&quot;o&quot;&gt;&amp;gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; catch &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Throwable t&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
// EPollArrayWrapper
void initInterrupt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int fd0, int fd1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    outgoingInterruptFD &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; fd1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    incomingInterruptFD &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; fd0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    epollCtl&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;epfd, EPOLL_CTL_ADD, fd0, EPOLLIN&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

private native int epollCreate&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
private native void epollCtl&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int epfd, int opcode, int fd, int events&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
private native int epollWait&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;long pollAddress, int numfds, long &lt;span class=&quot;nb&quot;&gt;timeout&lt;/span&gt;,
                             int epfd&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; throws IOException&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Selector中维护3个特别重要的SelectionKey集合，分别是
    &lt;ul&gt;
      &lt;li&gt;keys：所有注册到Selector的Channel所表示的SelectionKey都会存在于该集合中。keys元素的添加会在Channel注册到Selector时发生。&lt;/li&gt;
      &lt;li&gt;selectedKeys：该集合中的每个SelectionKey都是其对应的Channel在上一次操作selection期间被检查到至少有一种SelectionKey中所感兴趣的操作已经准备好被处理。该集合是keys的一个子集。&lt;/li&gt;
      &lt;li&gt;cancelledKeys：执行了取消操作的SelectionKey会被放入到该集合中。该集合是keys的一个子集。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;参考 &lt;a href=&quot;https://www.cnblogs.com/itxiaok/p/10357828.html&quot;&gt;https://www.cnblogs.com/itxiaok/p/10357828.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;再说epoll&quot;&gt;再说epoll&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;epoll相关系统调用是在Linux 2.5 后的某个版本开始引入的。该系统调用针对传统的select/poll不足，设计上作了很大的改动。select/poll 的缺点在于:
    &lt;ul&gt;
      &lt;li&gt;每次调用时要重复地从用户模式读入参数，并重复地扫描文件描述符。&lt;/li&gt;
      &lt;li&gt;每次在调用开始时，要把当前进程放入各个文件描述符的等待队列。在调用结束后，又把进程从各个等待队列中删除。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;epoll 是把 select/poll 单个的操作拆分为 1 个 epollcreate，多个 epollctrl和一个 wait。
  此外，操作系统内核针对 epoll 操作添加了一个文件系统，每一个或者多个要监视的文件描述符都有一个对应的inode 节点，
  主要信息保存在 eventpoll 结构中。而被监视的文件的重要信息则保存在 epitem 结构中，是一对多的关系。
  由于在执行 epollcreate 和 epollctrl 时，已经把用户模式的信息保存到内核了， 所以之后即便反复地调用 epoll_wait，
  也不会重复地拷贝参数，不会重复扫描文件描述符，也不反复地把当前进程放入/拿出等待队列。&lt;/li&gt;
  &lt;li&gt;select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，
  期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，
  但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。&lt;/li&gt;
  &lt;li&gt;select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次
  （在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;netty的组件&quot;&gt;Netty的组件&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;group() EventLoop -&amp;gt; 控制流、多线程处理、并发
    &lt;ul&gt;
      &lt;li&gt;一个 EventLoopGroup 包含一个或者多个 EventLoop;&lt;/li&gt;
      &lt;li&gt;一个 EventLoop 在它的生命周期内只和一个 Thread 绑定;&lt;/li&gt;
      &lt;li&gt;所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理;&lt;/li&gt;
      &lt;li&gt;一个 Channel 在它的生命周期内只注册于一个 EventLoop，一个Channel可以理解为一个用户;&lt;/li&gt;
      &lt;li&gt;一个 EventLoop 可能会被分配给一个或多个 Channel。 注意，在这种设计中，一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的，实际上消除了对于同步的需要。&lt;/li&gt;
      &lt;li&gt;EventLoop本身只由一个线程驱动，其处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会改变。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;channel() Channel -&amp;gt; Socket
    &lt;ul&gt;
      &lt;li&gt;ChannelPipeline
        &lt;ul&gt;
          &lt;li&gt;handler() ChannelHandler&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ChannelConfig&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ChannelFuture -&amp;gt; 异步通知&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;netty的数据容器bytebuf&quot;&gt;Netty的数据容器ByteBuf&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;它可以被用户自定义的缓冲区类型扩展;&lt;/li&gt;
  &lt;li&gt;通过内置的复合缓冲区类型实现了透明的零拷贝;&lt;/li&gt;
  &lt;li&gt;容量可以按需增长(类似于 JDK 的 StringBuilder);&lt;/li&gt;
  &lt;li&gt;在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip()方法;&lt;/li&gt;
  &lt;li&gt;读和写使用了不同的索引;&lt;/li&gt;
  &lt;li&gt;支持方法的链式调用;&lt;/li&gt;
  &lt;li&gt;支持引用计数;&lt;/li&gt;
  &lt;li&gt;支持池化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;netty的对象池化技术pooledbytebufallocator&quot;&gt;Netty的对象池化技术PooledByteBufAllocator&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过引用计数的方式实现 ReferenceCounted&lt;/li&gt;
  &lt;li&gt;Unpooled.copiedBuffer(“Netty rocks!”,CharsetUtil.UTF-8);&lt;/li&gt;
  &lt;li&gt;由于采用引用计数，需要在消费完消息之后调用ReferenceCountUtil.release(msg);&lt;/li&gt;
  &lt;li&gt;可以通过 java -Dio.netty.leakDetectionLevel=ADVANCED 这个参数设置泄露检测级别
&lt;img src=&quot;/img/leak_level.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;channelhandler-channelpipeline-channelhandlercontext&quot;&gt;ChannelHandler ChannelPipeline ChannelHandlerContext&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;每个ChannelHandler都会分配一个ChannelHandlerContext&lt;/li&gt;
  &lt;li&gt;通过Channel、Handler的write会传递整个pipe，但是通过context的write只能传递对应Handler之后的handlers&lt;/li&gt;
  &lt;li&gt;SimpleChannelInboundHandler&lt;T&gt;，最常见的情况是，你的应用程序会利用一个 ChannelHandler 来接收解码消息，并对该数据应用业务逻辑。要创建一个这样的 ChannelHandler，
  你只需要扩展基类 SimpleChannel- InboundHandler&lt;T&gt;，其中 T 是你要处理的消息的 Java 类型 。
  在这个 ChannelHandler 中， 你将需要重写基类的一个或者多个方法，并且获取一个到 ChannelHandlerContext 的引用， 
  这个引用将作为输入参数传递给 ChannelHandler 的所有方法。在这种类型的 ChannelHandler 中，最重要的方法是 channelRead0(Channel- HandlerContext,T)。除了要求不要阻塞当前的 I/O 线程之外，其具体实现完全取决于你。&lt;/T&gt;&lt;/T&gt;&lt;/li&gt;
  &lt;li&gt;ChannelOutboundHandlerAdapter，几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise 的实例。
  作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;promise.addListener&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new ChannelFutureListener&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
@Override
public void operationComplete&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ChannelFuture f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;f.isSuccess&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; f.cause&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;.printStackTrace&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                      f.channel&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;.close&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h4 id=&quot;eventloop和线程池&quot;&gt;EventLoop和线程池&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;本质是创建包含少量的线程EventLoop的线程池EventLoopGroup，一个EventLoop管理多个Channel，
  实际上就是IO多路复用
&lt;img src=&quot;/img/eventLoop.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;bootstrap&quot;&gt;Bootstrap&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;为什么引导类是 Cloneable 的 你有时可能会需要创建多个具有类似配置或者完全相同配置的Channel。为了支持这种模式而又不
    &lt;ul&gt;
      &lt;li&gt;需要为每个Channel都创建并配置一个新的引导类实例，AbstractBootstrap被标记为了 Cloneable1。在一个已经配置完成的引导类实例上调用clone()方法将返回另一个可以立即使用的引 导类实例。&lt;/li&gt;
      &lt;li&gt;注意，这种方式只会创建引导类实例的EventLoopGroup的一个浅拷贝，所以，后者 2将在所有克 隆的Channel实例之间共享。这是可以接受的，因为通常这些克隆的Channel的生命周期都很短暂，一 个典型的场景是——创建一个Channel以进行一次HTTP请求。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;netty-设计&quot;&gt;Netty 设计&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从高层次的角度来看，Netty 解决了两个相应的关注领域，我们可将其大致标记为技术的和 体系结构的。
    &lt;ul&gt;
      &lt;li&gt;首先，它的基于 Java NIO 的异步的和事件驱动的实现，保证了高负载下应用程序 性能的最大化和可伸缩性。&lt;/li&gt;
      &lt;li&gt;其次，Netty 也包含了一组设计模式，将应用程序逻辑从网络层解耦， 简化了开发过程，同时也最大限度地提高了可测试性、模块化以及代码的可重用性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;不使用netty的nio&quot;&gt;不使用Netty的NIO&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/nio-selector.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;netty-的-opensslsslengine-实现&quot;&gt;Netty 的 OpenSSL/SSLEngine 实现&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Netty 还提供了使用 OpenSSL 工具包(www.openssl.org)的 SSLEngine 实现。这个 OpenSsl-Engine 类提供了比 JDK 提供的 SSLEngine 实现更好的性能。&lt;/li&gt;
  &lt;li&gt;如果 OpenSSL 库可用，可以将 Netty 应用程序(客户端和服务器)配置为默认使用 OpenSslEngine。如果不可用，Netty 将会回退到 JDK 实现。有关配置 OpenSSL 支持的详细说明，参见 Netty 文档: http://netty.io/wiki/forked-tomcat-native.html#wikih2-1。&lt;/li&gt;
  &lt;li&gt;注意，无论你使用 JDK 的 SSLEngine 还是使用 Netty 的 OpenSslEngine，SSL API 和数据流都 是一致的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/ssl_tls.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SelfSignedCertificate cert &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; new SelfSignedCertificate&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
SslContext context &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; SslContext.newServerContext&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cert.certificate&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;, cert.privateKey&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

SSLEngine engine &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; context.newEngine&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ch.alloc&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
engine.setUseClientMode&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
ch.pipeline&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;.addFirst&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new SslHandler&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;engine&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;检测空闲连接以及超时对于及时释放资源&quot;&gt;检测空闲连接以及超时对于及时释放资源&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS)&lt;/li&gt;
  &lt;li&gt;ReadTimeoutHandler exceptionCaught()&lt;/li&gt;
  &lt;li&gt;WriteTimeoutHandler exceptionCaught()&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;写大数据&quot;&gt;写大数据&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ChunkedFile 从文件中逐块获取数据，当你的平台不支持零拷贝或者你需要转换数据时使用&lt;/li&gt;
  &lt;li&gt;ChunkedNioFile 和 ChunkedFile 类似，只是它使用了 FileChannel&lt;/li&gt;
  &lt;li&gt;ChunkedStream 从 InputStream 中逐块传输内容&lt;/li&gt;
  &lt;li&gt;ChunkedNioStream 从ReadableByteChannel中逐块传输内容
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class WriteStreamHandler extends ChannelInboundHandlerAdapter &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  @Override
  public void channelActive&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ChannelHandlerContext ctx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;throws Exception &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      super.channelActive&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ctx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      ctx.writeAndFlush&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      new ChunkedStream&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new FileInputStream&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;file&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h4 id=&quot;websocketframe&quot;&gt;WebSocketFrame&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;BinaryWebSocketFrame 包含了二进制数据&lt;/li&gt;
  &lt;li&gt;TextWebSocketFrame 包含了文本数据&lt;/li&gt;
  &lt;li&gt;ContinuationWebSocketFrame 包含属于上一个BinaryWebSocketFrame或TextWebSocket-Frame 的文本数据或者二进制数据&lt;/li&gt;
  &lt;li&gt;CloseWebSocketFrame 表示一个 CLOSE 请求，包含一个关闭的状态码和关闭的原因&lt;/li&gt;
  &lt;li&gt;PingWebSocketFrame 作为一个对于 PingWebSocketFrame 的响应被发送&lt;/li&gt;
  &lt;li&gt;PongWebSocketFrame 请求传输一个 PongWebSocketFrame&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;websocket示例&quot;&gt;WebSocket示例&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ChannelPipeline pipeline &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; ch.pipeline&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# http编解码&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new HttpServerCodec&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 写入一个文件的内容&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new ChunkedWriteHandler&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 将一个 HttpMessage 和跟随它的多个 HttpContent 聚合&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 为单个 FullHttpRequest 或者 FullHttpResponse(取决于它是被用来处理请求还是响应)。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 安装了这个之后， ChannelPipeline 中的下一个 ChannelHandler 将只会 收到完整的 HTTP 请求或响应&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new HttpObjectAggregator&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;64 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 1024&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 如果是/ws请求就交个下个handler，否则HTTP handler来处理&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new HttpRequestHandler&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/ws&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 按照 WebSocket 规范的要求，处理 WebSocket 升级握手、 PingWebSocketFrame 、 PongWebSocketFrame 和 CloseWebSocketFrame&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new WebSocketServerProtocolHandler&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/ws&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 处理 TextWebSocketFrame 和握手完成事件&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new TextWebSocketFrameHandler&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;group&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在从标准的HTTP或者HTTPS协议切换到WebSocket时，将会使用一种称为升级握手的机制。因此 ，使用WebSocket的应用程序将始终以HTTP/S作为开始，然后再执行升级。这个升级动 作发生的确切时刻特定于应用程序;它可能会发生在启动时，也可能会发生在请求了某个特定的 URL之后。&lt;/p&gt;

&lt;h4 id=&quot;理解http协议中的-expect-100-continue&quot;&gt;理解HTTP协议中的 Expect: 100-continue&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP/1.1 协议里设计 100 (Continue) HTTP 状态码的的目的是，在客户端发送 Request Message 之前，HTTP/1.1 协议允许客户端先判定服务器是否愿意接受客户端发来的消息主体（基于 Request Headers）。&lt;/li&gt;
  &lt;li&gt;即， 客户端 在 Post（较大）数据到服务端之前，允许双方“握手”，如果匹配上了，Client 才开始发送（较大）数据。&lt;/li&gt;
  &lt;li&gt;这么做的原因是，如果客户端直接发送请求数据，但是服务器又将该请求拒绝的话，这种行为将带来很大的资源开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/skh2015java/article/details/88723028&quot;&gt;https://blog.csdn.net/skh2015java/article/details/88723028&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;http协议与websocket协议升级过程&quot;&gt;http协议与websocket协议升级过程&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# req&lt;/span&gt;
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: &lt;span class=&quot;nv&quot;&gt;x3JJHMbDL1EzLkh9GBhXDw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com

&lt;span class=&quot;c&quot;&gt;# resp&lt;/span&gt;
Sec-WebSocket-Key: &lt;span class=&quot;nv&quot;&gt;x3JJHMbDL1EzLkh9GBhXDw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.xiaosongit.com/index/detail/id/645.html&quot;&gt;http://www.xiaosongit.com/index/detail/id/645.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;其他-1&quot;&gt;其他&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ChannelFuture 与 ChannelFutureListener相互结合，构成了Netty本身的关键构件之一&lt;/li&gt;
  &lt;li&gt;关于ServerBootStrap，因为服务器需要两组不同的 Channel。第一组将只包含一个 ServerChannel，代表服务 器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传 入客户端连接(对于每个服务器已经接受的连接都有一个)的 Channel。&lt;/li&gt;
  &lt;li&gt;PCB Process Control Block&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 08 Jul 2020 18:18:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/08/NettyInAction.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/08/NettyInAction.html</guid>
        
        <category>Java</category>
        
        <category>网络</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>DotDot</title>
        <description>&lt;h4 id=&quot;arraylist的扩容方式和扩容时机&quot;&gt;ArrayList的扩容方式和扩容时机&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;初始化
  ArrayList的底层是一个动态数组，ArrayList首先会对传进来的初始化参数initalCapacity进行判断
  如果参数等于0，则将数组初始化为一个空数组，
  如果不等于0，将数组初始化为一个容量为10的数组。&lt;/li&gt;
  &lt;li&gt;扩容时机
  当数组的大小大于初始容量的时候(比如初始为10，当添加第11个元素的时候)，就会进行扩容，新的容量为旧的容量的1.5倍。
  Vector会扩容2倍。&lt;/li&gt;
  &lt;li&gt;扩容方式
 扩容的时候，会以新的容量建一个原数组的拷贝，修改原数组，指向这个新数组，原数组被抛弃，会被GC回收。&lt;/li&gt;
  &lt;li&gt;蚂蚁金服 &lt;a href=&quot;https://www.cnblogs.com/silyvin/p/10223910.html&quot;&gt;https://www.cnblogs.com/silyvin/p/10223910.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;volatile保证可见性禁止重排无法实现原子性&quot;&gt;volatile（保证可见性、禁止重排、无法实现原子性）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;指令重排只会保证串行语义的执行一致性(单线程) 并不会关心多线程间的语义一致性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cas--unsafe&quot;&gt;CAS &amp;amp; Unsafe&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CAS的全称为Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。&lt;/li&gt;
  &lt;li&gt;CAS并发原语体现在JAVA语言中就是sum.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所有的数据不一致问题。&lt;/li&gt;
  &lt;li&gt;CAS只能保证一个共享变量的原子性&lt;/li&gt;
  &lt;li&gt;CAS自旋&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 我们可以看到getAndAddInt方法执行时，有个do while&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# unsafe.getAndAddInt&lt;/span&gt;
public final int getAndAddInt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Object var1, long var2, int var4&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    int var5&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        var5 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; this.getIntVolatile&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;var1, var2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;this.compareAndSwapInt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;var1, var2, var5, var5 + var4&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;var5&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会能CPU带来很大的开锁。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;CAS造成的ABA问题用版本号解决&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# （旧值，新值）&lt;/span&gt;
atomicReference.compareAndSet&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;101, 100&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# AtomicStampedReference 以时间戳做为版本号解决ABA的问题&lt;/span&gt;
public boolean compareAndSet&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;exchanger&quot;&gt;Exchanger&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;允许在并发任务之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中&lt;/li&gt;
  &lt;li&gt;例子模拟一个队列中数据的交换使用的场景：
    &lt;ul&gt;
      &lt;li&gt;线程A往队列中存入数据&lt;/li&gt;
      &lt;li&gt;线程B从队列中消耗数据&lt;/li&gt;
      &lt;li&gt;当线程A存满的时候&lt;/li&gt;
      &lt;li&gt;才交换给线程B&lt;/li&gt;
      &lt;li&gt;当线程B消耗完成之后才交换给线程A。&lt;/li&gt;
      &lt;li&gt;线程A、B的生产和消耗的速率有可能不同&lt;/li&gt;
      &lt;li&gt;对方线程调用exchange之前，另一个线程执行到exchange会阻塞&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jvm-对-java-的原生锁做了哪些优化&quot;&gt;JVM 对 Java 的原生锁做了哪些优化？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一种优化是使用自旋锁，即在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;现代 JDK 中还提供了三种不同的 Monitor 实现，也就是三种不同的锁：
    &lt;ul&gt;
      &lt;li&gt;偏向锁（Biased Locking）&lt;/li&gt;
      &lt;li&gt;轻量级锁&lt;/li&gt;
      &lt;li&gt;重量级锁,这三种锁使得 JDK 得以优化 Synchronized 的运行，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这就是锁的升级、降级。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当没有竞争出现时，默认会使用偏向锁。
    &lt;ul&gt;
      &lt;li&gt;JVM 会利用 CAS 操作，在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁，因为在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果有另一线程试图锁定某个被偏斜过的对象，JVM 就撤销偏斜锁，切换到轻量级锁实现。&lt;/li&gt;
  &lt;li&gt;轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;readwritelock&quot;&gt;ReadWriteLock&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final boolean tryWriteLock&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            Thread current &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Thread.currentThread&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            int c &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; getState&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                int w &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; exclusiveCount&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;w &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; current &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; getExclusiveOwnerThread&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;w &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; MAX_COUNT&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    throw new Error&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;compareAndSetState&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c, c + 1&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            setExclusiveOwnerThread&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;current&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        /&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Performs tryLock &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt;, enabling barging &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;both modes.
         &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; This is identical &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;effect to tryAcquireShared except &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; lack of calls to readerShouldBlock.
         &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/
        final boolean tryReadLock&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            Thread current &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Thread.currentThread&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                int c &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; getState&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;exclusiveCount&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                    getExclusiveOwnerThread&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; current&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                int r &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sharedCount&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;r &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; MAX_COUNT&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    throw new Error&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;compareAndSetState&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c, c + SHARED_UNIT&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;r &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        firstReader &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; current&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        firstReaderHoldCount &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;firstReader &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; current&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        firstReaderHoldCount++&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        HoldCounter rh &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; cachedHoldCounter&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rh &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; null &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; rh.tid &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; getThreadId&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;current&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                            cachedHoldCounter &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; rh &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; readHolds.get&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;else if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rh.count &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                            readHolds.set&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rh&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        rh.count++&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;面向对象的五大基本原则solid&quot;&gt;面向对象的五大基本原则(solid)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;S单一职责SRP:Single-Responsibility Principle
   一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。&lt;/li&gt;
  &lt;li&gt;O开放封闭原则OCP:Open-Closed Principle
   软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭&lt;/li&gt;
  &lt;li&gt;L里氏替换原则LSP:Liskov-Substitution Principle
   子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。&lt;/li&gt;
  &lt;li&gt;I接口隔离原则ISP:Interface-Segregation Principle
   使用多个小的接口,而不是一个大的总接口&lt;/li&gt;
  &lt;li&gt;D依赖倒置原则DIP:Dependency-Inversion Principle
   依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;类什么时候才被初始化&quot;&gt;类什么时候才被初始化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;创建类的实例，也就是new一个对象&lt;/li&gt;
  &lt;li&gt;访问某个类或接口的静态变量，或者对该静态变量赋值&lt;/li&gt;
  &lt;li&gt;调用类的静态方法&lt;/li&gt;
  &lt;li&gt;反射（Class.forName(“com.lyj.load”)）&lt;/li&gt;
  &lt;li&gt;初始化一个类的子类（会首先初始化子类的父类）&lt;/li&gt;
  &lt;li&gt;JVM启动时标明的启动类，即文件名和类名相同的那个类&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;arraylist&quot;&gt;ArrayList&lt;/h4&gt;
&lt;p&gt;ArrayList创建时的大小为0；当加入第一个元素时，进行第一次扩容时，默认容量大小为10。
ArrayList每次扩容都以当前数组大小的1.5倍去扩容。
Vector创建时的默认大小为10。
Vector每次扩容都以当前数组大小的2倍去扩容。当指定了capacityIncrement之后，每次扩容仅在原先基础上增加capacityIncrement个单位空间。
ArrayList和Vector的add、get、size方法的复杂度都为O(1)，remove方法的复杂度为O(n)。
ArrayList是非线程安全的，Vector是线程安全的。&lt;/p&gt;

&lt;h4 id=&quot;hashmap为什么初始容量是2的指数幂&quot;&gt;hashmap为什么初始容量是2的指数幂&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;hashmap在确定元素落在数组的位置的时候，计算方法是hash%n，类似数据库分表，但是“取模”运算的消耗还是比较大的，可以用(n - 1) &amp;amp; hash的位运算来使计算更加高效。&lt;/li&gt;
  &lt;li&gt;如果初始容量是奇数，那么（n-1)就为偶数，偶数2进制的结尾都是0，经过hash值&amp;amp;运算后末尾都是0，那么0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这样就会造成空间的浪费而且会增加hash冲突。&lt;/li&gt;
  &lt;li&gt;只有是2的指数次幂的数字经过n-1之后，二进制尾数才是1，这样hash最后一位无论是什么，完全是由产生的hash值类决定，而不受n-1 影响。这样会提高效率。比如要扩容了，2的幂次方*2，在二进制中比如4和8，代表2的2次方和3次方，他们的2进制结构相 似,
比如 4：00000100 和 8：0000 1000，只是高位向前移了一位，这样扩容的时候，只需要判断高位hash,移动到之前位置的倍数就可以了，免去了重新计算位置的运算。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;springboot-start&quot;&gt;SpringBoot Start&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;引入该Start相关依赖&lt;/li&gt;
  &lt;li&gt;查找resources/META-INF/spring.factories下对应的XXXAutoConfigure&lt;/li&gt;
  &lt;li&gt;根据Condition自己加装相关的Bean
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnBean:当容器中有指定的Bean的条件下&lt;/li&gt;
      &lt;li&gt;@ConditionalOnClass：当类路径下有指定的类的条件下&lt;/li&gt;
      &lt;li&gt;@ConditionalOnExpression:基于SpEL表达式作为判断条件&lt;/li&gt;
      &lt;li&gt;@ConditionalOnJava:基于JVM版本作为判断条件&lt;/li&gt;
      &lt;li&gt;@ConditionalOnJndi:在JNDI存在的条件下查找指定的位置&lt;/li&gt;
      &lt;li&gt;@ConditionalOnMissingBean:当容器中没有指定Bean的情况下&lt;/li&gt;
      &lt;li&gt;@ConditionalOnMissingClass:当类路径下没有指定的类的条件下&lt;/li&gt;
      &lt;li&gt;@ConditionalOnNotWebApplication:当前项目不是Web项目的条件下&lt;/li&gt;
      &lt;li&gt;@ConditionalOnProperty:指定的属性是否有指定的值&lt;/li&gt;
      &lt;li&gt;@ConditionalOnResource:类路径下是否有指定的资源&lt;/li&gt;
      &lt;li&gt;@ConditionalOnSingleCandidate:当指定的Bean在容器中只有一个，或者在有多个Bean的情况下，用来指定首选的Bean&lt;/li&gt;
      &lt;li&gt;@ConditionalOnWebApplication:当前项目是Web项目的条件下&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yuansc/p/9088212.html&quot;&gt;https://www.cnblogs.com/yuansc/p/9088212.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;spring中解决循环依赖为什么要用三级缓存&quot;&gt;Spring中解决循环依赖为什么要用三级缓存&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Bean创建有3步
    &lt;ol&gt;
      &lt;li&gt;初始化init,分配内存空间，此时在singletonFactories完成&lt;/li&gt;
      &lt;li&gt;注入各种属性，此时在earlySingletonObjects中&lt;/li&gt;
      &lt;li&gt;完美的bean最终会在singletonObjects中&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;举例
    &lt;ul&gt;
      &lt;li&gt;A与B循环依赖，A初始化经过第1、2步，在第2步发现依赖B&lt;/li&gt;
      &lt;li&gt;此时，触发B的初始化进入第1步，如果再进入第2步，会发现依赖A了，所以此时B只能在第1步&lt;/li&gt;
      &lt;li&gt;把B的第1步，不完美的B注入给A，先完成A的注入，让A进入第3步&lt;/li&gt;
      &lt;li&gt;然后，再完成B的完美初始化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;关于nio的-channel与bytebuffer&quot;&gt;关于NIO的 Channel与ByteBuffer&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Buffer的使用，主要是减少copy实现零拷贝，流的读写方式还是基于用户态和内核态的拷贝&lt;/li&gt;
  &lt;li&gt;从使用NIO读写文件说起——拆解堆外内存分配过程  &lt;a href=&quot;https://mp.weixin.qq.com/s/Wea1ubBTH9jXSZtU9NwVhw&quot;&gt;https://mp.weixin.qq.com/s/Wea1ubBTH9jXSZtU9NwVhw&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;从操作系统看NIO &lt;a href=&quot;https://mp.weixin.qq.com/s/Titt2vOEtSWIzEbtWKQOzA&quot;&gt;https://mp.weixin.qq.com/s/Titt2vOEtSWIzEbtWKQOzA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;关于nio的-空轮训的bug&quot;&gt;关于NIO的 空轮训的bug&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    selector.select&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  // &lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;可能在无就绪事件时异常返回！主要发生在linux系统

    Set&amp;lt;SelectionKey&amp;gt; readyKeys &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; selector.selectedKeys&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    Iterator&amp;lt;SelectionKey&amp;gt; it &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; readyKeys.iterator&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;it.hasNext&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        SelectionKey key &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; it.next&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        ...  // 处理事件
        it.remove&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;selector.select() 应该 一直阻塞，直到有就绪事件到达，但很遗憾，由于 Java NIO 实现上存在 bug，select() 可能在 没有 任何就绪事件的情况下返回，从而导致 while(true) 被不断执行，最后导致某个 CPU 核心的利用率飙升到 100%，这就是臭名昭著的 Java NIO 的 epoll bug。&lt;/li&gt;
  &lt;li&gt;解决方法&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;selectCnt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  // epoll 空轮询场景下 &lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;调用次数
long currentTimeNanos &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; System.nanoTime&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  // 每个 &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;循环开始时的绝对时间

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    timeoutMillis &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; ...  // 初始化超时参数

    int selectedKeys &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; selector.select&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;timeoutMillis&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    selectCnt++&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    long &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; System.nanoTime&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  // 记录执行到此处的绝对时间：

    // 检测逻辑
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt; - currentTimeNanos &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; timeoutMillis&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        selectCnt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  // 未发生 epoll 空轮询，所以把 selectCnt 重置为 1
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;selectCnt &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; 重试次数阈值（默认 512）&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        selector &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; selectRebuildSelector&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;selectCnt&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  // 解决 epoll bug 的实际逻辑
        selectCnt &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  // 解决本次 epoll bug，重置 selectCnt
        &lt;span class=&quot;nb&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    currentTimeNanos &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  // 重置下次 &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;循环开始时间
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://songkun.me/2019/07/26/2019-07-26-java-nio-epoll-bug-and-netty-solution/&quot;&gt;http://songkun.me/2019/07/26/2019-07-26-java-nio-epoll-bug-and-netty-solution/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;netty零拷贝总结的比较清楚了&quot;&gt;Netty零拷贝总结的比较清楚了&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;零拷贝
    &lt;ul&gt;
      &lt;li&gt;在传统的I/O操作中，每次都需要把内核空间的数据拷贝到用户空间中，这样挺浪费空间的，所以零拷贝的出现就是为了解决这个问题。&lt;/li&gt;
      &lt;li&gt;主要有两种方法：mmap+write 和 Sendfile&lt;/li&gt;
      &lt;li&gt;mmap+write&lt;/li&gt;
      &lt;li&gt;使用mmap+write方式替换原来的read+write方式，mmap是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。
  这样就可以省略掉原来内核Read缓冲区Copy数据到用户缓冲区，但是还是需要内核Read缓冲区将数据Copy到内核Socket缓冲区。&lt;/li&gt;
      &lt;li&gt;Sendfile&lt;/li&gt;
      &lt;li&gt;Sendfile是为了简化通过网络在两个通道内进行的数据传输过程。&lt;/li&gt;
      &lt;li&gt;它不仅减少了数据复制，还减少了上下文次数的切换。数据传送只发生在内核空间里，所以减少了一次上下文切换，但是还是存在一次Copy。
  后来进行了改进，将Kernel Buffer中对应的数据描述信息（内存地址，偏移量）记录到相应的Socket缓冲区中，这样连内核空间中的一次CPU Copy也省掉了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Netty的零拷贝具体体现
    &lt;ul&gt;
      &lt;li&gt;Netty零拷贝主要体现在三个方面。&lt;/li&gt;
      &lt;li&gt;Netty的接收和发送ByteBuffer采用DirtectByteBuffer，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。&lt;/li&gt;
      &lt;li&gt;Netty在操作多个Channel时，使用CompositeChannelBuffer，它并不会开辟新的内存并复制所有ChannelBuffer内容，而是直接保存了所有ChannelBuffer的引用，并在子ChannelBuffer里进行读写，实现了零拷贝。&lt;/li&gt;
      &lt;li&gt;Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/mFhSemUjxxsp6RBpvT6Cmg&quot;&gt;https://mp.weixin.qq.com/s/mFhSemUjxxsp6RBpvT6Cmg&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;netty&quot;&gt;Netty&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaoyangjia/p/11526197.html&quot;&gt;https://www.cnblogs.com/xiaoyangjia/p/11526197.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;utf-8-是一种变长的编码方式&quot;&gt;Utf-8 是一种变长的编码方式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。&lt;/li&gt;
  &lt;li&gt;对于n字节的符号（n&amp;gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
    &lt;ul&gt;
      &lt;li&gt;1110xxxx 10xxxxxx 10xxxxxx （3个字节，xxx放入Unicode）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Little endian和Big endian
    &lt;ul&gt;
      &lt;li&gt;Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。&lt;/li&gt;
      &lt;li&gt;如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;redis与memcached区别&quot;&gt;Redis与Memcached区别&lt;/h4&gt;
&lt;p&gt;如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。&lt;/li&gt;
  &lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li&gt;
  &lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
  &lt;li&gt;在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别&lt;/li&gt;
  &lt;li&gt;memcache可以存储大文件&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;dns&quot;&gt;DNS&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在UDP协议栈上方&lt;/li&gt;
  &lt;li&gt;全面了解移动端DNS域名劫持等杂症：原理、根源、HttpDNS解决方案等 &lt;a href=&quot;http://www.52im.net/thread-2121-1-1.html&quot;&gt;http://www.52im.net/thread-2121-1-1.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;HTTPDNS 替代 LocalDNS
    &lt;ol&gt;
      &lt;li&gt;解决域名检验和多个子域名多个证书SNI（Server Name Indication 允许客户端向服务器提供它所请求的域名） 的问题
        &lt;ul&gt;
          &lt;li&gt;android 美图APP &lt;a href=&quot;http://www.52im.net/thread-2172-1-1.html&quot;&gt;http://www.52im.net/thread-2172-1-1.html&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;ios &lt;a href=&quot;https://kangzubin.com/httpdns-https/&quot;&gt;https://kangzubin.com/httpdns-https/&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;百度 &lt;a href=&quot;http://www.52im.net/thread-2472-1-1.html&quot;&gt;http://www.52im.net/thread-2472-1-1.html&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lvs之drnattun模式祥解&quot;&gt;LVS之DR,NAT,TUN模式祥解&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;NAT：修改请求报文的目标IP，多目标IP的DNAT&lt;/li&gt;
  &lt;li&gt;DR：操纵封装新的MAC地址&lt;/li&gt;
  &lt;li&gt;TUN：在原请求IP报文之外新加一个IP首部&lt;/li&gt;
  &lt;li&gt;FullNAT：修改请求报文的源和目标IP&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;nat-与-打洞&quot;&gt;Nat 与 打洞&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Nat技术 Net Address Transfer
    &lt;ul&gt;
      &lt;li&gt;全锥型NAT：一旦内部主机端口对(iAddr:iPort)被NAT网关映射到(eAddr:ePort)，所有后续的(iAddr:iPort)报文都会被转换为(eAddr:ePort)；任何一个外部主机发送到(eAddr:ePort)的报文将会被转换后发到(iAddr:iPort)。&lt;/li&gt;
      &lt;li&gt;限制锥型NAT：在全锥基础上限制机器&lt;/li&gt;
      &lt;li&gt;端口限制锥型NAT：在限制锥型NAT基础上限制端口&lt;/li&gt;
      &lt;li&gt;对称型NAT：限制在固定的主机+端口，可以理解为是”Session级”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;p2p打洞原理是通过中间服务器S”伪装”连接，获取到P1与P2的公网IP+端口组合，然后P1与P2分别伪装S与彼此建立连接&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.52im.net/thread-542-1-1.html&quot;&gt;http://www.52im.net/thread-542-1-1.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.52im.net/thread-50-1-1.html&quot;&gt;http://www.52im.net/thread-50-1-1.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/weiyuefei/article/details/52247497&quot;&gt;https://blog.csdn.net/weiyuefei/article/details/52247497&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;内存泄漏&quot;&gt;内存泄漏&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;内部类持有外部类&lt;/li&gt;
  &lt;li&gt;静态集合类&lt;/li&gt;
  &lt;li&gt;各种连接的打开与关闭&lt;/li&gt;
  &lt;li&gt;变量作用域不合理，比如类似逃逸&lt;/li&gt;
  &lt;li&gt;改变了Hash算法，导致之前的hash key 对应的 value不能被释放&lt;/li&gt;
  &lt;li&gt;ThreadLocal内存泄漏，是因为内部的Map的key是通过虚引用关联的threadLocal，发生GC的时候key就消失了，造成Value泄漏。使用的时候记得显示remove
 &lt;a href=&quot;https://www.jianshu.com/p/1a5d288bdaee&quot;&gt;https://www.jianshu.com/p/1a5d288bdaee&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;监听器的回调绑定与取消&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;direct-memory-回收&quot;&gt;Direct Memory 回收&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;DirectByteBuffer是通过虚引用(Phantom Reference)来实现堆外内存的释放的&lt;/li&gt;
  &lt;li&gt;Cleaner是PhantomReference的子类，并通过自身的next和prev字段维护的一个双向链表。PhantomReference的作用在于跟踪垃圾回收过程，
  并不会对对象的垃圾回收过程造成任何的影响。 所以cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); 
  用于对当前构造的DirectByteBuffer对象的垃圾回收过程进行跟踪。 当DirectByteBuffer对象从pending状态 ——&amp;gt; enqueue状态时，会触发Cleaner的clean()，
  而Cleaner的clean()的方法会实现通过unsafe对堆外内存的释放。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        try &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            base &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; unsafe.allocateMemory&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;size&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; catch &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;OutOfMemoryError x&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            Bits.unreserveMemory&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;size, cap&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            throw x&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        unsafe.setMemory&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;base, size, &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;byte&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pa &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;base % ps &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            // Round up to page boundary
            address &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; base + ps - &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;base &amp;amp; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ps - 1&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            address &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; base&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        // DirectByteBuffer 内 构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，堆外内存也会被释放
        cleaner &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Cleaner.create&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;this, new Deallocator&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;base, size, cap&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        // Cleaner 内 clean
        cleaner.clean&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        // Deallocator 继承 Runnable
        public void run&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;address &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                // Paranoia
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            unsafe.freeMemory&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;address&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            address &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            Bits.unreserveMemory&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;size, capacity&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;java之HeapByteBuffer&amp;amp;DirectByteBuffer以及回收DirectByteBuffer &lt;a href=&quot;https://blog.csdn.net/xieyuooo/article/details/7547435&quot;&gt;https://blog.csdn.net/xieyuooo/article/details/7547435&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;java nio 和 jvm 虚拟机参数的 XX:+DisableExplicitGC 的潜规则 &lt;a href=&quot;https://blog.csdn.net/phj88/article/details/8011830&quot;&gt;https://blog.csdn.net/phj88/article/details/8011830&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Java网络编程和NIO详解8：浅析mmap和Direct Buffer &lt;a href=&quot;https://www.cnblogs.com/itxiaok/p/10357832.html&quot;&gt;https://www.cnblogs.com/itxiaok/p/10357832.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;KAFKA推送消息用到了sendfile，落盘技术用到了mmap，DMA贯穿其中 &lt;a href=&quot;https://www.jianshu.com/p/7863667d5fa7&quot;&gt;https://www.jianshu.com/p/7863667d5fa7&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Java魔法类：Unsafe应用解析 &lt;a href=&quot;https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html&quot;&gt;https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jdk-各个版本特性&quot;&gt;JDK 各个版本特性&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Java5 ，2004-09-30发行
    &lt;ul&gt;
      &lt;li&gt;泛型&lt;/li&gt;
      &lt;li&gt;枚举&lt;/li&gt;
      &lt;li&gt;自动装箱拆箱&lt;/li&gt;
      &lt;li&gt;可变参数&lt;/li&gt;
      &lt;li&gt;注解&lt;/li&gt;
      &lt;li&gt;foreach循环（增强for、for/in）&lt;/li&gt;
      &lt;li&gt;静态导入&lt;/li&gt;
      &lt;li&gt;格式化（System.out.println 支持%s %d等格式化输出）&lt;/li&gt;
      &lt;li&gt;线程框架/数据结构 JUC&lt;/li&gt;
      &lt;li&gt;Arrays工具类/StringBuilder/instrument&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java6
    &lt;ul&gt;
      &lt;li&gt;开发代号为Mustang(野马),于2006-12-11发行。评价：鸡肋的版本，有JDBC4.0更新、Complier API、WebSevice支持的加强等更新。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java7  2011年7月7日
    &lt;ul&gt;
      &lt;li&gt;switch中添加对String类型的支持&lt;/li&gt;
      &lt;li&gt;数字字面量的改进 / 数值可加下划&lt;/li&gt;
      &lt;li&gt;异常处理（捕获多个异常） try-with-resources&lt;/li&gt;
      &lt;li&gt;增强泛型推断&lt;/li&gt;
      &lt;li&gt;JSR203 NIO2.0（AIO）新IO的支持&lt;/li&gt;
      &lt;li&gt;JSR292与InvokeDynamic指令，可以调用其他语言生成的字节码&lt;/li&gt;
      &lt;li&gt;Path接口、DirectoryStream、Files、WatchService（重要接口更新）&lt;/li&gt;
      &lt;li&gt;fork/join framework 并行计算&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;Java8 2014年
        &lt;ul&gt;
          &lt;li&gt;Lambda&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java9 2017年9月1日
    &lt;ul&gt;
      &lt;li&gt;平台级modularity（原名：Jigsaw） 模块化系统&lt;/li&gt;
      &lt;li&gt;Java 的 REPL 工具： jShell 命令&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java10 2018年3月20日
    &lt;ul&gt;
      &lt;li&gt;局部变量的类型推断 var关键字&lt;/li&gt;
      &lt;li&gt;GC改进和内存管理 并行全垃圾回收器 G1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java11 2018年9月26日&lt;/li&gt;
  &lt;li&gt;参考 &lt;a href=&quot;https://mp.weixin.qq.com/s/6PgdGCulBm3Q5o75MJQVAA&quot;&gt;https://mp.weixin.qq.com/s/6PgdGCulBm3Q5o75MJQVAA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;service-mesh-sidecar&quot;&gt;Service Mesh Sidecar&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qH7j3eR6mPZrOaLnzSM_6A&quot;&gt;https://mp.weixin.qq.com/s/qH7j3eR6mPZrOaLnzSM_6A&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Kubernetes 和 Istio ?&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 08 Jul 2020 14:18:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/08/DotDot.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/08/DotDot.html</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>用户画像之标签数据开发</title>
        <description>&lt;h4 id=&quot;离线标签开发&quot;&gt;离线标签开发&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;统计类标签开发，是指统计用户相关数值、客户描述用户状态的标签，如用户的年龄、体重、累计购买金额、累计购买次数、近30日登陆次数
    &lt;ul&gt;
      &lt;li&gt;近30日购买行为（付款订单量ACTION_U_01_001、总付款金额ACTION_U_01_002、加入购物车次数ACTION_U_01_003）&lt;/li&gt;
      &lt;li&gt;最近来访：最近登录到今天的天数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;规则类标签开发，是指根据业务运营上的需要，在业务层面制定规则的标签。这类标签会带一些人为主观判断
    &lt;ul&gt;
      &lt;li&gt;数码达人，用户浏览的商品中有80%是3C产品，自动打标签&lt;/li&gt;
      &lt;li&gt;用户价值类RFM（重要/一般 价值/保持/发展/挽留）
        &lt;ul&gt;
          &lt;li&gt;R&amp;lt;=90为近，R&amp;gt;90为远&lt;/li&gt;
          &lt;li&gt;F&amp;lt;=3为低频，F&amp;gt;3为高频&lt;/li&gt;
          &lt;li&gt;M&amp;lt;=300为低额，M&amp;gt;300为高额&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;用户活跃程度（用户留存率的拐点一般就是用户的生命周期）
        &lt;ul&gt;
          &lt;li&gt;ACTION_U_05_003 高活跃&lt;/li&gt;
          &lt;li&gt;ACTION_U_05_002 中活跃&lt;/li&gt;
          &lt;li&gt;ACTION_U_05_001 低活跃&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;挖掘类标签开发，是指需要应用算法挖掘用户相关特征，比如预测性别、预测下单、预测流失、预测偏好
      - 文章分类&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;实时类标签开发&quot;&gt;实时类标签开发&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;新人弹窗、新人红包&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;用户特征库开发动态标签&quot;&gt;用户特征库开发（动态标签）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;用户特征库就是对用户每一次的不同行为（如浏览、收藏、搜索、购买等）及该行为对应的标签（或商品品类）进行
  详细的记录，以便从用户的行为特征中挖掘用户的偏好。&lt;/li&gt;
  &lt;li&gt;经常浏览或购买奶粉、尿不湿等，她可能是个妈妈。&lt;/li&gt;
  &lt;li&gt;查询最近7日浏览某商品详情页超过10次的用户&lt;/li&gt;
  &lt;li&gt;查询7日浏览、收藏、关注过”母婴”品类商品的用户&lt;/li&gt;
  &lt;li&gt;用户标签权重=行为类型权重 X 时间衰减 X 用户行为次数 X TF-IDF计算标签权重
&lt;img src=&quot;/img/up9.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;同现矩阵是指标签和标签之间的关联程度，这种关联程度有用户身上的标签所决定。（啤酒&amp;amp;尿不湿）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;人群计算&quot;&gt;人群计算&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过标签筛选人群
    &lt;ul&gt;
      &lt;li&gt;从MySQL中读出规则&lt;/li&gt;
      &lt;li&gt;请求es数据找出用户id&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;打通数据服务处&quot;&gt;打通数据服务处&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;把数据发送给相应的业务系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;用户画像的应用&quot;&gt;用户画像的应用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;经营分析
    &lt;ul&gt;
      &lt;li&gt;商品分析&lt;/li&gt;
      &lt;li&gt;用户分析&lt;/li&gt;
      &lt;li&gt;渠道分析&lt;/li&gt;
      &lt;li&gt;漏斗分析&lt;/li&gt;
      &lt;li&gt;客服话术&lt;/li&gt;
      &lt;li&gt;人群特征分析&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;精准营销
    &lt;ul&gt;
      &lt;li&gt;短信/邮件营销&lt;/li&gt;
      &lt;li&gt;效果分析&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;个性化推荐与服务&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;案例&quot;&gt;案例&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;风控反欺诈画像模型
&lt;img src=&quot;/img/up10.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;LTV生命周期运营
    &lt;ul&gt;
      &lt;li&gt;流失率的倒数用来表示预测的用户的生命周期，如果一个产品的流失率为10%，则产品对应的生命周期为10个月&lt;/li&gt;
      &lt;li&gt;单个用户毛利 = CLV customer life value - CAC customer aqurie cost - COC customer operation cost
&lt;img src=&quot;/img/up11.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;80%的注册用户在安装3日内完成注册，那就圈出来3日用户发红包优惠券等&lt;/li&gt;
  &lt;li&gt;76%的下单用户是在注册前9日完成的首次交易&lt;/li&gt;
  &lt;li&gt;注册首日消费满100，立即短信营销赠送红包，以更好地留存该高价值新用户&lt;/li&gt;
  &lt;li&gt;Session特征库
&lt;img src=&quot;/img/up12.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;在线医疗场景
&lt;img src=&quot;/img/up13.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/up14.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/up15.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/up16.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 07 Jul 2020 16:18:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/07/UserProfile3.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/07/UserProfile3.html</guid>
        
        <category>用户</category>
        
        
        <category>技术</category>
        
      </item>
    
  </channel>
</rss>
