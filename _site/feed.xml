<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>粉笔灰杂谈</title>
    <description>关于互联网、金融、商业的一些见解，顺便记录一下自己的生活感悟和读书笔记。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 12 Jan 2020 17:35:28 +0800</pubDate>
    <lastBuildDate>Sun, 12 Jan 2020 17:35:28 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>卧底经济学</title>
        <description>&lt;h4 id=&quot;三种市场失灵&quot;&gt;三种市场失灵&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;稀缺&lt;/li&gt;
  &lt;li&gt;信息缺失、信息不对等&lt;/li&gt;
  &lt;li&gt;外部效应&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 14 Dec 2019 16:10:02 +0800</pubDate>
        <link>http://localhost:4000/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2019/12/14/TheUndercoverEconomist.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2019/12/14/TheUndercoverEconomist.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title> Keepalived </title>
        <description>&lt;h3 id=&quot;keepalived是什么&quot;&gt;keepalived是什么&lt;/h3&gt;
&lt;p&gt;Keepalived软件起初是专为LVS负载均衡软件设计的，用来管理并监控LVS集群系统中各个服务节点的状态，后来又加入了可以实现高可用的VRRP功能。因此，Keepalived除了能够管理LVS软件外，还可以作为其他服务（例如：Nginx、Haproxy、MySQL等）的高可用解决方案软件。
Keepalived软件主要是通过VRRP协议实现高可用功能的。VRRP是Virtual Router RedundancyProtocol(虚拟路由器冗余协议）的缩写，VRRP出现的目的就是为了解决静态路由单点故障问题的，它能够保证当个别节点宕机时，整个网络可以不间断地运行。
所以，Keepalived 一方面具有配置管理LVS的功能，同时还具有对LVS下面节点进行健康检查的功能，另一方面也可实现系统网络服务的高可用功能。&lt;/p&gt;

&lt;h3 id=&quot;keepalived工作原理&quot;&gt;keepalived工作原理&lt;/h3&gt;
&lt;p&gt;keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。
虚拟路由冗余协议，可以认为是实现路由器高可用的协议，即将N台提供相同功能的路由器组成一个路由器组，这个组里面有一个master和多个backup，master上面有一个对外提供服务的vip（该路由器所在局域网内其他机器的默认路由为该vip），master会发组播，当backup收不到vrrp包时就认为master宕掉了，这时就需要根据VRRP的优先级来选举一个backup当master。这样的话就可以保证路由器的高可用了。
keepalived主要有三个模块，分别是core、check和vrrp。core模块为keepalived的核心，负责主进程的启动、维护以及全局配置文件的加载和解析。check负责健康检查，包括常见的各种检查方式。vrrp模块是来实现VRRP协议的。&lt;/p&gt;

&lt;h3 id=&quot;keepalived官网&quot;&gt;keepalived官网&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.keepalived.org&quot;&gt;http://www.keepalived.org&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;常见容错机制&quot;&gt;常见容错机制&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;failover：失效转移
Fail-Over的含义为“失效转移”，是一种备份操作模式，当主要组件异常时，其功能转移到备份组件。其要点在于有主有备，且主故障时备可启用，并设置为主。如Mysql的双Master模式，当正在使用的Master出现故障时，可以拿备Master做主使用&lt;/li&gt;
  &lt;li&gt;failfast：快速失败
从字面含义看就是“快速失败”，尽可能的发现系统中的错误，使系统能够按照事先设定好的错误的流程执行，对应的方式是“fault-tolerant（错误容忍）”。以JAVA集合（Collection）的快速失败为例，当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常（发现错误执行设定好的错误的流程），产生fail-fast事件。&lt;/li&gt;
  &lt;li&gt;failback：失效自动恢复
Fail-over之后的自动恢复，在簇网络系统（有两台或多台服务器互联的网络）中，由于要某台服务器进行维修，需要网络资源和服务暂时重定向到备用系统。在此之后将网络资源和服务器恢复为由原始主机提供的过程，称为自动恢复&lt;/li&gt;
  &lt;li&gt;failsafe：失效安全
Fail-Safe的含义为“失效安全”，即使在故障的情况下也不会造成伤害或者尽量减少伤害。维基百科上一个形象的例子是红绿灯的“冲突监测模块”当监测到错误或者冲突的信号时会将十字路口的红绿灯变为闪烁错误模式，而不是全部显示为绿灯。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/clsn/p/8052649.html&quot;&gt;https://www.cnblogs.com/clsn/p/8052649.html&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 08 Dec 2019 10:25:00 +0800</pubDate>
        <link>http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/12/08/Keepalived.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/12/08/Keepalived.html</guid>
        
        <category>linux</category>
        
        
        <category>互联网</category>
        
      </item>
    
      <item>
        <title>《原则》Ray Dalio</title>
        <description>&lt;h4 id=&quot;原则&quot;&gt;原则&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;发现问题、分析问题、正视问题、找出解决问题的路径、彻底解决问题。&lt;/li&gt;
  &lt;li&gt;一部分人不知道自己不知道处于不自知，另一部分人知道自己不知道处于自知但是不行动，只有及少数自知并且不容忍自己的问题并加以行动。&lt;/li&gt;
  &lt;li&gt;如果你的见解不比一般人搞，你就不会是领导者；如果你的见解比他们更高，那就不必担心你做得事情不受欢迎。&lt;/li&gt;
  &lt;li&gt;创意择优（可信度加权决策）。&lt;/li&gt;
  &lt;li&gt;想方设法达成共识。（基于逻辑、数据、坦诚的沟通）&lt;/li&gt;
  &lt;li&gt;多次确认，不如把同一个事情交给多人来做。（比如财务）&lt;/li&gt;
  &lt;li&gt;做有意义的工作，发展有意义的人际关系。&lt;/li&gt;
  &lt;li&gt;切勿混淆慷慨和公平。&lt;/li&gt;
  &lt;li&gt;价值观 &amp;gt; 能力 &amp;gt; 技能。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 01 Dec 2019 16:10:02 +0800</pubDate>
        <link>http://localhost:4000/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2019/12/01/Principles.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2019/12/01/Principles.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>为何我们不能获得真正的成功</title>
        <description>&lt;h4 id=&quot;原则&quot;&gt;原则&lt;/h4&gt;

</description>
        <pubDate>Sun, 01 Dec 2019 16:10:02 +0800</pubDate>
        <link>http://localhost:4000/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2019/12/01/HowToSuccess.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/2019/12/01/HowToSuccess.html</guid>
        
        
        <category>读书笔记</category>
        
      </item>
    
      <item>
        <title>女人的起源</title>
        <description>&lt;h4 id=&quot;开言&quot;&gt;开言&lt;/h4&gt;
&lt;p&gt;以这一篇做为这个版块的开始，之所以要增加【极致思考】这个版块，根本的原因是，我认为，大多数业务或者商业甚至物理定律是在有限的条件下有规律的发生（概率其实是规律的一种形式）。
那么，如何能在极短的时间内发现有限的规律、发现事物本质就难能可贵了。所以，我想把自己对一些事物的自认为合理的猜测记录下来，以锻炼自己的思考力。&lt;/p&gt;

&lt;h4 id=&quot;女人的起源&quot;&gt;女人的起源&lt;/h4&gt;
&lt;p&gt;今天开车回家，在路上，无意间摸到了我副驾驶的座椅，我内心一惊，拥有这辆车5年多，我第一次感受到它。由于是真皮座椅，那一刻我忽然觉得它似乎有了生命，它是我的伴侣，它是我的”小途途”。
这个奇妙的感觉，让我想到几年前，阅读了张小龙推荐的《女人的起源》一书，该书提出了一个有意思的问题：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;人为何没有了毛发？
 书中的解释是：某个时段，人类为了躲避陆地大型凶兽，很长一段时间是生活在水中或浅海区域，因为大型凶兽多数怕水。在水中时间久了，毛发就脱落了。但是，水中会有蛇类，所以人类至今都会天生怕蛇。&lt;/li&gt;
  &lt;li&gt;女性为何有凸起的乳房？&lt;/li&gt;
  &lt;li&gt;男性为何有凸起的乳房？&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sun, 01 Dec 2019 16:10:02 +0800</pubDate>
        <link>http://localhost:4000/%E6%9E%81%E8%87%B4%E6%80%9D%E8%80%83/2019/12/01/WhereAreWomenFrom.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%9E%81%E8%87%B4%E6%80%9D%E8%80%83/2019/12/01/WhereAreWomenFrom.html</guid>
        
        
        <category>极致思考</category>
        
      </item>
    
      <item>
        <title>DB-distributed-transacion</title>
        <description>&lt;h3 id=&quot;数据库本地事务简述&quot;&gt;数据库本地事务简述&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ACID原则
    &lt;ol&gt;
      &lt;li&gt;原子性(Atomicity)&lt;/li&gt;
      &lt;li&gt;一致性(Consistency)&lt;/li&gt;
      &lt;li&gt;隔离性(Isolation)&lt;/li&gt;
      &lt;li&gt;持久性(Durability)&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;以Mysql的InnoDB为例，事务的ACID是通过InnoDB日志和锁来保证
    &lt;ol&gt;
      &lt;li&gt;事务的隔离性是通过数据库锁的机制实现的&lt;/li&gt;
      &lt;li&gt;持久性通过Redo Log（重做日志）来实现，在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。&lt;/li&gt;
      &lt;li&gt;原子性和一致性通过 Undo Log 来实现。（数据数据操作前的数据备份 Undo Log）&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;本质都是通过一个本地事务资源管理器来统一协调调度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;分布式事务&quot;&gt;分布式事务&lt;/h3&gt;

&lt;h4 id=&quot;分布式事务产生的原因&quot;&gt;分布式事务产生的原因&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Service多节点部署（比如公司内的用户、账户等各种微服务)&lt;/li&gt;
  &lt;li&gt;Resource 多节点 (每个人的数据部署再不同节点的数据库里)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分布式系统之cap定理&quot;&gt;分布式系统之CAP定理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CAP 定理，又被叫作布鲁尔定理。对于设计分布式系统(不仅仅是分布式事务)的架构师来说，CAP 就是你的入门理论。&lt;/li&gt;
  &lt;li&gt;C (一致性)：对某个指定的客户端来说，读操作能返回一致的写操作。
对于数据分布在不同节点上的数据来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个***的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。&lt;/li&gt;
  &lt;li&gt;A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。
合理的时间指的是请求不能被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回 50，而不是返回 40。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;P (分区容错性)：当出现网络分区后，系统能够继续工作。打个比方，这里集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;熟悉 CAP 的人都知道，三者不能共有，如果感兴趣可以搜索 CAP 的证明，在分布式系统中，网络无法 100% 可靠，分区其实是一个必然现象。&lt;/p&gt;

    &lt;p&gt;如果我们选择了 CA 而放弃了 P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是 A 又不允许，所以分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。&lt;/p&gt;

    &lt;p&gt;对于 CP 来说，放弃可用性，追求一致性和分区容错性，我们的 ZooKeeper 其实就是追求的强一致。&lt;/p&gt;

    &lt;p&gt;对于 AP 来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的 BASE 也是根据 AP 来扩展。&lt;/p&gt;

    &lt;p&gt;顺便一提，CAP 理论中是忽略网络延迟，也就是当事务提交时，从节点 A 复制到节点 B 没有延迟，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。&lt;/p&gt;

    &lt;p&gt;同时 CAP 中选择两个，比如你选择了 CP，并不是叫你放弃 A。因为 P 出现的概率实在是太小了，大部分的时间你仍然需要保证 CA。&lt;/p&gt;

    &lt;p&gt;就算分区出现了你也要为后来的 A 做准备，比如通过一些日志的手段，是其他机器回复至可用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分布式系统之base定理&quot;&gt;分布式系统之BASE定理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写，是对 CAP 中 AP 的一个扩展。&lt;/li&gt;
  &lt;li&gt;基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。&lt;/li&gt;
  &lt;li&gt;软状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致。&lt;/li&gt;
  &lt;li&gt;最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。&lt;/li&gt;
  &lt;li&gt;BASE 解决了 CAP 中理论没有网络延迟，在 BASE 中用软状态和最终一致，保证了延迟后的一致性。&lt;/li&gt;
  &lt;li&gt;BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;常用分布式事务框架&quot;&gt;常用分布式事务框架&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;基于XA的 2PC、3PC
   本质相当于本地事务的加强版，强一致性，引入中间事务协调者，依赖数据库，属于数据库资源层方案&lt;/li&gt;
  &lt;li&gt;Saga
  引入补偿机制（最终一致性）&lt;/li&gt;
  &lt;li&gt;TCC
  Try、Commit、Cancel&lt;/li&gt;
  &lt;li&gt;本地消息表&lt;/li&gt;
  &lt;li&gt;RocketMQ(阿里开源)&lt;/li&gt;
  &lt;li&gt;Seata&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;参考资料&quot;&gt;参考资料&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.51cto.com/art/201808/581174.htm&quot;&gt;分布式事务概述&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/917cb4bdaa03&quot;&gt;由Seata看分布式事务取舍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1401904&quot;&gt;常用分布式事务框架&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/75843832&quot;&gt;蚂蚁金服分布式事务实战&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.infoq.cn/article/8bu33kuSyJ6P-wAAoELT&quot;&gt;分布式事务选型的取舍infoq&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.tianshouzhi.com/api/tutorials/distributed_transaction/383&quot;&gt;分布式事务&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jdon.com/48829&quot;&gt;Spring的分布式事务实现(JTA+XA/2PC)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://seata.io/zh-cn/&quot;&gt;Seata官网&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/firstdream/p/6585923.html&quot;&gt;FLP不可能原理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sohu.com/a/290897501_684445&quot;&gt;分布式事务：深入理解什么是2PC、3PC及TCC协议 &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5dd0ff1af265da0c075d0af7&quot;&gt;如何基于RocketMQ的事务消息特性实现分布式系统的最终一致性？&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/07/cap.html&quot;&gt;CAP定理&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/m0_38110132/article/details/76994165&quot;&gt;分布式事务的解决方案CSDN&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bbsmax.com/A/obzb24Y0zE/&quot;&gt;Atomikos和GTS-Fescar和TCC-Transaction和TX-LCN分布式事物的比较&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_27384769/category_7453176_1.html&quot;&gt;分布式CSDN博客&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.itcodemonkey.com/article/13548.html&quot;&gt;基于RocketMQ的最终一致性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 12 Nov 2019 10:25:00 +0800</pubDate>
        <link>http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/11/12/DB-distributed-transacion.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/11/12/DB-distributed-transacion.html</guid>
        
        <category>mysql DB</category>
        
        
        <category>互联网</category>
        
      </item>
    
      <item>
        <title>DB Shard</title>
        <description>&lt;h4 id=&quot;主键避重问题&quot;&gt;主键避重问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ID生成器
    &lt;ul&gt;
      &lt;li&gt;Twitter Snowflake&lt;/li&gt;
      &lt;li&gt;美团 LeftUid&lt;/li&gt;
      &lt;li&gt;百度 Uid-genarator&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;散表规则
    &lt;ul&gt;
      &lt;li&gt;按照ID范围，要求ID自增&lt;/li&gt;
      &lt;li&gt;简单Hash(取模)&lt;/li&gt;
      &lt;li&gt;Hash一致性算法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;分页查询问题&quot;&gt;分页查询问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;分表查，应用程序合并&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;关联查询问题&quot;&gt;关联查询问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;避免join操作，改造为多次查询，由应用程序合并&lt;/li&gt;
  &lt;li&gt;使用现成的中间件&lt;/li&gt;
  &lt;li&gt;实际业务中可能会结合Redis/Es等解决方案&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;公共表问题&quot;&gt;公共表问题&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;公共表多库冗余，多库同步&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;事务一致性&quot;&gt;事务一致性&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tianshouzhi.com/api/tutorials/distributed_transaction/383&quot;&gt;分布式事务&lt;/a&gt;
&lt;a href=&quot;https://www.jdon.com/48829&quot;&gt;Spring的分布式事务实现(JTA+XA/2PC)&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;jtaxa&quot;&gt;JTA*XA&lt;/h5&gt;

&lt;h4 id=&quot;比较常见的中间件cobartddlatlassharding-jdbcmycat&quot;&gt;比较常见的中间件cobar、TDDL、atlas、sharding-jdbc、mycat&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;cobar：阿里b2b团队开发和开源的，属于proxy层方案。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库join和分页等操作。&lt;/li&gt;
  &lt;li&gt;TDDL：淘宝团队开发的，属于client层方案。不支持join、多表查询等语法，就是基本的crud语法是ok，但是支持读写分离。目前使用的也不多，因为还依赖淘宝的diamond配置管理系统。&lt;/li&gt;
  &lt;li&gt;atlas：360开源的，属于proxy层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在5年前了。所以，现在用的公司基本也很少了。&lt;/li&gt;
  &lt;li&gt;sharding-jdbc：当当开源的，属于client层方案。确实之前用的还比较多一些，因为SQL语法支持也比较多，没有太多限制，而且目前推出到了2.0版本，支持分库分表、读写分离、分布式id生成、柔性事务（最大努力送达型事务、TCC事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从2017年一直到现在，是不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也可以选择的方案。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;mycat：基于cobar改造的，属于proxy层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于sharding jdbc来说，年轻一些，经历的锤炼少一些。&lt;/p&gt;

    &lt;p&gt;所以综上所述，现在其实建议考量的，就是sharding-jdbc和mycat，这两个都可以去考虑使用。
  sharding-jdbc这种client层方案的优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要耦合sharding-jdbc的依赖；
  mycat这种proxy层方案的缺点在于需要部署，自己及运维一套中间件，运维成本高，但是好处在于对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了。
  通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用sharding-jdbc，client层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；
  但是中大型公司最好还是选用mycat这类proxy层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护mycat，然后大量项目直接透明使用即可。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;主从同步&quot;&gt;主从同步&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;半同步复制，semi-sync复制，指的就是主库写入binlog日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。&lt;/li&gt;
  &lt;li&gt;并行复制，指的是从库开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;其他&quot;&gt;其他&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;amp;mid=2651960212&amp;amp;idx=1&amp;amp;sn=ab4c52ab0309f7380f7e0207fa357128&amp;amp;pass_ticket=G8v3RrpK9Is7NJZH0fOShUfY8lp5oz9un8K5L24LeGGVtiBTXkBMc9UKkTMdQeDS&quot;&gt;58用户系统分库分表实战&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 12 Nov 2019 10:25:00 +0800</pubDate>
        <link>http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/11/12/DB-Shard.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/11/12/DB-Shard.html</guid>
        
        <category>mysql DB</category>
        
        <category>分库/分表</category>
        
        
        <category>互联网</category>
        
      </item>
    
      <item>
        <title>DB Mysql</title>
        <description>&lt;h4 id=&quot;索引原理btree&quot;&gt;索引原理(B+Tree)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Tree -&amp;gt; BelanceTree -&amp;gt; B+Tree&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://www.sohu.com/a/280609547_818692&quot;&gt;http://www.sohu.com/a/280609547_818692&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/0371c9569736&quot;&gt;https://www.jianshu.com/p/0371c9569736&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tiancai/p/9024351.html&quot;&gt;https://www.cnblogs.com/tiancai/p/9024351.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;查询优化&quot;&gt;查询优化&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/efaa9005a598&quot;&gt;https://www.jianshu.com/p/efaa9005a598&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jb51.net/article/136701.htm&quot;&gt;https://www.jb51.net/article/136701.htm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/houss/p/10598901.html&quot;&gt;https://www.cnblogs.com/houss/p/10598901.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;常用指标&quot;&gt;常用指标&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;QPS   (2w/s与机器配置及数据量有关)&lt;/li&gt;
  &lt;li&gt;TPS   (1w/s)&lt;/li&gt;
  &lt;li&gt;并发数&lt;/li&gt;
  &lt;li&gt;连接数&lt;/li&gt;
  &lt;li&gt;缓存命中率&lt;/li&gt;
  &lt;li&gt;慢查询
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;slow_query_log=on
slow_query_log_file=存放目录
long_query_time=0.1秒
log_queries_not_using_indexes=on
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;主从延迟
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;show slave status;
Seconds_Behind_Master
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;死锁
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set global innodb_print_all_deadlocks=on; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mysql-wal技术-write-ahead-logging&quot;&gt;Mysql WAL技术 Write-Ahead Logging&lt;/h4&gt;
&lt;p&gt;在计算机领域，WAL（Write-ahead logging，预写式日志）是数据库系统提供原子性和持久化的一系列技术。
在使用WAL的系统中，所有的修改都先被写入到日志中，然后再被应用到系统状态中。通常包含redo和undo两部分信息。
为什么需要使用WAL，然后包含redo和undo信息呢？举个例子，如果一个系统直接将变更应用到系统状态中，那么在机器掉电重启之后系统需要知道操作是成功了，
还是只有部分成功或者是失败了（为了恢复状态）。如果使用了WAL，那么在重启之后系统可以通过比较日志和系统状态来决定是继续完成操作还是撤销操作。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hzmark/p/wal.html&quot;&gt;https://www.cnblogs.com/hzmark/p/wal.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;mysql主从同步&quot;&gt;Mysql主从同步&lt;/h4&gt;

&lt;h4 id=&quot;innodb-myisam&quot;&gt;InnoDB MyISAM&lt;/h4&gt;

&lt;h4 id=&quot;mysql--keepalived实现双高可用&quot;&gt;mysql + keepalived实现双高可用&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://database.51cto.com/art/201910/604128.htm&quot;&gt;数据库规范&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Nov 2019 10:25:00 +0800</pubDate>
        <link>http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/11/12/DB-Mysql.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/11/12/DB-Mysql.html</guid>
        
        <category>mysql DB</category>
        
        
        <category>互联网</category>
        
      </item>
    
      <item>
        <title>一致性算法</title>
        <description>&lt;p&gt;强一致性的2PC、3PC、Paxos、Raft、Zab；&lt;/p&gt;

&lt;p&gt;https://www.cnblogs.com/think90/p/11443428.html&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Nov 2019 10:25:00 +0800</pubDate>
        <link>http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/11/12/ConsistencyAlgorithm.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/11/12/ConsistencyAlgorithm.html</guid>
        
        <category>算法</category>
        
        
        <category>互联网</category>
        
      </item>
    
      <item>
        <title>NoSQL-NewSQL</title>
        <description>&lt;h4 id=&quot;redis&quot;&gt;Redis&lt;/h4&gt;

&lt;h4 id=&quot;mongo&quot;&gt;Mongo&lt;/h4&gt;

&lt;h4 id=&quot;cassandra&quot;&gt;Cassandra&lt;/h4&gt;

&lt;h4 id=&quot;leveldbrocksdb&quot;&gt;Leveldb、Rocksdb、&lt;/h4&gt;
&lt;h4 id=&quot;tidbtair&quot;&gt;TiDB、Tair&lt;/h4&gt;
</description>
        <pubDate>Tue, 12 Nov 2019 10:25:00 +0800</pubDate>
        <link>http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/11/12/NoSQL-NewSQL.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E4%BA%92%E8%81%94%E7%BD%91/2019/11/12/NoSQL-NewSQL.html</guid>
        
        <category>newSQL NoSQL</category>
        
        
        <category>互联网</category>
        
      </item>
    
  </channel>
</rss>
