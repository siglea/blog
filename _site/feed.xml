<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>粉笔灰杂谈</title>
    <description>关于产品、技术、商业的一些见解，顺便记录一下自己的生活感悟和读书笔记。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 18 Jul 2020 11:28:01 +0800</pubDate>
    <lastBuildDate>Sat, 18 Jul 2020 11:28:01 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Jvm 参数一览</title>
        <description>&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;-Xms2g&lt;/span&gt;：初始化推大小为 2g；
&lt;span class=&quot;nt&quot;&gt;-Xmx2g&lt;/span&gt;：堆最大内存为 2g；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:NewRatio&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;4：设置年轻的和老年代的内存比例为 1:4；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:SurvivorRatio&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;8：设置新生代 Eden 和 Survivor 比例为 8:2；
–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:+PrintGC：开启打印 gc 信息；
&lt;span class=&quot;nt&quot;&gt;-XX&lt;/span&gt;:+PrintGCDetails：打印 gc 详细信息。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/img/jp1.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp2.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp3.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp4.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp5.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp6.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/jp7.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Jul 2020 10:10:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/18/JVM-Param.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/18/JVM-Param.html</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Jvm Note</title>
        <description>&lt;h4 id=&quot;class文件&quot;&gt;Class文件&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/class.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Magic Number：4字节，0xCAFEBABE&lt;/li&gt;
  &lt;li&gt;minor_version/major_version：JDK版本号，向下兼容&lt;/li&gt;
  &lt;li&gt;constant_pool_count/constant_pool：常量池（javap -verbose可以输出.class内容)&lt;/li&gt;
  &lt;li&gt;access_flags：表示class是类或者接口、是否public、是否abstract、是否final&lt;/li&gt;
  &lt;li&gt;this_class/super_class/interfaces_count/interfaces：&lt;/li&gt;
  &lt;li&gt;fields/fields_count，methods/methods_count&lt;/li&gt;
  &lt;li&gt;attributes/attributes_count：属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；如果出现在fileds的某一项里，那么它就是对该字段额外信息的描述；如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。
    &lt;ol&gt;
      &lt;li&gt;Code：使用在方法表里，Java代码编译成的字节码指令。
        &lt;ul&gt;
          &lt;li&gt;可以查看虚拟机字节码指令表 &lt;a href=&quot;https://www.cnblogs.com/magexi/p/11822910.html&quot;&gt;https://www.cnblogs.com/magexi/p/11822910.html&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;虚拟机规范一个方法不允许超过 65535条字节码指令&lt;/li&gt;
          &lt;li&gt;如果把一个Java程序中的信息分为代码(Code，方法体里面的Java代码)和元数据(Metadata，包括类、字段、方法定义及其他信息)，
  那么在整个Class文件中，Code属性用于描述代码，所有的其他属性用于描述元数据。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Exception&lt;/li&gt;
      &lt;li&gt;LineNumberTable：Java源码的行号与字节码指令的对应关系&lt;/li&gt;
      &lt;li&gt;LocalVariableTable属性：用于描述栈帧中局部变量表中的变量与Java源代码中定义的变量之间的关系。&lt;/li&gt;
      &lt;li&gt;SourceFile：源代码名字&lt;/li&gt;
      &lt;li&gt;ConstantValue属性：通知虚拟机自动为静态变量赋值&lt;/li&gt;
      &lt;li&gt;InnerClasses属性&lt;/li&gt;
      &lt;li&gt;Synthetic属性：代表此字段或方法并不是由Java源代码直接产生的，而是由编译器自行添加的（如:init)&lt;/li&gt;
      &lt;li&gt;StackMapTable属性：会在虚拟机类加载的字节码验证阶段被新类型检查验证器使用。&lt;/li&gt;
      &lt;li&gt;Signature：泛型&lt;/li&gt;
      &lt;li&gt;BootstrapMethods属性：用于保存invokeDynamic指令引用的引导方法限定符。&lt;/li&gt;
      &lt;li&gt;RuntimeVisibleAnnotations：为动态注解提供支持&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;案例看下
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TestClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;inc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(){&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;/img/class_code.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/class_javap.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;字节码指令集200多个不超过256&quot;&gt;字节码指令集（200多个，不超过256）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;加载和存储指令：iload、istore、bipush等&lt;/li&gt;
  &lt;li&gt;运算指令：iadd、isub、imul、idiv、ior、iand等&lt;/li&gt;
  &lt;li&gt;类型转换指令：i2b、i2c、i2s等&lt;/li&gt;
  &lt;li&gt;对象创建与访问指令：new、newarray、putfield、getfield、arraylength等&lt;/li&gt;
  &lt;li&gt;操作栈管理指令：pop、dup、 swap等&lt;/li&gt;
  &lt;li&gt;控制转移指令：ifeq、iflt、ifle等&lt;/li&gt;
  &lt;li&gt;方法调用和返回指令：
    &lt;ul&gt;
      &lt;li&gt;invokevirtual：抽象/虚拟方法&lt;/li&gt;
      &lt;li&gt;invokeinterface：接口方法&lt;/li&gt;
      &lt;li&gt;invokespecial：init、私有、父类方法&lt;/li&gt;
      &lt;li&gt;invokestatic：静态方法&lt;/li&gt;
      &lt;li&gt;invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，
  前4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑由用户所设定的引导方法决定的。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异常处理指令：throw（catch用异常表来实现）&lt;/li&gt;
  &lt;li&gt;同步指令：monitorenter 、monitorexit&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;类加载机制&quot;&gt;类加载机制&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;加载
    &lt;ul&gt;
      &lt;li&gt;加载时机：new、invocke static；反射调用；子类依赖的父类；main类；jdk1.7后的动态语言支持REF_getStatic&lt;/li&gt;
      &lt;li&gt;除了上述5种场景，其他的方式都是被动引用（如：访问类常量、创建对象数组等），不会触发初始化。&lt;/li&gt;
      &lt;li&gt;加载渠道：zip包类(Jar/Ear/War)；网络类(Applet)；动态代理生成；JSP等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;验证
    &lt;ul&gt;
      &lt;li&gt;文件格式验证：版本号、类型、常量类型等&lt;/li&gt;
      &lt;li&gt;元数据验证：类继承实现是否正确完整等Java语言规范&lt;/li&gt;
      &lt;li&gt;字节码验证：字节码语义验证、安全验证、类型推断验证（StackMapTable优化了类型推断）&lt;/li&gt;
      &lt;li&gt;符号引用验证：为确保解析动作能正常运行，类名、访问权限等核实&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;准备
    &lt;ul&gt;
      &lt;li&gt;为类变量分配内存，并设置初始化”零值”（final直接赋值）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;解析
    &lt;ul&gt;
      &lt;li&gt;把符号引用替换为直接引用&lt;/li&gt;
      &lt;li&gt;正式解析类、字段、方法，解析失败会出现IllegalAccessError、NoSuchFieldError、NoSuchMethodError&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化
    &lt;ul&gt;
      &lt;li&gt;clinit()方法执行、虚拟机保证该方法现成安全&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;破坏双亲委派&quot;&gt;破坏双亲委派&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;JDK1.2通过覆盖loadClass实现自定义加载器，之后应是把自己的加载逻辑放到findClass中&lt;/li&gt;
  &lt;li&gt;SPI机制通过 ThreadContextClassLoader的方式，父加载器可以实现委派下级进行加载。比如BootstrapClassLoader
  需要使用到了classpath下的class，但是自己只能加载固定目录下，就需要委派AppClassLoader来替它加载&lt;/li&gt;
  &lt;li&gt;OSGI动态热部署等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;虚拟机字节码执行引擎&quot;&gt;虚拟机字节码执行引擎&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;在不同的虚拟机实现里会有解释执行（解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种方式。&lt;/li&gt;
  &lt;li&gt;运行时栈帧结构
    &lt;ul&gt;
      &lt;li&gt;每个线程包含多个栈帧&lt;/li&gt;
      &lt;li&gt;局部变量表
        &lt;ul&gt;
          &lt;li&gt;局部变量表的容量以变量槽(Variable Slot)为最小单位(32位/64位)&lt;/li&gt;
          &lt;li&gt;第0位，表示this&lt;/li&gt;
          &lt;li&gt;Slot可以被复用一变节省空间，比如把不用的对象=null，就可以把该对象占用的空间让出来，但是=null有可能被编译器优化擦出掉或者jvm会优化这种操作&lt;/li&gt;
          &lt;li&gt;局部变量需要明确初始化，不会给初始化”零值”&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;操作栈&lt;/li&gt;
      &lt;li&gt;动态连接
        &lt;ul&gt;
          &lt;li&gt;Class文件中的符号引用在运行期间转换为直接引用，就是指动态连接&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;返回地址
        &lt;ul&gt;
          &lt;li&gt;方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：
  恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，
  调整PC计时器的值以指向方法调用指令后面的一条指令等。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;方法调用
    &lt;ul&gt;
      &lt;li&gt;方法调用阶段唯一的任务就是确定被调用的方法的版本，暂时还不涉及方法内部的具体运行过程。
在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面已经讲过，Class文件的编译过程中
不包含传统编译中的连接步骤，一起方法调用在Class文件里面存储的都只是符号引用，而不是方法
在实际运行时内存布局中的入口地址（直接引用）。这个特性给Java带来了更强大的动态扩展能力，
但也使得Java方法调用过程变得相对复杂起来，需要再类加载期间，甚至到运行期间才能确定目标方法的直接引用。&lt;/li&gt;
      &lt;li&gt;编译器可知，运行期不可变&lt;/li&gt;
      &lt;li&gt;2大类方法
        &lt;ol&gt;
          &lt;li&gt;非虚方法：通过invokestatic/invokespecial调用的诸如静态、私有、构造、父类方法这4类，在解析阶段就确定了&lt;/li&gt;
          &lt;li&gt;虚方法：抽象，多态。
            &lt;ul&gt;
              &lt;li&gt;静态分派：方法重载&lt;/li&gt;
              &lt;li&gt;动态分派：方法重写
                &lt;ul&gt;
                  &lt;li&gt;动态单分派&lt;/li&gt;
                  &lt;li&gt;通过方法表来优化查找性能&lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;动态性
    &lt;ul&gt;
      &lt;li&gt;何为动态语言？变量无类型而变量值才有类型。&lt;/li&gt;
      &lt;li&gt;Java动态性实现从JDK1.7开始 &lt;a href=&quot;https://blog.csdn.net/zero__007/article/details/107304054&quot;&gt;https://blog.csdn.net/zero__007/article/details/107304054&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;java.lang.invoke包MethodHandler&lt;/li&gt;
          &lt;li&gt;invokedynamic字节码指令&lt;/li&gt;
          &lt;li&gt;Reflection与MethodHandle机制都是在模拟方法调用，Reflection是在Java代码层次，而MethodHandl是在模拟字节码层次&lt;/li&gt;
          &lt;li&gt;Reflection是重量级的能映射整个方法相关的信息，MethoudHandle仅仅是方法调用&lt;/li&gt;
          &lt;li&gt;Reflection是为Java语言服务的，MethodHandle是为所有Java虚拟机之上的语言服务&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 通过MethodType的静态工厂方法构造 MethodType&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;MethodType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodType&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MethodType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;methodType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 获取方法句柄&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;MethodHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodHandle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MethodHandles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findVirtual&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;say&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;methodType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;methodHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zero&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// invoke和invokeExact方法, invokeExact方法与直接调用底层方法是一样的&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;methodHandle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invokeExact&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;zero&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;useConstantCallSite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;MethodHandles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;Lookup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lookup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MethodHandles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;MethodType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MethodType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;methodType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;MethodHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lookup&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findVirtual&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;substring&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        
        &lt;span class=&quot;nc&quot;&gt;ConstantCallSite&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callSite&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ConstantCallSite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mh&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;MethodHandle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invoker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;callSite&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;dynamicInvoker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  
        &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invoker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;  
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;执行引擎
    &lt;ul&gt;
      &lt;li&gt;编译执行/解释执行&lt;/li&gt;
      &lt;li&gt;JIT编译(just-in-time compilation)狭义来说是当某段代码即将第一次被执行时进行编译,因而叫“即时编译”&lt;/li&gt;
      &lt;li&gt;基于栈的指令集 与 基于寄存器的指令集 （Android Dalvik VM)
  &lt;img src=&quot;/img/exec.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;类加载及执行子系统案例&quot;&gt;类加载及执行子系统案例&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;tomcat
    &lt;ul&gt;
      &lt;li&gt;放置在 /common 目录中：类库可被 Tomcat 和所有的 Web 应用程序共同使用。CommonClassLoader&lt;/li&gt;
      &lt;li&gt;放置在 /server 目录中：类库可被 Tomcat 使用，对所有的 Web 应用程序都不可见。CatalinaClassLoader&lt;/li&gt;
      &lt;li&gt;放置在 /shared 目录中：类库可被所有的 Web 应用程序共同使用，但对 Tomcat 自己不可见。SharedClassLoader&lt;/li&gt;
      &lt;li&gt;放置在 /WebApp/WEB-INF 目录中：类库仅仅可以被此 Web 应用程序使用，对 Tomcat 和其他 Web 应用程序都不可见 WebAppClassLoader&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OSGi：灵活的类加载器架构
    &lt;ul&gt;
      &lt;li&gt;OSGi（Open Service Gateway Initiative） 是 OSGi 联盟（OSGi Alliance）制定的一个基于 Java 语言的动态模块化规范&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;字节码生成技术与动态代理的实现
    &lt;ul&gt;
      &lt;li&gt;javac、Javassit、CGlib、ASM&lt;/li&gt;
      &lt;li&gt;JDK Proxy，也是生成字节码，用完删除了而已
        &lt;ul&gt;
          &lt;li&gt;Proxy.newProxyInstance()&lt;/li&gt;
          &lt;li&gt;sun.misc.ProxyGenerator.generateProxyClass()&lt;/li&gt;
          &lt;li&gt;System.getProperties().put(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”);&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Retrotranslator 的作用是将 JDK 1.5 编译出来的 Class 文件转变为可以在 JDK 1.4 或 1.3 上部署的版本&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/u013678930/article/details/51995251&quot;&gt;https://blog.csdn.net/u013678930/article/details/51995251&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;早期编译期优化&quot;&gt;早期（编译期）优化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;编译器类型
    &lt;ul&gt;
      &lt;li&gt;前端编译器：把java变为class，如Sun的Javac、Eclipse JDT中的增量式编译器(ECJ)&lt;/li&gt;
      &lt;li&gt;JIT编译器：运行时把 class字节码转变成机器码，如HotSpot VM的 C1、C2编译器&lt;/li&gt;
      &lt;li&gt;AOT编译器：直接把java编译成本地机器码，如GNU Compiler for the Java (GCJ)、Excelsior JET&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编译过程
    &lt;ul&gt;
      &lt;li&gt;解析与填充符号表过程&lt;/li&gt;
      &lt;li&gt;插入式注解处理器的注解处理过程&lt;/li&gt;
      &lt;li&gt;分析与字节码生成过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;泛型与类型擦除(Signature、LocalVariableTypeTable从JDK1.6之后用于解决此特性带来的问题)&lt;/li&gt;
  &lt;li&gt;自动装箱、拆箱与遍历循环&lt;/li&gt;
  &lt;li&gt;Annotation Processor是javac的一个工具，它用来在编译时扫描和处理注解，通过Annotation Processor可以获取到注解和被注解类的相关信息，
  然后根据注解自动生成Java代码，省去了手动编写，提高了编码效率。(javac -processor)
    &lt;ul&gt;
      &lt;li&gt;Hibernate Validator Annotation Processor&lt;/li&gt;
      &lt;li&gt;Project Lombok&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;晚期运行期优化&quot;&gt;晚期运行期优化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;主流的虚拟机采用解释器与编译器并存的架构 (java -version  mixed mode)，为了再启动响应速度和运行效率之间达到最佳平衡，
  hotSpot虚拟机还会逐渐启用分层编译（Tiered Compilation）的策略。
    &lt;ul&gt;
      &lt;li&gt;解释器，一遍运行一遍把字节码解释为本地机器码 [0层]&lt;/li&gt;
      &lt;li&gt;编译器，把字节码编译成为本地机器码并缓存起来
        &lt;ul&gt;
          &lt;li&gt;C1（Client Compiler），更高的编译速度   [1层]&lt;/li&gt;
          &lt;li&gt;C2 (Server Compiler)，更好的编译质量   [2层]&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;热点代码：在运行过程中会被即时编译器编译的代码 也就是HotSpot的名称来源
    &lt;ul&gt;
      &lt;li&gt;被多次调用的方法：由方法调用触发编译，也是标准的JIT编译方式
        &lt;ul&gt;
          &lt;li&gt;Invocation Counter，超过阈值触发JIT编译&lt;/li&gt;
          &lt;li&gt;C1默认：1500次 C2：10000次&lt;/li&gt;
          &lt;li&gt;-XX：CompileThreshold&lt;/li&gt;
          &lt;li&gt;可以设置衰减周期：CounterHalfLifeTime&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;被对此执行的循环体：由循环体，关联出所在的方法，发生在方法执行过程中，因此被称为栈上替换OSR (On Stack Replacement)
        &lt;ul&gt;
          &lt;li&gt;Back Edge Counter，字节码遇到控制流向后跳转的指令后统计次数，为了触发OSR&lt;/li&gt;
          &lt;li&gt;CompileThreshold * OnStackReplacePercentage / 100&lt;/li&gt;
          &lt;li&gt;C1: 13995,C2：10700&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;热点探测的判断方法
    &lt;ul&gt;
      &lt;li&gt;基于采样（Sample Based Hot Spot Detection)，周期性检查各个线程的栈顶。缺点是受线程阻塞等因素影响会不准&lt;/li&gt;
      &lt;li&gt;基于计数器（Counter Based Hot Spot Detection)，统计方法的执行次数。缺点是无法知道调用关系。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;编译过程
    &lt;ul&gt;
      &lt;li&gt;C1
        &lt;ul&gt;
          &lt;li&gt;字节码 -&amp;gt;方法内联、常量传播 -&amp;gt; HIR High level Intermediate Representation (SSA Static Single Assignment形式)&lt;/li&gt;
          &lt;li&gt;HIR -&amp;gt; 空置检查消除、范围检查消除 -&amp;gt; LLR Low-Level Intermediate Representation&lt;/li&gt;
          &lt;li&gt;LIR -&amp;gt; 寄存器分配、窥孔优化 -&amp;gt; 本地机器码&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;C2,相对于C1更加缓慢，提高代码质量，进一步减少本地代码的执行时间
        &lt;ul&gt;
          &lt;li&gt;无用代码消除 Dead Code Elimination&lt;/li&gt;
          &lt;li&gt;循环展开 Loop Unrolling&lt;/li&gt;
          &lt;li&gt;循环表达式外提 Loop Expression Hoisting&lt;/li&gt;
          &lt;li&gt;消除公共子表达式 Common Subexpression Elimination&lt;/li&gt;
          &lt;li&gt;常量传播 Constant Propagation&lt;/li&gt;
          &lt;li&gt;基本块重排序 Basic Block Reordering&lt;/li&gt;
          &lt;li&gt;范围检查消除 Range Check Elimiation&lt;/li&gt;
          &lt;li&gt;数组边界检查消除 Array Bounds Checking Elimination：JAVA数组的方位不是通过裸指针，所以每次都需要检查是否越界
  可以通过数据流分析推断出取值范围，就可以把检查消除&lt;/li&gt;
          &lt;li&gt;逃逸分析 Escape Analysis
            &lt;ul&gt;
              &lt;li&gt;当一个对象在方法中被定义后，它可能被外部方法所引用&lt;/li&gt;
              &lt;li&gt;逃逸分析带来的好处：栈上分配，同步消除、标量替换&lt;/li&gt;
              &lt;li&gt;缺点：不确定逃逸对象的比例，反而会浪费性能&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/w372426096/article/details/80333657&quot;&gt;https://blog.csdn.net/w372426096/article/details/80333657&lt;/a&gt;&lt;/li&gt;
              &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/hollis_chuang/article/details/80922794&quot;&gt;https://blog.csdn.net/hollis_chuang/article/details/80922794&lt;/a&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java 与 C++ 编译器对比
    &lt;ul&gt;
      &lt;li&gt;Java编译器占用用户时间&lt;/li&gt;
      &lt;li&gt;Java语言是动态的类型安全语言，意味值需要频繁检测空指针、数字越界、类型转换，总体耗时&lt;/li&gt;
      &lt;li&gt;运行时多态选择频率远远大于C/C++&lt;/li&gt;
      &lt;li&gt;Java对象内存分配在只能再堆上，造成局部对象不能随之栈消失被回收&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;线程与内存模型&quot;&gt;线程与内存模型&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;缓存一致性 Cache Coherence，解决CPU高速缓存与主内存数据一致性。如MSI、FireFly等协议&lt;/li&gt;
  &lt;li&gt;指令重排 Instruction Reorder，与处理器乱序执行OutOfOrder Execution类似，使得处理器内部的运算单元尽可能被充分利用&lt;/li&gt;
  &lt;li&gt;Java内存模型：所有变量储存在主内存Main Memory、每条线程还有自己的工作内存Working Memory
    &lt;ul&gt;
      &lt;li&gt;read/load : 从主内存读取到工作内存&lt;/li&gt;
      &lt;li&gt;store/write ：从工作内存写入主内存&lt;/li&gt;
      &lt;li&gt;use：从工作内存传递给执行引擎&lt;/li&gt;
      &lt;li&gt;assign：工作引擎赋值给工作内存&lt;/li&gt;
      &lt;li&gt;lock/unlock：在主内存锁定或解锁变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;volatile：
    &lt;ul&gt;
      &lt;li&gt;保证可见性：本质上volatile变量也可以存在不一致的情况，但由于每次使用前都要先刷新，执行引擎看不到不一致的情况&lt;/li&gt;
      &lt;li&gt;禁止指令重排：通过插入内存屏障指令来实现，因此写操作会比普通变量慢&lt;/li&gt;
      &lt;li&gt;非原子性的i++之类的操作仍然会出现问题&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;long/double这种64位的数据，几乎所有虚拟机厂商都实现读写原子性，所以可以不需要声明为volatile&lt;/li&gt;
  &lt;li&gt;先行发生原则 happen before，只要遵循以下几个原则就是有顺序保障的，否则可能被重排。也就是说我们考虑并发问题
  不要看先后发生的时间顺序，而一切以先行发生原则为准
    &lt;ul&gt;
      &lt;li&gt;程序次序规则 Program Order Rule&lt;/li&gt;
      &lt;li&gt;管程锁定规则 Monitor Lock Rule&lt;/li&gt;
      &lt;li&gt;volatile变量规则 Volatile Variable Rule&lt;/li&gt;
      &lt;li&gt;线程启动、终止、中断规则&lt;/li&gt;
      &lt;li&gt;对象终结规则 init 先于 finalize&lt;/li&gt;
      &lt;li&gt;传递性 Transitivity&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java线程实现
    &lt;ul&gt;
      &lt;li&gt;JDK1.2之前，是用用户线程&lt;/li&gt;
      &lt;li&gt;JDK1.2及之后，是用操作系统的线程来实现&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Java线程调度
    &lt;ul&gt;
      &lt;li&gt;协同式线程调度 Cooperative Thread-Scheduling，线程执行时间由自己控制，会造成各种阻塞不让出资源&lt;/li&gt;
      &lt;li&gt;抢占式线程调度 Preemptive Threads Scheduling，由操作系统分配执行时间，Java使用该方式，可以指定线程优先级但是不一定起作用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;线程状态
    &lt;ul&gt;
      &lt;li&gt;新建 New：尚未启动的状态&lt;/li&gt;
      &lt;li&gt;运行 Runable，对应操作系统中的Running和Ready，可以是正在执行也可以是等待CPU分配时间&lt;/li&gt;
      &lt;li&gt;等待 Waiting
        &lt;ul&gt;
          &lt;li&gt;无限期等待：Object.wait/Thread.join/LockSupport.park&lt;/li&gt;
          &lt;li&gt;限期等待：Thread.sleep/Object.wait timeout/Thread.join timeout/LockSupport.parkNanos timeout/LockSupport.parkUntil timeout&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;阻塞 Blocked
        &lt;ul&gt;
          &lt;li&gt;阻塞与等待的区别：阻塞是在等待这获取到一个排他锁，等待状态是在等待时间或者被唤醒&lt;/li&gt;
          &lt;li&gt;在程序等待进入同步区域的时候会进入该状态&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;结束 Terminated&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;线程安全的实现方法
    &lt;ul&gt;
      &lt;li&gt;互斥同步&lt;/li&gt;
      &lt;li&gt;非阻塞同步/乐观锁，乐观锁的实现依赖于”硬件指令集的发展”
      - 测试并设置 Test-and-Set
      - 获取并增加 Fetch-and-Increment
      - 交换 Swap
      - 比较并交换 CAS
      - 加载链接/条件存储&lt;/li&gt;
      &lt;li&gt;无同步&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;自旋锁，单纯自旋等待前面的锁定释放&lt;/li&gt;
  &lt;li&gt;偏向锁、轻量级锁、重量级锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/lock_optimize.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;总览&quot;&gt;总览&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/linghu-java/category/855958.html&quot;&gt;https://www.cnblogs.com/linghu-java/category/855958.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 15 Jul 2020 13:40:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/15/JVM-Note.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/15/JVM-Note.html</guid>
        
        <category>Java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Tree</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/tree.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;各种树&quot;&gt;各种树&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;AVL 树具有以下特点：
    &lt;ul&gt;
      &lt;li&gt;每个结点的平衡因子只可能是 -1、0、1（如果绝对值超过 1，则认为是失衡）&lt;/li&gt;
      &lt;li&gt;每个结点的左右子树高度差不超过 1&lt;/li&gt;
      &lt;li&gt;搜索、插入、删除的时间复杂度是 O(logn)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;二叉搜索树（Binary Search Tree）是二叉树的一种，英文简称 BST。又称为二叉查找树、二叉排序树。
    &lt;ul&gt;
      &lt;li&gt;它的特点是任何一个结点的值都大于其左子树的所有结点的值，任何一个结点的值都小于其右子树的所有结点的值。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;红黑树是一种含有红黑结点并能自平衡的二叉搜索树。
    &lt;ul&gt;
      &lt;li&gt;为了保证平衡，红黑树必须满足以下性质：
        &lt;ol&gt;
          &lt;li&gt;每个结点是要么是红色或黑色&lt;/li&gt;
          &lt;li&gt;根结点必须是黑色&lt;/li&gt;
          &lt;li&gt;叶结点（外部结点、空结点）是黑色&lt;/li&gt;
          &lt;li&gt;红色结点不能连续（也就是，红色结点的孩子和父亲都是黑色）&lt;/li&gt;
          &lt;li&gt;对于每个结点，从该点至 nil（树尾端，Java 中为 null 的结点）的任何路径都包含所相同个数的黑色结点&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;B 树（Balanced Tree）是一种平衡的多路搜索树，多用于文件系统、数据库的实现。
    &lt;ul&gt;
      &lt;li&gt;1个结点可以存储超过 2 个元素，可以拥有超过 2 个子结点&lt;/li&gt;
      &lt;li&gt;拥有二叉搜索树的一些性质&lt;/li&gt;
      &lt;li&gt;平衡，每个结点的所有子树高度一致&lt;/li&gt;
      &lt;li&gt;比较矮&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;数据库为什么用b树不用二叉树&quot;&gt;数据库为什么用B树不用二叉树&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;二叉树的高度以及建数过程，决定了磁盘的存储是分散的，导致读取时IO次数要远远高于B树&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;b树相对b-树的优点&quot;&gt;B+树相对B-树的优点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。&lt;/li&gt;
  &lt;li&gt;所以从Mysql（Inoodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别。&lt;/li&gt;
  &lt;li&gt;所以为了减少内存的占用，索引也会被存储在磁盘上。那么Mysql如何衡量查询效率呢？– 磁盘IO次数。&lt;/li&gt;
  &lt;li&gt;B-树/B+树 的特点就是每层节点数目非常多，层数很少，目的就是为了就少磁盘IO次数。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，增加了磁盘IO次数，磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;所以我们可以看到B+树的优点：
    &lt;ol&gt;
      &lt;li&gt;B+树的层级更少。
  相较于B树B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；&lt;/li&gt;
      &lt;li&gt;B+树查询速度更稳定。
  B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;&lt;/li&gt;
      &lt;li&gt;B+树天然具备排序功能。
  B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。&lt;/li&gt;
      &lt;li&gt;B+树全节点遍历更快。
  B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;树 &lt;a href=&quot;https://mp.weixin.qq.com/s/sq8rJBtT5mcDYh2ycBuX4g&quot;&gt;https://mp.weixin.qq.com/s/sq8rJBtT5mcDYh2ycBuX4g&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;为什么Mysql用B+树做索引而不用B-树或红黑树？&lt;a href=&quot;http://www.coder55.com/question/139&quot;&gt;http://www.coder55.com/question/139&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 15 Jul 2020 10:47:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/15/Tree.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/15/Tree.html</guid>
        
        <category>数据结构与算法</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Case of online system</title>
        <description>&lt;p&gt;&lt;img src=&quot;/img/arch1.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;电商秒杀系统&quot;&gt;电商秒杀系统&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;流量削峰前置
    &lt;ul&gt;
      &lt;li&gt;库存数量判断，直接走缓存，挡掉大部分请求（可以用lua在nginx层做）&lt;/li&gt;
      &lt;li&gt;只接受拥有合法token的等于库存数量的用户（需要考虑超时未支付的）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;异步化，轮询秒杀状态及下单&lt;/li&gt;
  &lt;li&gt;redis压力转移
    &lt;ul&gt;
      &lt;li&gt;本地应用服务器可以存储库存&lt;/li&gt;
      &lt;li&gt;商品id_分片的方式分开存储库存&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/tx_ZfE3rqbED0pteYEkdkQ&quot;&gt;https://mp.weixin.qq.com/s/tx_ZfE3rqbED0pteYEkdkQ&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;今日头条系统&quot;&gt;今日头条系统&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;业务数据：2015年 3000万日活、30亿PV、1亿VV、7000台机器&lt;/li&gt;
  &lt;li&gt;技术组件：Scribe、Flume、Kafka、Hadoop、Storm&lt;/li&gt;
  &lt;li&gt;在线存储-abase：QPS读360万、QPS写40万、延时avg 1ms、99%用户不会超过pct99 4ms&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mucaoyx/article/details/84498468&quot;&gt;https://blog.csdn.net/mucaoyx/article/details/84498468&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;100亿次的挑战如何实现一个有把握的春晚摇一摇系统&quot;&gt;100亿次的挑战：如何实现一个“有把握”的春晚摇一摇系统&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;指标：QPS1400、全程110亿次、638台接入机器、支撑14.6亿同时在线&lt;/li&gt;
  &lt;li&gt;接入层能支撑200万同时在线&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/DLbaiSiH15QBkrB_i0imEw&quot;&gt;https://mp.weixin.qq.com/s/DLbaiSiH15QBkrB_i0imEw&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;基于token的多平台身份认证架构设计&quot;&gt;基于token的多平台身份认证架构设计&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/token.png&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/beer/p/6029861.html&quot;&gt;https://www.cnblogs.com/beer/p/6029861.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;框架图&quot;&gt;框架图&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;可视化架构设计-C4 &lt;a href=&quot;https://www.jianshu.com/p/33c6a7ed126f&quot;&gt;https://www.jianshu.com/p/33c6a7ed126f&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;语境图、容器图、组件图、类图&lt;/li&gt;
      &lt;li&gt;系统景观图、部署图、动态图&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;UML &lt;a href=&quot;https://blog.csdn.net/qq_35495763/article/details/80764914&quot;&gt;https://blog.csdn.net/qq_35495763/article/details/80764914&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;用例图、活动图、序列图、类图、状态机&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;im系统存储设计&quot;&gt;IM系统（存储设计）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;单聊、小群使用写扩散，也就是推模式
    &lt;ul&gt;
      &lt;li&gt;优点：
        &lt;ul&gt;
          &lt;li&gt;消除了拉模式（读扩散）的IO集中点，每个用户都读自己的数据，高并发下锁竞争少&lt;/li&gt;
          &lt;li&gt;拉取朋友圈feed流列表的业务流程异常简单，速度很快&lt;/li&gt;
          &lt;li&gt;拉取朋友圈feed流列表，不需要进行大量的内存计算，网络传输，性能很高&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缺点：
        &lt;ul&gt;
          &lt;li&gt;极大的消耗存储资源，feed数据会存储很多份，例如杨幂5KW粉丝，她每次一发博文，消息会冗余5KW份&lt;/li&gt;
          &lt;li&gt;新增关注，取消关注，发布feed的业务流会更复杂&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;群聊、大VFeed使用写读扩散，也就是拉模式（可以先拉有更新的索引，然后触发服务器推）
    &lt;ul&gt;
      &lt;li&gt;优点：
        &lt;ul&gt;
          &lt;li&gt;存储结构简单，数据存储量较小，关系数据与feed数据都只存一份&lt;/li&gt;
          &lt;li&gt;取消关注，发布feed的业务流程非常简单&lt;/li&gt;
          &lt;li&gt;存储结构，业务流程都比较容易理解，非常适合项目早期用户量、数据量、并发量不大时的快速实现&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;缺点：
        &lt;ul&gt;
          &lt;li&gt;拉取朋友圈feed流列表的业务流程非常复杂&lt;/li&gt;
          &lt;li&gt;有多次数据访问，并且要进行大量的内存计算，大量数据的网络传输，性能较低&lt;/li&gt;
          &lt;li&gt;在拉模式中，系统的瓶颈容易出现在“用户所发布feed列表”的读取上，而每个用户发布feed的频率其实是很低的，此时，架构优化的核心是通过缓存降低数据存储磁盘IO。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;现代IM系统中消息推送和存储架构的实现 &lt;a href=&quot;https://developer.aliyun.com/article/253242&quot;&gt;https://developer.aliyun.com/article/253242&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;IM群聊消息的已读回执功能该怎么实现 &lt;a href=&quot;http://www.52im.net/thread-1611-1-1.html&quot;&gt;http://www.52im.net/thread-1611-1-1.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;IM群聊消息的已读未读功能在存储空间方面的实现思路探讨 &lt;a href=&quot;http://www.52im.net/forum.php?mod=viewthread&amp;amp;tid=3054&amp;amp;highlight=%B4%E6%B4%A2&quot;&gt;http://www.52im.net/forum.php?mod=viewthread&amp;amp;tid=3054&amp;amp;highlight=%B4%E6%B4%A2&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;微信后台基于时间序的海量数据冷热分级架构设计实践 &lt;a href=&quot;http://www.52im.net/thread-895-1-1.html&quot;&gt;http://www.52im.net/thread-895-1-1.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;微信后台基于时间序的新一代海量数据存储架构的设计实践 &lt;a href=&quot;http://www.52im.net/forum.php?mod=viewthread&amp;amp;tid=2970&amp;amp;highlight=%B4%E6%B4%A2&quot;&gt;http://www.52im.net/forum.php?mod=viewthread&amp;amp;tid=2970&amp;amp;highlight=%B4%E6%B4%A2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;亿级用户中心设计&quot;&gt;亿级用户中心设计&lt;/h4&gt;
&lt;p&gt;用户中心，是典型的“单KEY”类业务，这一类业务，都可以使用上述架构方案。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;常见的数据库水平切分方式有两种：
    &lt;ol&gt;
      &lt;li&gt;范围法；&lt;/li&gt;
      &lt;li&gt;哈希法；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;水平切分后碰到的问题是：
    &lt;ol&gt;
      &lt;li&gt;通过uid属性查询能直接定位到库，通过非uid属性查询不能定位到库；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;非uid属性查询，有两类典型的业务：
    &lt;ol&gt;
      &lt;li&gt;用户侧，前台访问，单条记录的查询，访问量较大，服务需要高可用，并且对一致性的要求较高；&lt;/li&gt;
      &lt;li&gt;运营侧，后台访问，根据产品、运营需求，访问模式各异，基本上是批量分页的查询，由于是内部系统，访问量很低，对可用性的要求不高，对一致性的要求也没这么严格；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;针对这两类业务，架构设计的思路是：
    &lt;ol&gt;
      &lt;li&gt;用户侧，采用“建立非uid属性到uid的映射关系”的架构方案；&lt;/li&gt;
      &lt;li&gt;运营侧，采用“前台与后台分离”的架构方案；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;前台用户侧，“建立非uid属性到uid的映射关系”，有四种常见的实践：
    &lt;ol&gt;
      &lt;li&gt;索引表法：数据库中记录login_name与uid的映射关系；&lt;/li&gt;
      &lt;li&gt;缓存映射法：缓存中记录login_name与uid的映射关系；&lt;/li&gt;
      &lt;li&gt;生成uid法：login_name生成uid；&lt;/li&gt;
      &lt;li&gt;基因法：login_name基因融入uid；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;后台运营侧，“前台与后台分离”的最佳实践是：
    &lt;ol&gt;
      &lt;li&gt;前台、后台系统 web/service/db 分离解耦，避免后台低效查询引发前台查询抖动；&lt;/li&gt;
      &lt;li&gt;可以采用数据冗余的设计方式；&lt;/li&gt;
      &lt;li&gt;可以采用“外置索引”（例如ES搜索系统）或者“大数据处理”（例如HIVE）来满足后台变态的查询需求；&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/8KTK_Bz8netP6R5MNSKeFw&quot;&gt;https://mp.weixin.qq.com/s/8KTK_Bz8netP6R5MNSKeFw&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 13 Jul 2020 11:45:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/13/Cases.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/13/Cases.html</guid>
        
        <category>分布式</category>
        
        <category>网络</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>Netty In Action</title>
        <description>&lt;p&gt;TODO &lt;a href=&quot;https://mp.weixin.qq.com/s/OFG6tD9YRbII3BgjF4IKRg&quot;&gt;https://mp.weixin.qq.com/s/OFG6tD9YRbII3BgjF4IKRg&lt;/a&gt;
netty源码阅读之ByteBuf之内存概念arena、chunk、page、subpage&lt;/p&gt;
&lt;h4 id=&quot;netty的组件&quot;&gt;Netty的组件&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;group() EventLoop -&amp;gt; 控制流、多线程处理、并发
    &lt;ul&gt;
      &lt;li&gt;一个 EventLoopGroup 包含一个或者多个 EventLoop;&lt;/li&gt;
      &lt;li&gt;一个 EventLoop 在它的生命周期内只和一个 Thread 绑定;&lt;/li&gt;
      &lt;li&gt;所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理;&lt;/li&gt;
      &lt;li&gt;一个 Channel 在它的生命周期内只注册于一个 EventLoop，一个Channel可以理解为一个用户;&lt;/li&gt;
      &lt;li&gt;一个 EventLoop 可能会被分配给一个或多个 Channel。 注意，在这种设计中，一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的，实际上消除了对于同步的需要。&lt;/li&gt;
      &lt;li&gt;EventLoop本身只由一个线程驱动，其处理了一个Channel的所有I/O事件，并且在该EventLoop的整个生命周期内都不会改变。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;channel() Channel -&amp;gt; Socket
    &lt;ul&gt;
      &lt;li&gt;ChannelPipeline
        &lt;ul&gt;
          &lt;li&gt;handler() ChannelHandler&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ChannelConfig&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ChannelFuture -&amp;gt; 异步通知&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;netty的数据容器bytebuf&quot;&gt;Netty的数据容器ByteBuf&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;它可以被用户自定义的缓冲区类型扩展;&lt;/li&gt;
  &lt;li&gt;通过内置的复合缓冲区类型实现了透明的零拷贝;&lt;/li&gt;
  &lt;li&gt;容量可以按需增长(类似于 JDK 的 StringBuilder);&lt;/li&gt;
  &lt;li&gt;在读和写这两种模式之间切换不需要调用 ByteBuffer 的 flip()方法;&lt;/li&gt;
  &lt;li&gt;读和写使用了不同的索引;&lt;/li&gt;
  &lt;li&gt;支持方法的链式调用;&lt;/li&gt;
  &lt;li&gt;支持引用计数;&lt;/li&gt;
  &lt;li&gt;支持池化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;netty的对象池化技术pooledbytebufallocator&quot;&gt;Netty的对象池化技术PooledByteBufAllocator&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过引用计数的方式实现 ReferenceCounted&lt;/li&gt;
  &lt;li&gt;Unpooled.copiedBuffer(“Netty rocks!”,CharsetUtil.UTF-8);&lt;/li&gt;
  &lt;li&gt;由于采用引用计数，需要在消费完消息之后调用ReferenceCountUtil.release(msg);&lt;/li&gt;
  &lt;li&gt;可以通过 java -Dio.netty.leakDetectionLevel=ADVANCED 这个参数设置泄露检测级别
&lt;img src=&quot;/img/leak_level.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;channelhandler-channelpipeline-channelhandlercontext&quot;&gt;ChannelHandler ChannelPipeline ChannelHandlerContext&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;每个ChannelHandler都会分配一个ChannelHandlerContext&lt;/li&gt;
  &lt;li&gt;通过Channel、Handler的write会传递整个pipe，但是通过context的write只能传递对应Handler之后的handlers&lt;/li&gt;
  &lt;li&gt;SimpleChannelInboundHandler&lt;T&gt;，最常见的情况是，你的应用程序会利用一个 ChannelHandler 来接收解码消息，并对该数据应用业务逻辑。要创建一个这样的 ChannelHandler，
  你只需要扩展基类 SimpleChannel- InboundHandler&lt;T&gt;，其中 T 是你要处理的消息的 Java 类型 。
  在这个 ChannelHandler 中， 你将需要重写基类的一个或者多个方法，并且获取一个到 ChannelHandlerContext 的引用， 
  这个引用将作为输入参数传递给 ChannelHandler 的所有方法。在这种类型的 ChannelHandler 中，最重要的方法是 channelRead0(Channel- HandlerContext,T)。除了要求不要阻塞当前的 I/O 线程之外，其具体实现完全取决于你。&lt;/T&gt;&lt;/T&gt;&lt;/li&gt;
  &lt;li&gt;ChannelOutboundHandlerAdapter，几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise 的实例。
  作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;promise.addListener&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new ChannelFutureListener&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
@Override
public void operationComplete&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ChannelFuture f&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;f.isSuccess&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; f.cause&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;.printStackTrace&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                      f.channel&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;.close&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h4 id=&quot;eventloop和线程池&quot;&gt;EventLoop和线程池&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;本质是创建包含少量的线程EventLoop的线程池EventLoopGroup，一个EventLoop管理多个Channel，
  实际上就是IO多路复用
&lt;img src=&quot;/img/eventLoop.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;bootstrap&quot;&gt;Bootstrap&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;为什么引导类是 Cloneable 的 你有时可能会需要创建多个具有类似配置或者完全相同配置的Channel。为了支持这种模式而又不
    &lt;ul&gt;
      &lt;li&gt;需要为每个Channel都创建并配置一个新的引导类实例，AbstractBootstrap被标记为了 Cloneable1。在一个已经配置完成的引导类实例上调用clone()方法将返回另一个可以立即使用的引 导类实例。&lt;/li&gt;
      &lt;li&gt;注意，这种方式只会创建引导类实例的EventLoopGroup的一个浅拷贝，所以，后者 2将在所有克 隆的Channel实例之间共享。这是可以接受的，因为通常这些克隆的Channel的生命周期都很短暂，一 个典型的场景是——创建一个Channel以进行一次HTTP请求。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;netty-设计&quot;&gt;Netty 设计&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;从高层次的角度来看，Netty 解决了两个相应的关注领域，我们可将其大致标记为技术的和 体系结构的。
    &lt;ul&gt;
      &lt;li&gt;首先，它的基于 Java NIO 的异步的和事件驱动的实现，保证了高负载下应用程序 性能的最大化和可伸缩性。&lt;/li&gt;
      &lt;li&gt;其次，Netty 也包含了一组设计模式，将应用程序逻辑从网络层解耦， 简化了开发过程，同时也最大限度地提高了可测试性、模块化以及代码的可重用性。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;不使用netty的nio&quot;&gt;不使用Netty的NIO&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/nio-selector.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;netty-的-opensslsslengine-实现&quot;&gt;Netty 的 OpenSSL/SSLEngine 实现&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Netty 还提供了使用 OpenSSL 工具包(www.openssl.org)的 SSLEngine 实现。这个 OpenSsl-Engine 类提供了比 JDK 提供的 SSLEngine 实现更好的性能。&lt;/li&gt;
  &lt;li&gt;如果 OpenSSL 库可用，可以将 Netty 应用程序(客户端和服务器)配置为默认使用 OpenSslEngine。如果不可用，Netty 将会回退到 JDK 实现。有关配置 OpenSSL 支持的详细说明，参见 Netty 文档: http://netty.io/wiki/forked-tomcat-native.html#wikih2-1。&lt;/li&gt;
  &lt;li&gt;注意，无论你使用 JDK 的 SSLEngine 还是使用 Netty 的 OpenSslEngine，SSL API 和数据流都 是一致的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/img/ssl_tls.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SelfSignedCertificate cert &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; new SelfSignedCertificate&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
SslContext context &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; SslContext.newServerContext&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;cert.certificate&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;, cert.privateKey&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

SSLEngine engine &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; context.newEngine&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ch.alloc&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
engine.setUseClientMode&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
ch.pipeline&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;.addFirst&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new SslHandler&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;engine&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;检测空闲连接以及超时对于及时释放资源&quot;&gt;检测空闲连接以及超时对于及时释放资源&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;new IdleStateHandler(0, 0, 60, TimeUnit.SECONDS)&lt;/li&gt;
  &lt;li&gt;ReadTimeoutHandler exceptionCaught()&lt;/li&gt;
  &lt;li&gt;WriteTimeoutHandler exceptionCaught()&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;写大数据&quot;&gt;写大数据&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ChunkedFile 从文件中逐块获取数据，当你的平台不支持零拷贝或者你需要转换数据时使用&lt;/li&gt;
  &lt;li&gt;ChunkedNioFile 和 ChunkedFile 类似，只是它使用了 FileChannel&lt;/li&gt;
  &lt;li&gt;ChunkedStream 从 InputStream 中逐块传输内容&lt;/li&gt;
  &lt;li&gt;ChunkedNioStream 从ReadableByteChannel中逐块传输内容
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final class WriteStreamHandler extends ChannelInboundHandlerAdapter &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  @Override
  public void channelActive&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ChannelHandlerContext ctx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;throws Exception &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      super.channelActive&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;ctx&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      ctx.writeAndFlush&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
      new ChunkedStream&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new FileInputStream&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;file&lt;span class=&quot;o&quot;&gt;)))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;h4 id=&quot;websocketframe&quot;&gt;WebSocketFrame&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;BinaryWebSocketFrame 包含了二进制数据&lt;/li&gt;
  &lt;li&gt;TextWebSocketFrame 包含了文本数据&lt;/li&gt;
  &lt;li&gt;ContinuationWebSocketFrame 包含属于上一个BinaryWebSocketFrame或TextWebSocket-Frame 的文本数据或者二进制数据&lt;/li&gt;
  &lt;li&gt;CloseWebSocketFrame 表示一个 CLOSE 请求，包含一个关闭的状态码和关闭的原因&lt;/li&gt;
  &lt;li&gt;PingWebSocketFrame 作为一个对于 PingWebSocketFrame 的响应被发送&lt;/li&gt;
  &lt;li&gt;PongWebSocketFrame 请求传输一个 PongWebSocketFrame&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;websocket示例&quot;&gt;WebSocket示例&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ChannelPipeline pipeline &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; ch.pipeline&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# http编解码&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new HttpServerCodec&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 写入一个文件的内容&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new ChunkedWriteHandler&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 将一个 HttpMessage 和跟随它的多个 HttpContent 聚合&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 为单个 FullHttpRequest 或者 FullHttpResponse(取决于它是被用来处理请求还是响应)。&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 安装了这个之后， ChannelPipeline 中的下一个 ChannelHandler 将只会 收到完整的 HTTP 请求或响应&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new HttpObjectAggregator&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;64 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 1024&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 如果是/ws请求就交个下个handler，否则HTTP handler来处理&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new HttpRequestHandler&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/ws&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 按照 WebSocket 规范的要求，处理 WebSocket 升级握手、 PingWebSocketFrame 、 PongWebSocketFrame 和 CloseWebSocketFrame&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new WebSocketServerProtocolHandler&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/ws&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 处理 TextWebSocketFrame 和握手完成事件&lt;/span&gt;
pipeline.addLast&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;new TextWebSocketFrameHandler&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;group&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在从标准的HTTP或者HTTPS协议切换到WebSocket时，将会使用一种称为升级握手的机制。因此 ，使用WebSocket的应用程序将始终以HTTP/S作为开始，然后再执行升级。这个升级动 作发生的确切时刻特定于应用程序;它可能会发生在启动时，也可能会发生在请求了某个特定的 URL之后。&lt;/p&gt;

&lt;h4 id=&quot;理解http协议中的-expect-100-continue&quot;&gt;理解HTTP协议中的 Expect: 100-continue&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP/1.1 协议里设计 100 (Continue) HTTP 状态码的的目的是，在客户端发送 Request Message 之前，HTTP/1.1 协议允许客户端先判定服务器是否愿意接受客户端发来的消息主体（基于 Request Headers）。&lt;/li&gt;
  &lt;li&gt;即， 客户端 在 Post（较大）数据到服务端之前，允许双方“握手”，如果匹配上了，Client 才开始发送（较大）数据。&lt;/li&gt;
  &lt;li&gt;这么做的原因是，如果客户端直接发送请求数据，但是服务器又将该请求拒绝的话，这种行为将带来很大的资源开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/skh2015java/article/details/88723028&quot;&gt;https://blog.csdn.net/skh2015java/article/details/88723028&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;http协议与websocket协议升级过程&quot;&gt;http协议与websocket协议升级过程&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# req&lt;/span&gt;
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: &lt;span class=&quot;nv&quot;&gt;x3JJHMbDL1EzLkh9GBhXDw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com

&lt;span class=&quot;c&quot;&gt;# resp&lt;/span&gt;
Sec-WebSocket-Key: &lt;span class=&quot;nv&quot;&gt;x3JJHMbDL1EzLkh9GBhXDw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;http://www.xiaosongit.com/index/detail/id/645.html&quot;&gt;http://www.xiaosongit.com/index/detail/id/645.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;其他&quot;&gt;其他&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ChannelFuture 与 ChannelFutureListener相互结合，构成了Netty本身的关键构件之一&lt;/li&gt;
  &lt;li&gt;关于ServerBootStrap，因为服务器需要两组不同的 Channel。第一组将只包含一个 ServerChannel，代表服务 器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传 入客户端连接(对于每个服务器已经接受的连接都有一个)的 Channel。&lt;/li&gt;
  &lt;li&gt;为啥ByteBuffer 为啥flip()?&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 08 Jul 2020 18:18:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/08/NettyInAction.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/08/NettyInAction.html</guid>
        
        <category>java</category>
        
        <category>网络</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>DotDot</title>
        <description>&lt;h4 id=&quot;蚂蚁金服&quot;&gt;蚂蚁金服&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;ArrayList的扩容方式和扩容时机
    &lt;ul&gt;
      &lt;li&gt;初始化
  ArrayList的底层是一个动态数组，ArrayList首先会对传进来的初始化参数initalCapacity进行判断
  如果参数等于0，则将数组初始化为一个空数组，
  如果不等于0，将数组初始化为一个容量为10的数组。&lt;/li&gt;
      &lt;li&gt;扩容时机
  当数组的大小大于初始容量的时候(比如初始为10，当添加第11个元素的时候)，就会进行扩容，新的容量为旧的容量的1.5倍。
  Vector会扩容2倍。&lt;/li&gt;
      &lt;li&gt;扩容方式
 扩容的时候，会以新的容量建一个原数组的拷贝，修改原数组，指向这个新数组，原数组被抛弃，会被GC回收。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/silyvin/p/10223910.html&quot;&gt;https://www.cnblogs.com/silyvin/p/10223910.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;volatile保证可见性禁止重排无法实现原子性&quot;&gt;volatile（保证可见性、禁止重排、无法实现原子性）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;指令重排只会保证串行语义的执行一致性(单线程) 并不会关心多线程间的语义一致性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cas--unsafe&quot;&gt;CAS &amp;amp; Unsafe&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CAS的全称为Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。&lt;/li&gt;
  &lt;li&gt;CAS并发原语体现在JAVA语言中就是sum.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所有的数据不一致问题。&lt;/li&gt;
  &lt;li&gt;CAS只能保证一个共享变量的原子性&lt;/li&gt;
  &lt;li&gt;CAS自旋&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 我们可以看到getAndAddInt方法执行时，有个do while&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# unsafe.getAndAddInt&lt;/span&gt;
public final int getAndAddInt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Object var1, long var2, int var4&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
    int var5&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        var5 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; this.getIntVolatile&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;var1, var2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;this.compareAndSwapInt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;var1, var2, var5, var5 + var4&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;var5&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会能CPU带来很大的开锁。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;CAS造成的ABA问题用版本号解决&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# （旧值，新值）&lt;/span&gt;
atomicReference.compareAndSet&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;101, 100&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# AtomicStampedReference 以时间戳做为版本号解决ABA的问题&lt;/span&gt;
public boolean compareAndSet&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;exchanger&quot;&gt;Exchanger&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;允许在并发任务之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中&lt;/li&gt;
  &lt;li&gt;例子模拟一个队列中数据的交换使用的场景：
    &lt;ul&gt;
      &lt;li&gt;线程A往队列中存入数据&lt;/li&gt;
      &lt;li&gt;线程B从队列中消耗数据&lt;/li&gt;
      &lt;li&gt;当线程A存满的时候&lt;/li&gt;
      &lt;li&gt;才交换给线程B&lt;/li&gt;
      &lt;li&gt;当线程B消耗完成之后才交换给线程A。&lt;/li&gt;
      &lt;li&gt;线程A、B的生产和消耗的速率有可能不同&lt;/li&gt;
      &lt;li&gt;对方线程调用exchange之前，另一个线程执行到exchange会阻塞&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jvm-对-java-的原生锁做了哪些优化&quot;&gt;JVM 对 Java 的原生锁做了哪些优化？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一种优化是使用自旋锁，即在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;现代 JDK 中还提供了三种不同的 Monitor 实现，也就是三种不同的锁：
    &lt;ul&gt;
      &lt;li&gt;偏向锁（Biased Locking）&lt;/li&gt;
      &lt;li&gt;轻量级锁&lt;/li&gt;
      &lt;li&gt;重量级锁,这三种锁使得 JDK 得以优化 Synchronized 的运行，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这就是锁的升级、降级。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;当没有竞争出现时，默认会使用偏向锁。
    &lt;ul&gt;
      &lt;li&gt;JVM 会利用 CAS 操作，在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁，因为在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;如果有另一线程试图锁定某个被偏斜过的对象，JVM 就撤销偏斜锁，切换到轻量级锁实现。&lt;/li&gt;
  &lt;li&gt;轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;readwritelock&quot;&gt;ReadWriteLock&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final boolean tryWriteLock&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            Thread current &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Thread.currentThread&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            int c &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; getState&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                int w &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; exclusiveCount&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;w &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; current &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; getExclusiveOwnerThread&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;w &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; MAX_COUNT&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    throw new Error&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;compareAndSetState&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c, c + 1&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            setExclusiveOwnerThread&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;current&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        /&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Performs tryLock &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;read&lt;/span&gt;, enabling barging &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;both modes.
         &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; This is identical &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;effect to tryAcquireShared except &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; lack of calls to readerShouldBlock.
         &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/
        final boolean tryReadLock&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            Thread current &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Thread.currentThread&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                int c &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; getState&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;exclusiveCount&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; 0 &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                    getExclusiveOwnerThread&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; current&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                int r &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; sharedCount&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;r &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; MAX_COUNT&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    throw new Error&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;compareAndSetState&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;c, c + SHARED_UNIT&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;r &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        firstReader &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; current&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        firstReaderHoldCount &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;firstReader &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; current&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        firstReaderHoldCount++&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        HoldCounter rh &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; cachedHoldCounter&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rh &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; null &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; rh.tid &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; getThreadId&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;current&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
                            cachedHoldCounter &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; rh &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; readHolds.get&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;else if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rh.count &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                            readHolds.set&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;rh&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                        rh.count++&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;面向对象的五大基本原则solid&quot;&gt;面向对象的五大基本原则(solid)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;S单一职责SRP:Single-Responsibility Principle
   一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。&lt;/li&gt;
  &lt;li&gt;O开放封闭原则OCP:Open-Closed Principle
   软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭&lt;/li&gt;
  &lt;li&gt;L里氏替换原则LSP:Liskov-Substitution Principle
   子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。&lt;/li&gt;
  &lt;li&gt;I接口隔离原则ISP:Interface-Segregation Principle
   使用多个小的接口,而不是一个大的总接口&lt;/li&gt;
  &lt;li&gt;D依赖倒置原则DIP:Dependency-Inversion Principle
   依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;类什么时候才被初始化&quot;&gt;类什么时候才被初始化&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;创建类的实例，也就是new一个对象&lt;/li&gt;
  &lt;li&gt;访问某个类或接口的静态变量，或者对该静态变量赋值&lt;/li&gt;
  &lt;li&gt;调用类的静态方法&lt;/li&gt;
  &lt;li&gt;反射（Class.forName(“com.lyj.load”)）&lt;/li&gt;
  &lt;li&gt;初始化一个类的子类（会首先初始化子类的父类）&lt;/li&gt;
  &lt;li&gt;JVM启动时标明的启动类，即文件名和类名相同的那个类&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;arraylist&quot;&gt;ArrayList&lt;/h4&gt;
&lt;p&gt;ArrayList创建时的大小为0；当加入第一个元素时，进行第一次扩容时，默认容量大小为10。
ArrayList每次扩容都以当前数组大小的1.5倍去扩容。
Vector创建时的默认大小为10。
Vector每次扩容都以当前数组大小的2倍去扩容。当指定了capacityIncrement之后，每次扩容仅在原先基础上增加capacityIncrement个单位空间。
ArrayList和Vector的add、get、size方法的复杂度都为O(1)，remove方法的复杂度为O(n)。
ArrayList是非线程安全的，Vector是线程安全的。&lt;/p&gt;

&lt;h4 id=&quot;hashmap为什么初始容量是2的指数幂&quot;&gt;hashmap为什么初始容量是2的指数幂&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;hashmap在确定元素落在数组的位置的时候，计算方法是(n - 1) &amp;amp; hash，n为数组长度也就是初始容量 ，这是因为“取模”运算的消耗还是比较大的，那么如何保证(n - 1) &amp;amp; hash和hash%n的结果相同呢，当n为2的指数次幂时，会满足一个公式：(n - 1) &amp;amp; hash = hash % n，这样就可以用(n - 1) &amp;amp; hash的位运算来使计算更加高效。&lt;/li&gt;
  &lt;li&gt;如果初始容量是奇数，那么（n-1)就为偶数，偶数2进制的结尾都是0，经过hash值&amp;amp;运算后末尾都是0，那么0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这样就会造成空间的浪费而且会增加hash冲突。&lt;/li&gt;
  &lt;li&gt;只有是2的指数次幂的数字经过n-1之后，二进制肯定是  …11111111  这样的格式，这种格式计算的位置的时候，完全是由产生的hash值类决定，而不受n-1 影响。这样会提高效率。比如要扩容了，2的幂次方*2，在二进制中比如4和8，代表2的2次方和3次方，他们的2进制结构相 似,比如 4和8   00000100    0000 1000   只是高位向前移了一位，这样扩容的时候，只需要判断高位hash,移动到之前位置的倍数就可以了，免去了重新计算位置的运算。并且这样可以保证(n - 1) &amp;amp; hash得到的存储位置是在hashmap的length之内的,也就是n之内。因为最大也就是hash值也全是…1111111&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;springboot-start&quot;&gt;SpringBoot Start&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;引入该Start相关依赖&lt;/li&gt;
  &lt;li&gt;查找resources/META-INF/spring.factories下对应的XXXAutoConfigure&lt;/li&gt;
  &lt;li&gt;根据Condition自己加装相关的Bean
    &lt;ul&gt;
      &lt;li&gt;@ConditionalOnBean:当容器中有指定的Bean的条件下&lt;/li&gt;
      &lt;li&gt;@ConditionalOnClass：当类路径下有指定的类的条件下&lt;/li&gt;
      &lt;li&gt;@ConditionalOnExpression:基于SpEL表达式作为判断条件&lt;/li&gt;
      &lt;li&gt;@ConditionalOnJava:基于JVM版本作为判断条件&lt;/li&gt;
      &lt;li&gt;@ConditionalOnJndi:在JNDI存在的条件下查找指定的位置&lt;/li&gt;
      &lt;li&gt;@ConditionalOnMissingBean:当容器中没有指定Bean的情况下&lt;/li&gt;
      &lt;li&gt;@ConditionalOnMissingClass:当类路径下没有指定的类的条件下&lt;/li&gt;
      &lt;li&gt;@ConditionalOnNotWebApplication:当前项目不是Web项目的条件下&lt;/li&gt;
      &lt;li&gt;@ConditionalOnProperty:指定的属性是否有指定的值&lt;/li&gt;
      &lt;li&gt;@ConditionalOnResource:类路径下是否有指定的资源&lt;/li&gt;
      &lt;li&gt;@ConditionalOnSingleCandidate:当指定的Bean在容器中只有一个，或者在有多个Bean的情况下，用来指定首选的Bean&lt;/li&gt;
      &lt;li&gt;@ConditionalOnWebApplication:当前项目是Web项目的条件下&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yuansc/p/9088212.html&quot;&gt;https://www.cnblogs.com/yuansc/p/9088212.html&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;spring中解决循环依赖为什么要用三级缓存&quot;&gt;Spring中解决循环依赖为什么要用三级缓存&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Bean创建有3步
    &lt;ol&gt;
      &lt;li&gt;初始化init,分配内存空间，此时在singletonFactories完成&lt;/li&gt;
      &lt;li&gt;注入各种属性，此时在earlySingletonObjects中&lt;/li&gt;
      &lt;li&gt;完美的bean最终会在singletonObjects中&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;举例
    &lt;ul&gt;
      &lt;li&gt;A与B循环依赖，A初始化经过第1、2步，在第2步发现依赖B&lt;/li&gt;
      &lt;li&gt;此时，触发B的初始化进入第1步，如果再进入第2步，会发现依赖A了，所以此时B只能在第1步&lt;/li&gt;
      &lt;li&gt;把B的第1步，不完美的B注入给A，先完成A的注入，让A进入第3步&lt;/li&gt;
      &lt;li&gt;然后，再完成B的完美初始化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;关于nio的-channel与bytebuffer&quot;&gt;关于NIO的 Channel与ByteBuffer&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Buffer的使用，主要是减少copy实现零拷贝，流的读写方式还是基于用户态和内核态的拷贝&lt;/li&gt;
  &lt;li&gt;从使用NIO读写文件说起——拆解堆外内存分配过程  &lt;a href=&quot;https://mp.weixin.qq.com/s/Wea1ubBTH9jXSZtU9NwVhw&quot;&gt;https://mp.weixin.qq.com/s/Wea1ubBTH9jXSZtU9NwVhw&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;从操作系统看NIO &lt;a href=&quot;https://mp.weixin.qq.com/s/Titt2vOEtSWIzEbtWKQOzA&quot;&gt;https://mp.weixin.qq.com/s/Titt2vOEtSWIzEbtWKQOzA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;关于nio的-空轮训的bug&quot;&gt;关于NIO的 空轮训的bug&lt;/h4&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    selector.select&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  // &lt;span class=&quot;k&quot;&gt;select &lt;/span&gt;可能在无就绪事件时异常返回！主要发生在linux系统

    Set&amp;lt;SelectionKey&amp;gt; readyKeys &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; selector.selectedKeys&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    Iterator&amp;lt;SelectionKey&amp;gt; it &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; readyKeys.iterator&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;it.hasNext&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        SelectionKey key &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; it.next&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        ...  // 处理事件
        it.remove&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;selector.select() 应该 一直阻塞，直到有就绪事件到达，但很遗憾，由于 Java NIO 实现上存在 bug，select() 可能在 没有 任何就绪事件的情况下返回，从而导致 while(true) 被不断执行，最后导致某个 CPU 核心的利用率飙升到 100%，这就是臭名昭著的 Java NIO 的 epoll bug。&lt;/li&gt;
  &lt;li&gt;解决方法
```shell
selectCnt = 0;  // epoll 空轮询场景下 select 调用次数
long currentTimeNanos = System.nanoTime();  // 每个 for 循环开始时的绝对时间&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;for (;;) {
    timeoutMillis = …  // 初始化超时参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int selectedKeys = selector.select(timeoutMillis);
selectCnt++;

long time = System.nanoTime();  // 记录执行到此处的绝对时间：

// 检测逻辑
if (time - currentTimeNanos &amp;gt; timeoutMillis) {
    selectCnt = 1;  // 未发生 epoll 空轮询，所以把 selectCnt 重置为 1
} else if (selectCnt &amp;gt;= 重试次数阈值（默认 512）) {
    selector = selectRebuildSelector(selectCnt);  // 解决 epoll bug 的实际逻辑
    selectCnt = 1;  // 解决本次 epoll bug，重置 selectCnt
    break;
}

currentTimeNanos = time;  // 重置下次 for 循环开始时间 } ``` - &amp;lt;http://songkun.me/2019/07/26/2019-07-26-java-nio-epoll-bug-and-netty-solution/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;netty零拷贝总结的比较清楚了&quot;&gt;Netty零拷贝总结的比较清楚了&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;零拷贝
    &lt;ul&gt;
      &lt;li&gt;在传统的I/O操作中，每次都需要把内核空间的数据拷贝到用户空间中，这样挺浪费空间的，所以零拷贝的出现就是为了解决这个问题。&lt;/li&gt;
      &lt;li&gt;主要有两种方法：mmap+write 和 Sendfile&lt;/li&gt;
      &lt;li&gt;mmap+write&lt;/li&gt;
      &lt;li&gt;使用mmap+write方式替换原来的read+write方式，mmap是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对应关系。
  这样就可以省略掉原来内核Read缓冲区Copy数据到用户缓冲区，但是还是需要内核Read缓冲区将数据Copy到内核Socket缓冲区。&lt;/li&gt;
      &lt;li&gt;Sendfile&lt;/li&gt;
      &lt;li&gt;Sendfile是为了简化通过网络在两个通道内进行的数据传输过程。&lt;/li&gt;
      &lt;li&gt;它不仅减少了数据复制，还减少了上下文次数的切换。数据传送只发生在内核空间里，所以减少了一次上下文切换，但是还是存在一次Copy。
  后来进行了改进，将Kernel Buffer中对应的数据描述信息（内存地址，偏移量）记录到相应的Socket缓冲区中，这样连内核空间中的一次CPU Copy也省掉了。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Netty的零拷贝具体体现
    &lt;ul&gt;
      &lt;li&gt;Netty零拷贝主要体现在三个方面。&lt;/li&gt;
      &lt;li&gt;Netty的接收和发送ByteBuffer采用DirtectByteBuffer，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。&lt;/li&gt;
      &lt;li&gt;Netty在操作多个Channel时，使用CompositeChannelBuffer，它并不会开辟新的内存并复制所有ChannelBuffer内容，而是直接保存了所有ChannelBuffer的引用，并在子ChannelBuffer里进行读写，实现了零拷贝。&lt;/li&gt;
      &lt;li&gt;Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/mFhSemUjxxsp6RBpvT6Cmg&quot;&gt;https://mp.weixin.qq.com/s/mFhSemUjxxsp6RBpvT6Cmg&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;netty&quot;&gt;Netty&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaoyangjia/p/11526197.html&quot;&gt;https://www.cnblogs.com/xiaoyangjia/p/11526197.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;utf-8-是一种变长的编码方式&quot;&gt;Utf-8 是一种变长的编码方式&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。&lt;/li&gt;
  &lt;li&gt;对于n字节的符号（n&amp;gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
    &lt;ul&gt;
      &lt;li&gt;1110xxxx 10xxxxxx 10xxxxxx （3个字节，xxx放入Unicode）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Little endian和Big endian
    &lt;ul&gt;
      &lt;li&gt;Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。&lt;/li&gt;
      &lt;li&gt;如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;redis与memcached区别&quot;&gt;Redis与Memcached区别&lt;/h4&gt;
&lt;p&gt;如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。&lt;/li&gt;
  &lt;li&gt;Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li&gt;
  &lt;li&gt;Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。&lt;/li&gt;
  &lt;li&gt;在Redis中，并不是所有的数据都一直存储在内存中的。这是和Memcached相比一个最大的区别&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;http-https-dns原理-&quot;&gt;HTTP HTTPS DNS原理 !!!???&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;使用HTTPDNS相比LocalDNS的好处&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;jdk-各个版本特性&quot;&gt;JDK 各个版本特性&lt;/h4&gt;

&lt;h4 id=&quot;kubernetes-和-istio-service-mesh-sidecar-&quot;&gt;Kubernetes 和 Istio 、Service Mesh Sidecar ???&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;微服务的缺点？分布式系统的复杂性;多服务运维难度,随着服务的增加,运维的压力也在增大;系统部署依赖;服务间通信成本;数 据一致性;系统集成测试;性能监控&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;lvs之drnattun模式祥解&quot;&gt;LVS之DR,NAT,TUN模式祥解&lt;/h4&gt;

&lt;h4 id=&quot;内存泄漏-内存溢出&quot;&gt;内存泄漏 内存溢出&lt;/h4&gt;

&lt;h4 id=&quot;direct-memory-回收&quot;&gt;Direct Memory 回收？？？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/xieyuooo/article/details/7547435&quot;&gt;https://blog.csdn.net/xieyuooo/article/details/7547435&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/phj88/article/details/8011830&quot;&gt;https://blog.csdn.net/phj88/article/details/8011830&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 08 Jul 2020 14:18:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/08/DotDot.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/08/DotDot.html</guid>
        
        <category>java</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>用户画像之标签数据开发</title>
        <description>&lt;h4 id=&quot;离线标签开发&quot;&gt;离线标签开发&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;统计类标签开发，是指统计用户相关数值、客户描述用户状态的标签，如用户的年龄、体重、累计购买金额、累计购买次数、近30日登陆次数
    &lt;ul&gt;
      &lt;li&gt;近30日购买行为（付款订单量ACTION_U_01_001、总付款金额ACTION_U_01_002、加入购物车次数ACTION_U_01_003）&lt;/li&gt;
      &lt;li&gt;最近来访：最近登录到今天的天数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;规则类标签开发，是指根据业务运营上的需要，在业务层面制定规则的标签。这类标签会带一些人为主观判断
    &lt;ul&gt;
      &lt;li&gt;数码达人，用户浏览的商品中有80%是3C产品，自动打标签&lt;/li&gt;
      &lt;li&gt;用户价值类RFM（重要/一般 价值/保持/发展/挽留）
        &lt;ul&gt;
          &lt;li&gt;R&amp;lt;=90为近，R&amp;gt;90为远&lt;/li&gt;
          &lt;li&gt;F&amp;lt;=3为低频，F&amp;gt;3为高频&lt;/li&gt;
          &lt;li&gt;M&amp;lt;=300为低额，M&amp;gt;300为高额&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;用户活跃程度（用户留存率的拐点一般就是用户的生命周期）
        &lt;ul&gt;
          &lt;li&gt;ACTION_U_05_003 高活跃&lt;/li&gt;
          &lt;li&gt;ACTION_U_05_002 中活跃&lt;/li&gt;
          &lt;li&gt;ACTION_U_05_001 低活跃&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;挖掘类标签开发，是指需要应用算法挖掘用户相关特征，比如预测性别、预测下单、预测流失、预测偏好
      - 文章分类&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;实时类标签开发&quot;&gt;实时类标签开发&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;新人弹窗、新人红包&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;用户特征库开发动态标签&quot;&gt;用户特征库开发（动态标签）&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;用户特征库就是对用户每一次的不同行为（如浏览、收藏、搜索、购买等）及该行为对应的标签（或商品品类）进行
  详细的记录，以便从用户的行为特征中挖掘用户的偏好。&lt;/li&gt;
  &lt;li&gt;经常浏览或购买奶粉、尿不湿等，她可能是个妈妈。&lt;/li&gt;
  &lt;li&gt;查询最近7日浏览某商品详情页超过10次的用户&lt;/li&gt;
  &lt;li&gt;查询7日浏览、收藏、关注过”母婴”品类商品的用户&lt;/li&gt;
  &lt;li&gt;用户标签权重=行为类型权重 X 时间衰减 X 用户行为次数 X TF-IDF计算标签权重
&lt;img src=&quot;/img/up9.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;同现矩阵是指标签和标签之间的关联程度，这种关联程度有用户身上的标签所决定。（啤酒&amp;amp;尿不湿）&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;人群计算&quot;&gt;人群计算&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;通过标签筛选人群
    &lt;ul&gt;
      &lt;li&gt;从MySQL中读出规则&lt;/li&gt;
      &lt;li&gt;请求es数据找出用户id&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;打通数据服务处&quot;&gt;打通数据服务处&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;把数据发送给相应的业务系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;用户画像的应用&quot;&gt;用户画像的应用&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;经营分析
    &lt;ul&gt;
      &lt;li&gt;商品分析&lt;/li&gt;
      &lt;li&gt;用户分析&lt;/li&gt;
      &lt;li&gt;渠道分析&lt;/li&gt;
      &lt;li&gt;漏斗分析&lt;/li&gt;
      &lt;li&gt;客服话术&lt;/li&gt;
      &lt;li&gt;人群特征分析&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;精准营销
    &lt;ul&gt;
      &lt;li&gt;短信/邮件营销&lt;/li&gt;
      &lt;li&gt;效果分析&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;个性化推荐与服务&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;案例&quot;&gt;案例&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;风控反欺诈画像模型
&lt;img src=&quot;/img/up10.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;LTV生命周期运营
    &lt;ul&gt;
      &lt;li&gt;流失率的倒数用来表示预测的用户的生命周期，如果一个产品的流失率为10%，则产品对应的生命周期为10个月&lt;/li&gt;
      &lt;li&gt;单个用户毛利 = CLV customer life value - CAC customer aqurie cost - COC customer operation cost
&lt;img src=&quot;/img/up11.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;80%的注册用户在安装3日内完成注册，那就圈出来3日用户发红包优惠券等&lt;/li&gt;
  &lt;li&gt;76%的下单用户是在注册前9日完成的首次交易&lt;/li&gt;
  &lt;li&gt;注册首日消费满100，立即短信营销赠送红包，以更好地留存该高价值新用户&lt;/li&gt;
  &lt;li&gt;Session特征库
&lt;img src=&quot;/img/up12.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;在线医疗场景
&lt;img src=&quot;/img/up13.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/up14.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/up15.jpg&quot; width=&quot;600px&quot; /&gt;
&lt;img src=&quot;/img/up16.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 07 Jul 2020 16:18:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/07/UserProfile3.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/07/UserProfile3.html</guid>
        
        <category>用户</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>用户画像之标签存储</title>
        <description>&lt;h4 id=&quot;数据仓库&quot;&gt;数据仓库&lt;/h4&gt;
&lt;p&gt;“数据􏱓库􏲄父”W.H.Inmon􏱖《Building the Data Warehouse》在一书􏰇􏰷定义数据􏱓仓库是“一个􏱥面􏰤向主题的、集成的、非易失的、随时􏰣变化的、用来支持􏲆管理人员决策的数据集合􏰬”。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;面􏰤向主题:业􏰊务数据库中􏰷的数据主要􏲊对事务处􏲋理，各个业􏱇􏱥􏰊务系统之间􏰦􏰮􏲄􏰣是相互分离的，而􏱽数据􏱓仓库中􏰷的数据是􏲌按照一定主题进行组织的。&lt;/li&gt;
  &lt;li&gt;集成:数据仓􏱓库中􏰷存储的数据是从业􏰊务数据库中􏰷提取出来的，但􏱟并不是对原有数据的􏱂简单复􏲍制，而􏱽是经过了抽􏲎􏱗􏱞􏲏取、清􏲐理、转􏲑换 (ETL)等􏱣工作􏰔。业􏰊务数据库记􏱀录的是每􏱤一项􏰊业务处􏲋理的流水􏰸􏲒账。这􏲓些数据不适􏰬进行分析处理，进入数据􏱓库􏲄前需要􏲎􏱗一系列计算􏰢， 同时􏲔􏲕抛弃一些无关分析处理的数据。&lt;/li&gt;
  &lt;li&gt;非易􏲅失:􏰊业务数据库中􏰷一般􏲃􏲖存储短期数据，􏲗因此其数据是不稳定的，记􏱀的是􏰦􏰮􏰷数据变化的瞬态􏱪。数据􏱓仓库中􏰷的数据􏱝􏱿大多表示过􏱗去某􏱋一时刻的数据，主要用于查询、分析􏱼，不像􏰊业务系统中􏰦􏰮􏰷的数据库一样􏲎经常修改，一般􏲃数据􏱓仓库构􏰼建完成后主要用于􏰋访问􏱭，不进行修􏲘改􏱰删除。&lt;/li&gt;
  &lt;li&gt;随时􏰣变化:数据仓􏱓库关注􏱩的是历史􏲙数据，按􏲌时间􏰣顺序定期从􏰊业务库和􏱰日志􏱺库里面载􏲚入新的数据进行追􏲛加，带有时间属性􏰲。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;标签分区存储&quot;&gt;标签分区存储&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/up1.jpeg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数字表示
    &lt;ul&gt;
      &lt;li&gt;0：用户没被打上该标签&lt;/li&gt;
      &lt;li&gt;1：用户被打上该标签，但是没有具体数值&lt;/li&gt;
      &lt;li&gt;具体数字：用户被打上该标签，有具体数值
&lt;img src=&quot;/img/up2.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;标签以userid进行冗余存储&quot;&gt;标签以UserID进行冗余存储&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/up3.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;id-map&quot;&gt;ID-MAP&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;用户使用不同设备登录系统，或者同一设备登录多个用户&lt;/li&gt;
  &lt;li&gt;可以通过event_log、page_view_log等来获取登录时长、登录天数&lt;/li&gt;
  &lt;li&gt;userid与cookieId通常是多对多
&lt;img src=&quot;/img/up4.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mysql存储元数据管理&quot;&gt;Mysql存储元数据管理&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/up5.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;mysql存储结果集&quot;&gt;Mysql存储结果集&lt;/h4&gt;
&lt;p&gt;比如用脚本通过Sqoop把Hive结果导入的mysql中，主要是离线，在线的建议用HBase&lt;/p&gt;

&lt;h4 id=&quot;hbase存储&quot;&gt;HBase存储&lt;/h4&gt;
&lt;p&gt;使用Spark，把用户标签同步到HBase以供线上实时访问
&lt;img src=&quot;/img/up6.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;es做为hbase的二级索引方便快速检索&quot;&gt;Es做为HBase的二级索引方便快速检索&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/up7.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;从etlhivhbasees整个链路的数据监控旧数据可怕&quot;&gt;从ETL/Hiv/HBase/Es整个链路的数据监控，旧数据可怕&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/up8.jpg&quot; width=&quot;600px&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Jul 2020 16:18:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/07/UserProfile2.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/07/07/UserProfile2.html</guid>
        
        <category>用户</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>myBatis</title>
        <description>&lt;h4 id=&quot;mybatis-和的区别是什么&quot;&gt;myBatis #{}和${}的区别是什么?&lt;/h4&gt;
&lt;p&gt;1)#{}是预编译处理，${}是字符串替换。
2)Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值;
3)Mybatis 在处理${}时，就是把${}替换成变量的值。 4)使用#{}可以有效的防止 SQL 注入，提高系统安全性。&lt;/p&gt;

&lt;h4 id=&quot;35ibatis-和-mybatis-区别&quot;&gt;35、IBatis 和 MyBatis 区别&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;IBatis 里面的核心处理类交 SqlMapClient,MyBatis 里面的核心处理类叫做 SqlSession。&lt;/li&gt;
  &lt;li&gt;在 sql 里面变量命名有原来的#变量# 变成了#{变量}&lt;/li&gt;
  &lt;li&gt;原来的$变量$变成了${变量}&lt;/li&gt;
  &lt;li&gt;原来在 sql 节点里面的 class 都换名字交 type&lt;/li&gt;
  &lt;li&gt;原来的 queryForObject queryForList 变成了 selectOne selectList5)原来的别名设置在映射 文件里面放在了核心配置文件里。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mybatis是否支持延迟加载如果支持它的实现原理是什么&quot;&gt;Mybatis是否支持延迟加载?如果支持，它的实现原理是什么？&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;Mybatis仅支持association关联对象和collection关联集合对象的延迟 
 加载，association指的就是一对一，collection指的就是一对多查询。在 
 Mybatis配置文件中，可以配置是否启用延迟加载 
 lazyLoadingEnabled=true|false&lt;/li&gt;
  &lt;li&gt;它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法 
 时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke〇 
 方法发现a.getB〇是null值，那么就会单独发送事先保存好的查询关联B 
 对象的sql，把B查询上来，然后调用fsetB(b)l，于是a的对象b属 
 性就有值了，接着完成|a.getB() .getNamet)]方法的调用。这就是延迟 
 加载的基本原理。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 30 Jun 2020 16:06:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/06/30/myBatis.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/06/30/myBatis.html</guid>
        
        <category>数据库</category>
        
        
        <category>技术</category>
        
      </item>
    
      <item>
        <title>HTTP-HTTPS</title>
        <description>&lt;h4 id=&quot;linux版本&quot;&gt;Linux版本&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;0.00  1991.2-4 两个进程分别显示AAA BBB&lt;/li&gt;
  &lt;li&gt;0.01  1991.9 第一个正式向外公布的Linux内核版本&lt;/li&gt;
  &lt;li&gt;0.02  1991.10.5 Linus Torvalds将当时最初的0.02内核版本发布到了Minix新闻组，很快就得到了反应。Linus Torvalds在这种简单的任务切换机制上进行扩展，并在很多热心支持者的帮助下开发和推出了Linux的第一个稳定的工作版本。&lt;/li&gt;
  &lt;li&gt;0.03  1991.10.5&lt;/li&gt;
  &lt;li&gt;0.10  1991.10 Linux0.10版本内核发布，0.11版本随后在1991年12月推出，当时它被发布在Internet上，供人们免费使用。&lt;/li&gt;
  &lt;li&gt;0.11  1991.12.8 基本可以正常运行的内核版本&lt;/li&gt;
  &lt;li&gt;0.12  1992.1.15 主要加入对数学协处理器的软件模拟程序&lt;/li&gt;
  &lt;li&gt;0.95（0.13） 1992.3.8 开始加入虚拟文件系统思想的内核版本&lt;/li&gt;
  &lt;li&gt;0.96  1992.5.12 开始加入网络支持和虚拟文件系统&lt;/li&gt;
  &lt;li&gt;0.97  1992.8.1&lt;/li&gt;
  &lt;li&gt;0.98  1992.9.29&lt;/li&gt;
  &lt;li&gt;0.99  1992.12.13&lt;/li&gt;
  &lt;li&gt;1.0   1994.3.14 Linux1.0版本内核发布，使用它的用户越来越多，而且Linux系统的核心开发队伍也建起来了。&lt;/li&gt;
  &lt;li&gt;1.2   1995.3.7&lt;/li&gt;
  &lt;li&gt;2.0   1996.2.9&lt;/li&gt;
  &lt;li&gt;2.2   1999.1.26&lt;/li&gt;
  &lt;li&gt;2.4   2001.1.4 Linux2.4.0版本内核发布。&lt;/li&gt;
  &lt;li&gt;2.6.x 2003-12 2011-05&lt;/li&gt;
  &lt;li&gt;3.x   2011-06 2015-02&lt;/li&gt;
  &lt;li&gt;4.x   2015-04 2018-12&lt;/li&gt;
  &lt;li&gt;5.x   2019-03&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;http版本差异&quot;&gt;HTTP版本差异&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;HTTP/0.9 (1991)
    &lt;ul&gt;
      &lt;li&gt;只支持GET、无协议头、无图片的HTML&lt;/li&gt;
      &lt;li&gt;连接用完立即关闭、无错误码&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP/1.0 (1992-1996)
    &lt;ul&gt;
      &lt;li&gt;请求与响应支持头域&lt;/li&gt;
      &lt;li&gt;响应对象以一个响应状态行开始&lt;/li&gt;
      &lt;li&gt;响应对象不只限于超文本&lt;/li&gt;
      &lt;li&gt;开始支持客户端通过POST方法向Web服务器提交数据，支持GET、HEAD、POST方法&lt;/li&gt;
      &lt;li&gt;支持长连接（但默认还是使用短连接），缓存机制，以及身份认证&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP/1.1 (1997-1999)
    &lt;ul&gt;
      &lt;li&gt;keepalive连接&lt;/li&gt;
      &lt;li&gt;chunked编码传输&lt;/li&gt;
      &lt;li&gt;字节范围请求，断点续传&lt;/li&gt;
      &lt;li&gt;请求流水线，同时交叉请求&lt;/li&gt;
      &lt;li&gt;请求消息和响应消息都应支持Host头域&lt;/li&gt;
      &lt;li&gt;增加了OPTIONS,PUT, DELETE, TRACE, CONNECT方法&lt;/li&gt;
      &lt;li&gt;HTTP/1.1在1.0的基础上加入了一些cache的新特性，引入了实体标签，一般被称为e-tags，新增更为强大的Cache-Control头。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HTTP/2.0 (2012-2014)
    &lt;ul&gt;
      &lt;li&gt;多路复用（二进制分帧）&lt;/li&gt;
      &lt;li&gt;头部压缩&lt;/li&gt;
      &lt;li&gt;随时复位&lt;/li&gt;
      &lt;li&gt;Server PUSH&lt;/li&gt;
      &lt;li&gt;优先权依赖&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SPDY 协议
    &lt;ul&gt;
      &lt;li&gt;2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。
这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ssltls历史&quot;&gt;SSL/TLS历史&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。&lt;/li&gt;
  &lt;li&gt;1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。&lt;/li&gt;
  &lt;li&gt;1996年，SSL 3.0版问世，得到大规模应用。&lt;/li&gt;
  &lt;li&gt;1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。&lt;/li&gt;
  &lt;li&gt;2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。&lt;/li&gt;
  &lt;li&gt;目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。
TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;ssltls简介&quot;&gt;SSL/TLS简介&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;SSL：（Secure Socket Layer，安全套接字层），位于可靠的面向连接的网络层协议和应用层协议之间的一种协议层。SSL通过互相认证、使用数字签名确保完整性、使用加密确保私密性，以实现客户端和服务器之间的安全通讯。该协议由两层组成：SSL记录协议和SSL握手协议。&lt;/li&gt;
  &lt;li&gt;TLS：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS记录协议和TLS握手协议。&lt;/li&gt;
  &lt;li&gt;SSL是Netscape开发的专门用户保护Web通讯的，目前版本为3.0。最新版本的TLS 1.0是IETF(工程任务组)制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本。两者差别极小，可以理解为SSL 3.1，它是写入了RFC的。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kb.cnblogs.com/page/197396/&quot;&gt;https://kb.cnblogs.com/page/197396/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mitm攻击&quot;&gt;MITM攻击&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;理解清楚中间人攻击（Man-in-the-MiddleAttack，简称“MITM攻击”）也就理解了HTTPS。&lt;/li&gt;
  &lt;li&gt;中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;https加密原理&quot;&gt;HTTPS加密原理&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;各个操作系统或浏览器提前内置或缓存了合法CA机构的公钥&lt;/li&gt;
  &lt;li&gt;服务器提交相关信息给CA机构&lt;/li&gt;
  &lt;li&gt;CA机构生成该服务器对应的私钥+证书（包含服务器公钥、数字签名等）&lt;/li&gt;
  &lt;li&gt;客户端发起请求到服务器，服务器返回CA机构生成的证书&lt;/li&gt;
  &lt;li&gt;客户端用提前内置的CA机构的公钥解密该证书，并验证该证书是否合法&lt;/li&gt;
  &lt;li&gt;验证证书合法后，从证书中提取服务器的公钥，开始SSL/TLS交互&lt;/li&gt;
  &lt;li&gt;其他方便理解的总结
    &lt;ul&gt;
      &lt;li&gt;引入CA之后，重点是有2个公钥：自己服务器的公钥、CA机构的公钥&lt;/li&gt;
      &lt;li&gt;当客户端收到证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。&lt;/li&gt;
      &lt;li&gt;然后用证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。&lt;/li&gt;
      &lt;li&gt;客户端验证证书的合法性，包括：
        &lt;ul&gt;
          &lt;li&gt;证书是否过期&lt;/li&gt;
          &lt;li&gt;发行服务器证书的CA是否可靠&lt;/li&gt;
          &lt;li&gt;本地CA公钥是否能正确解开证书&lt;/li&gt;
          &lt;li&gt;服务器证书上的域名是否和服务器的实际域名相匹配&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;第三方攻击者能否让自己的证书显示出来的信息也是服务端呢&quot;&gt;第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？&lt;/h4&gt;
&lt;p&gt;-（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名&lt;/p&gt;

&lt;h4 id=&quot;ios-面试题什么是中间人攻击如何避免&quot;&gt;iOS 面试题·什么是中间人攻击？如何避免？&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;客户端不要轻易信任证书&lt;/li&gt;
  &lt;li&gt;App可以提前预埋证书在本地&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/210c296eb836&quot;&gt;https://www.jianshu.com/p/210c296eb836&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;理解HTTPS &lt;a href=&quot;http://www.52im.net/forum.php?mod=viewthread&amp;amp;tid=1890&amp;amp;highlight=https&quot;&gt;http://www.52im.net/forum.php?mod=viewthread&amp;amp;tid=1890&amp;amp;highlight=https&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 29 Jun 2020 15:42:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/06/29/HTTP-HTTPS.html</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF/2020/06/29/HTTP-HTTPS.html</guid>
        
        <category>网络</category>
        
        
        <category>技术</category>
        
      </item>
    
  </channel>
</rss>
