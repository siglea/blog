---
layout: post
title:  "DotDot3"
date:   2020-06-30 17:06:00 +0900
comments: true
tags:
- 数据结构与算法
- BigData
- 分布式
categories:
- 技术
---
#### Java内存泄露
- 非静态内部类引用了外部类，类似循环引用。使用静态内部类解决该问题。

#### 分布式垃圾回收DGC？
- 分布式垃圾回收。RMI使用DGC来做自动垃圾回收，因为RMI包含了跨虚拟机的远程对象的引用，
    垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。

#### 请对比下 volatile 对比 Synchronized 的异同。
- Synchronized 既能保证可见性，又能保证原子性，而 volatile 只能保证可见性，无法保证原子性。
- ThreadLocal 和 Synchonized 都用于解决多线程并发访问，防止任务在共享资源上产生冲突。但是Thread Local 与 Synchronized 有本质的区别。 
    - Synchronized 用于实现同步机制，是利用锁的机制使变量或代码块在某一时该只能被一个线程访问，是一种“以时间换空间”的方式。
    - 而ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，根除了对变量的共享，是一种“以空间换时间”的方式。 
    
#### 请谈谈 ThreadLocal 是怎么解决并发安全的？
- ThreadLocal 这是Java提供的一种保存线程私有信息的机制，因为其在整个线程生命周期内有效，所以可以方便地在一个线程关联的不同业务模块之间传递信息，
    比如事务, Cookie等上下文相关信息。 ThreadLocal 为每一个线程维护变量的副本，把共享数据的可见范围限制在同一个线程之内，其实现原理是，在ThreadLocal 类中有一个Map ，用于存储每一个线程的变量的副本。
    
#### Mybatis是否支持延迟加载?如果支持，它的实现原理是什么？
1 .Mybatis仅支持association关联对象和collection关联集合对象的延迟 
加载，association指的就是一对一，collection指的就是一对多查询。在 
Mybatis配置文件中，可以配置是否启用延迟加载 
lazyLoadingEnabled=true|false 〇
2.它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法 
时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke〇 
方法发现a.getB〇是null值，那么就会单独发送事先保存好的查询关联B 
对象的sql，把B查询上来，然后调用fsetB(b)l，于是a的对象b属 
性就有值了，接着完成|a.getB() .getNamet)]方法的调用。这就是延迟 
加载的基本原理。