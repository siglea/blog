---
layout: post
title:  "Java基础"
date:   2020-06-17 21:25:00 +0900
comments: true
tags:
- Java
categories:
- 技术
---
#### 基础
1. Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线
程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入(CAS)的开销，看起
来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级
锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换
ThreadID 的时候依赖一次 CAS 原子指令(由于一旦出现多线程竞争的情况就必须撤销偏向锁，所
以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗)。上面说过，轻
量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进
一步提高性能。
1. 很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要
   在子线程结束后再结束，这时候就要用到 join() 方法。

#### Java内存泄露
- 非静态内部类引用了外部类，类似循环引用。使用静态内部类解决该问题。

#### 分布式垃圾回收DGC？
- 分布式垃圾回收。RMI使用DGC来做自动垃圾回收，因为RMI包含了跨虚拟机的远程对象的引用，
    垃圾回收是很困难的。DGC使用引用计数算法来给远程对象提供自动内存管理。

#### 请对比下 volatile 对比 Synchronized 的异同。
- Synchronized 既能保证可见性，又能保证原子性，而 volatile 只能保证可见性，无法保证原子性。
- ThreadLocal 和 Synchonized 都用于解决多线程并发访问，防止任务在共享资源上产生冲突。但是Thread Local 与 Synchronized 有本质的区别。 
    - Synchronized 用于实现同步机制，是利用锁的机制使变量或代码块在某一时该只能被一个线程访问，是一种“以时间换空间”的方式。
    - 而ThreadLocal 为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，根除了对变量的共享，是一种“以空间换时间”的方式。 
    
#### 请谈谈 ThreadLocal 是怎么解决并发安全的？
- ThreadLocal 这是Java提供的一种保存线程私有信息的机制，因为其在整个线程生命周期内有效，所以可以方便地在一个线程关联的不同业务模块之间传递信息，
  比如事务, Cookie等上下文相关信息。 ThreadLocal 为每一个线程维护变量的副本，把共享数据的可见范围限制在同一个线程之内，其实现原理是，在ThreadLocal 类中有一个Map ，用于存储每一个线程的变量的副本。
  ThreadLocal 注意需要自己remove，否则可能发生泄漏。
    

#### Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception
1. Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。
1. Exception 又有两个分支，一个是运行时异常 RuntimeException，一个是CheckedException。

#### 序列化 ID
Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，
这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。但在现实应用中，
就可能要求在 JVM 停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。
Java 对象序列化就能够帮助我们实现该功能。
 使用 Java 对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装
 成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对
 象序列化不会关注类中的静态变量。
 除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，
 都会用到对象序列化。Java 序列化 API 为处理对象序列化提供了一个标准机制，该 API 简单易用。
 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个
 类的序列化 ID 是否一致(就是 private static final long serialVersionUID)

#### 线程间共享
线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤: 1. 首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。
2. 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。

#### Iterater 和 ListIterator 之间有什么区别?
(1)我们可以使用 Iterator 来遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。 (2)Iterator 只可以向前遍历，而 LIstIterator 可以双向遍历。
(3)ListIterator 从 Iterator 接口继承，然后添加了一些额外的功能，比如添加一个元素、替 换一个元素、获取前面或后面元素的索引位置。

#### 什么是 Java 内存模型
- Java 内存模型定义了一种多线程访问 Java 内存的规范。Java 内存模型要完 整讲不是这里几句话能说清楚的，我简单总结一下 Java 内存模型的几部分内 容:
 - Java 内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间 共享的变量，是存储在主内存中的，每次 Java 线程用到这些主内存中的变量 的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份
 拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中 的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 
 - 定义了几个原子操作，用于操作主内存和工作内存中的变量
 - 定义了 volatile 变量的使用规则 
 - happens-before，即先行发生原则，定义了操作 A 必然先行发生于操作 B 的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流 后面的代码、一个释放锁 unlock 的动作一定先行发生于后面对于同一个锁进 行锁定 lock 的动作等等，只要符合这些规则，则不需要额外做同步措施，如 果某段代码不符合所有的 happens-before 规则，则这段代码一定是线程非 安全的
- 8种内存间操作
    - lock：把一个变量标志为一条线程独占的状态
    - unlock：把一个处于锁定状态的变量释放出来，释放之后的变量才能被其他线程锁定
    
    - read：把一个变量值从主内存传输到线程的工作内存，以便load
    - load：把read操作从主内存得到的变量值放入到工作内存的变量副本中
    
    - write：把store操作从工作内存得到的变量的值，放到主内存的变量中
    - store：把工作内存的变量值传到主内存，以便write
    
    - use：把工作内存变量值传递给执行引擎
    - assign：将执行引擎值传递给工作内存变量值

Pojo(plian ordinary普通的; 平常的; java object)

#### HashMap 为啥size是2的倍数，1.8比1.7做了哪些优化？
JDK1.7 VS JDK1.8 比较
JDK1.8主要解决或优化了一下问题：
resize 扩容优化
引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考
解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。

#### Seata 的 Demo