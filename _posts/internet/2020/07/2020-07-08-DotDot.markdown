---
layout: post
title:  "DotDot"
date:   2020-07-08 15:18:00 +0900
comments: true
tags:
- java
categories:
- 技术
---
#### 蚂蚁金服
- ArrayList的扩容方式和扩容时机
    - 初始化
        ArrayList的底层是一个动态数组，ArrayList首先会对传进来的初始化参数initalCapacity进行判断
        如果参数等于0，则将数组初始化为一个空数组，
        如果不等于0，将数组初始化为一个容量为10的数组。
    - 扩容时机
        当数组的大小大于初始容量的时候(比如初始为10，当添加第11个元素的时候)，就会进行扩容，新的容量为旧的容量的1.5倍。
    - 扩容方式
       扩容的时候，会以新的容量建一个原数组的拷贝，修改原数组，指向这个新数组，原数组被抛弃，会被GC回收。
- <https://www.cnblogs.com/silyvin/p/10223910.html>

#### volatile（保证可见性、禁止重排、无法实现原子性）
- 指令重排只会保证串行语义的执行一致性(单线程) 并不会关心多线程间的语义一致性

### CAS & Unsafe
- CAS的全称为Compare-And-Swap，它是一条CPU并发原语。它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。
- CAS并发原语体现在JAVA语言中就是sum.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条CPU的原子指令，不会造成所有的数据不一致问题。
- CAS只能保证一个共享变量的原子性
- CAS自旋

```shell
# 我们可以看到getAndAddInt方法执行时，有个do while
# unsafe.getAndAddInt
public final int getAndAddInt(Object var1, long var2, int var4){
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
    return var5;
}

# 如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会能CPU带来很大的开锁。
```

- CAS造成的ABA问题用版本号解决

```shell
# （旧值，新值）
atomicReference.compareAndSet(101, 100);

# AtomicStampedReference 以时间戳做为版本号解决ABA的问题
public boolean compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) {
```

#### Exchanger
- 允许在并发任务之间交换数据。具体来说，Exchanger类允许在两个线程之间定义同步点。当两个线程都到达同步点时，他们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，第二个线程的数据结构进入到第一个线程中
- 例子模拟一个队列中数据的交换使用的场景：
    - 线程A往队列中存入数据
    - 线程B从队列中消耗数据
    - 当线程A存满的时候
    - 才交换给线程B
    - 当线程B消耗完成之后才交换给线程A。
    - 线程A、B的生产和消耗的速率有可能不同
    - 对方线程调用exchange之前，另一个线程执行到exchange会阻塞

#### JVM 对 Java 的原生锁做了哪些优化？
- 一种优化是使用自旋锁，即在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。

- 现代 JDK 中还提供了三种不同的 Monitor 实现，也就是三种不同的锁：
    - 偏向锁（Biased Locking）
    - 轻量级锁
    - 重量级锁,这三种锁使得 JDK 得以优化 Synchronized 的运行，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这就是锁的升级、降级。
- 当没有竞争出现时，默认会使用偏向锁。
    - JVM 会利用 CAS 操作，在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁，因为在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。
- 如果有另一线程试图锁定某个被偏斜过的对象，JVM 就撤销偏斜锁，切换到轻量级锁实现。
- 轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁(自旋锁)；否则，进一步升级为重量级锁。

####  ReadWriteLock 
```shell 
final boolean tryWriteLock() {
            Thread current = Thread.currentThread();
            int c = getState();
            if (c != 0) {
                int w = exclusiveCount(c);
                if (w == 0 || current != getExclusiveOwnerThread())
                    return false;
                if (w == MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
            }
            if (!compareAndSetState(c, c + 1))
                return false;
            setExclusiveOwnerThread(current);
            return true;
        }

        /**
         * Performs tryLock for read, enabling barging in both modes.
         * This is identical in effect to tryAcquireShared except for
         * lack of calls to readerShouldBlock.
         */
        final boolean tryReadLock() {
            Thread current = Thread.currentThread();
            for (;;) {
                int c = getState();
                if (exclusiveCount(c) != 0 &&
                    getExclusiveOwnerThread() != current)
                    return false;
                int r = sharedCount(c);
                if (r == MAX_COUNT)
                    throw new Error("Maximum lock count exceeded");
                if (compareAndSetState(c, c + SHARED_UNIT)) {
                    if (r == 0) {
                        firstReader = current;
                        firstReaderHoldCount = 1;
                    } else if (firstReader == current) {
                        firstReaderHoldCount++;
                    } else {
                        HoldCounter rh = cachedHoldCounter;
                        if (rh == null || rh.tid != getThreadId(current))
                            cachedHoldCounter = rh = readHolds.get();
                        else if (rh.count == 0)
                            readHolds.set(rh);
                        rh.count++;
                    }
                    return true;
                }
            }
        }
```
####  面向对象的五大基本原则(solid)
- S单一职责SRP:Single-Responsibility Principle
     一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。
- O开放封闭原则OCP:Open-Closed Principle
     软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭
- L里氏替换原则LSP:Liskov-Substitution Principle
     子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。
- I接口隔离原则ISP:Interface-Segregation Principle
     使用多个小的接口,而不是一个大的总接口
- D依赖倒置原则DIP:Dependency-Inversion Principle
     依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。
     
#### 类什么时候才被初始化
- 创建类的实例，也就是new一个对象
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射（Class.forName("com.lyj.load")）
- 初始化一个类的子类（会首先初始化子类的父类）
- JVM启动时标明的启动类，即文件名和类名相同的那个类

#### ArrayList     
ArrayList创建时的大小为0；当加入第一个元素时，进行第一次扩容时，默认容量大小为10。
ArrayList每次扩容都以当前数组大小的1.5倍去扩容。
Vector创建时的默认大小为10。
Vector每次扩容都以当前数组大小的2倍去扩容。当指定了capacityIncrement之后，每次扩容仅在原先基础上增加capacityIncrement个单位空间。
ArrayList和Vector的add、get、size方法的复杂度都为O(1)，remove方法的复杂度为O(n)。
ArrayList是非线程安全的，Vector是线程安全的。

#### hashmap为什么初始容量是2的指数幂
1. hashmap在确定元素落在数组的位置的时候，计算方法是(n - 1) & hash，n为数组长度也就是初始容量 ，这是因为“取模”运算的消耗还是比较大的，那么如何保证(n - 1) & hash和hash%n的结果相同呢，当n为2的指数次幂时，会满足一个公式：(n - 1) & hash = hash % n，这样就可以用(n - 1) & hash的位运算来使计算更加高效。
2. 如果初始容量是奇数，那么（n-1)就为偶数，偶数2进制的结尾都是0，经过hash值&运算后末尾都是0，那么0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这样就会造成空间的浪费而且会增加hash冲突。
3. 只有是2的指数次幂的数字经过n-1之后，二进制肯定是  ...11111111  这样的格式，这种格式计算的位置的时候，完全是由产生的hash值类决定，而不受n-1 影响。这样会提高效率。比如要扩容了，2的幂次方*2，在二进制中比如4和8，代表2的2次方和3次方，他们的2进制结构相 似,比如 4和8   00000100    0000 1000   只是高位向前移了一位，这样扩容的时候，只需要判断高位hash,移动到之前位置的倍数就可以了，免去了重新计算位置的运算。并且这样可以保证(n - 1) & hash得到的存储位置是在hashmap的length之内的,也就是n之内。因为最大也就是hash值也全是...1111111

#### SpringBoot Start
1. 引入该Start相关依赖
2. 查找resources/META-INF/spring.factories下对应的XXXAutoConfigure
3. 根据Condition自己加装相关的Bean
    - @ConditionalOnBean:当容器中有指定的Bean的条件下  
    - @ConditionalOnClass：当类路径下有指定的类的条件下  
    - @ConditionalOnExpression:基于SpEL表达式作为判断条件  
    - @ConditionalOnJava:基于JVM版本作为判断条件  
    - @ConditionalOnJndi:在JNDI存在的条件下查找指定的位置  
    - @ConditionalOnMissingBean:当容器中没有指定Bean的情况下  
    - @ConditionalOnMissingClass:当类路径下没有指定的类的条件下  
    - @ConditionalOnNotWebApplication:当前项目不是Web项目的条件下  
    - @ConditionalOnProperty:指定的属性是否有指定的值  
    - @ConditionalOnResource:类路径下是否有指定的资源  
    - @ConditionalOnSingleCandidate:当指定的Bean在容器中只有一个，或者在有多个Bean的情况下，用来指定首选的Bean
    - @ConditionalOnWebApplication:当前项目是Web项目的条件下  

<https://www.cnblogs.com/yuansc/p/9088212.html>

#### Spring中解决循环依赖为什么要用三级缓存
- Bean创建有3步
    1. 初始化init,分配内存空间，此时在singletonFactories完成
    2. 注入各种属性，此时在earlySingletonObjects中
    3. 完美的bean最终会在singletonObjects中
- 举例
    - A与B循环依赖，A初始化经过第1、2步，在第2步发现依赖B
    - 此时，触发B的初始化进入第1步，如果再进入第2步，会发现依赖A了，所以此时B只能在第1步
    - 把B的第1步，不完美的B注入给A，先完成A的注入，让A进入第3步
    - 然后，再完成B的完美初始化


#### Netty
- <https://www.cnblogs.com/xiaoyangjia/p/11526197.html>