---
layout: post
title:  "2PC 3PC"
date:   2019-11-12 11:25:00 +0900
comments: true
tags:
- 数据库
- 分布式
categories:
- 技术
---
#### MySQL实现事务ACID特性的方式总结如下：
- 原子性：使用 undo log来实现，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。
- 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。
- 隔离性：通过锁以及MVCC来实现。
- 一致性：通过回滚、恢复以及并发情况下的隔离性，从而实现一致性。

#### 在分布式服务中，经常出现直接或间接调用数据库，此时的事务保证如何进行？
- 解决此问题，唯一的方法就是引入"中间人"事务管理器（Transaction Manager，简称 TM，也被称之为“协调者”）
- 无论哪种方案，都需要制定"协议"，由各个数据库配合实现（资源管理器 Resource Manager，简称 RM，也被称之为“参与者”）
- 无论是 2PC 还是 3PC 都不能保证分布式系统中的数据 100% 一致，只能尽可能的做到

#### 2PC、3PC
- 二阶段提交（Two-phase Commit，简称2PC）
    - 步骤：Prepare（实际上是3PC的PreCommit）、Commit（DoCommit）
- 三阶段提交（Three-phase Commit，简称3PC）
    - 步骤：CanCommit(新增机制，尝试获取锁)、PreCommit、DoCommit
- 区别
    1. 超时机制
        - 2PC由于RM没有超时机制会产生各种阻塞问题，导致即使失败了RM的事务也不能回滚
        - 3PC引入RM超时机制，在第二阶段PreCommit超时回滚，第三阶段DoCommit超时提交
    1. 相较于2PC而言，3PC多设置了一个缓冲阶段尽可能保证了在最后提交阶段之前各参与节点的状态是一致的。
    1. 由于多个参与者最终Commit提交发生的意外(网络或者协调者故障)，还是会产生不一致，无法彻底解决
    
#### 常用分布式事务框架
- X/Open DTP(Distributed Transaction Process)模型与XA(eXtended Architecture)
    - DTP模型里面定义了XA接口，TM 和 RM 通过XA接口进行双向通信（这也是XA的主要作用， 除此之外，XA还对两阶段提交协议进行了部分优化），例如：TM通知RM提交事务或者回滚事务，RM把提交结果通知给TM。XA 的全称是eXtended Architecture，它是一个分布式事务协议，它通过二阶段提交协议保证强一致性。
    - 基于XA协议实现的分布式事务是强一致性的分布式事务，典型应用场景如JAVA中有关分布式事务的规范如JTA（Java Transaction API）和JTS（Java Transaction Service）中就涉及到了XA。
- Seata（Simple Extensible Autonomous Transaction Architecture，一站式分布式事务解决方案）与AT模式
    - AT（Automatic Transaction）模式是基于XA事务演进而来，核心是对业务无侵入，是一种改进后的两阶段提交，需要数据库支持。
    - 引入补偿机制（最终一致性）
    - Seata 会有 4 种分布式事务解决方案，分别是 AT 模式、TCC(Try、Commit、Cancel) 模式、Saga 模式和 XA 模式。
- TCC(Try、Commit、Cancel) 模式
  - 锁定，提交/回滚
  - XA两阶段提交是资源层面的，而TCC实际上把资源层面二阶段提交上提到了业务层面来实现，有效了的避免了XA两阶段提交占用资源锁时间过长导致的性能低下问题。TCC也没有AT模式中的全局行锁，所以性能也会比AT模式高很多。不过，TCC模式对业务代码有很大的侵入性，主业务服务和从业务服务都需要进行改造，从业务方改造成本更高。
- Saga 算法（https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf）于 1987 年提出，是一种异步的分布式事务解决方案。其理论基础在于，其假设所有事件按照顺序推进，总能达到系统的最终一致性，因此 Saga需要服务分别定义提交接口以及补偿接口，当某个事务分支失败时，调用其它的分支的补偿接口来进行回滚。
  在Saga模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。
- 本地消息表
- 消息事务 RocketMQ(阿里开源)
- 最大努力通知型（Best-effort Delivery）

#### 分布式事务的取舍
- 严格的ACID事务对隔离性的要求很高，在事务执行中必须将所有的资源锁定，对于长事务来说，整个事务期间对数据的独占，将严重影响系统并发性能。因此，在高并发场景中，对ACID的部分特性进行放松从而提高性能，这便产生了BASE柔性事务。柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。通过放宽对强一致性要求，来换取系统吞吐量的提升。另外提供自动的异常恢复机制，可以在发生异常后也能确保事务的最终一致。
- 柔性事务需要应用层进行参与，因此这类分布式事务框架一个首要的功能就是怎么最大程度降低业务改造成本，然后就是尽可能提高性能（响应时间、吞吐），最好是保证隔离性。
- 当然如果我们要自己设计一个分布式事务框架，还需要考虑很多其它特性，在明确目标场景偏好后进行权衡取舍，这些特性包括但不限于以下：     
    - 业务侵入性（基于注解、XML，补偿逻辑）；
    - 隔离性（写隔离/读隔离/读未提交，业务隔离/技术隔离）；
    - TM/TC部署形态（单独部署、与应用部署一起）；
    - 错误恢复（自动恢复、手动恢复）；
    - 性能（回滚的概率、付出的代价,响应时间、吞吐）；
    - 高可用（注册中心、数据库）；
    - 持久化（数据库、文件、多副本一致算法）；
    - 同步/异步（2PC执行方式）；
    - 日志清理(自动、手动)；
    - ......
- 分布式事务一直是业界难题，难在于CAP定理，在于分布式系统8大错误假设 ，在于FLP不可能原理 ，在于我们习惯于单机事务ACID做对比。无论是数据库领域XA，还是微服务下AT、TCC、Saga、本地消息表、事务消息、最大努力通知等方案，都没有完美解决分布式事务问题，它们不过是各自在性能、一致性、可用性等方面做取舍，寻求某些场景偏好下的权衡。

#### FLP Impossibility（FLP不可能性 Fischer, Lynch and Patterson）
在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！
<https://www.cnblogs.com/firstdream/p/6585923.html>

#### 参考 
- <https://zhuanlan.zhihu.com/p/91263461>
- <https://mp.weixin.qq.com/s/ek3ycMJ1qbMXtMRAvTQDZg>
- <https://mp.weixin.qq.com/s/As8QpwpJvwAViZ2otiZnPg>