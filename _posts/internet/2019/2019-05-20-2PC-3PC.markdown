---
layout: post
title:  "2PC 3PC"
date:   2019-11-12 11:25:00 +0900
comments: true
tags:
- 数据库
- 分布式
categories:
- 技术
---
#### 分布式事务精华
1. X/Open DTP模型体系 Distribution Transaction Process
    - XA模式 eXtend Architecture
1. Seata体系 Simple Extensible Autonomous Transaction Architecture
    - AT模式，AT模式基于本地事务的特性，通过拦截并解析 SQL 的方式，记录自定义的回滚日志，从而打破 XA 协议阻塞性的制约，在一致性、性能、易用性三个方面取得一定的平衡：在达到确定一致性（非最终一致）的前提下，即保障一定的性能，又能完全不侵入业务。在很多应用场景下，Seata的AT模式都能很好地发挥作用，把应用的分布式事务支持成本降到极低的水平。
    - TCC模式，先扣下资源，又业务方编写commit或cancel代码，对业务侵入性强，要求幂等。由于是预扣机制，因此需要有补偿方案。长事务解决方案。
    - Saga模式，长事务解决方案，有补偿机制，其理论基础在于，其假设所有事件按照顺序推进，总能达到系统的最终一致性，因此 Saga需要服务分别定义提交接口以及补偿接口，当某个事务分支失败时，调用其它的分支的补偿接口来进行回滚。
        - Saga模式所具备的优势有：一阶段提交本地数据库事务，无锁，高性能；参与者可以采用事务驱动异步执行，高吞吐；补偿服务即正向服务的“反向”，易于理解、易于实现；不过，Saga 模式由于一阶段已经提交本地数据库事务，且没有进行“预留”动作，所以不能保证隔离性。
        - 由于Saga不保证隔离性，所以我们在业务设计的时候需要做到“宁可长款，不可短款”的原则，长款是指在出现差错的时候站在我方的角度钱多了的情况，钱少了则是短款，因为如果长款可以给客户退款，而短款则可能钱追不回来了，也就是说在业务设计的时候，一定是先扣客户帐再入帐，如果因为隔离性问题造成覆盖更新，也不会出现钱少了的情况。
1. 本地消息表，eBay方案，事务发起方，以消息表的方式记录后续业务方处理方的处理状态，然后发送消息出去，消费者执行完毕回传结果，如果长时间没有结果发起方就轮训本地消息表。超时转人工。
1. 消息事务，采用本地消息表方案和采用RocketMQ事务消息方案的对比，其实，我们不难发现RocketMQ的这种事务方案就是对本地消息表的封装，其MQ内部实现了本地消息表的功能，其他方面的协议基本与本地消息表一致。
1. 最大努力通知型（Best-effort Delivery），支付宝、微信方案，用于跨系统的调用。多次推送+查询接口。
1. 各种区别
    - TCC模型中的主业务服务相当于DTP模型中AP，从业务服务相当于DTP模型中的RM，两者也都有一个事务管理器；TCC模型中从业务服务器所提供的Try/Commit/Cancel接口相当于DTP模型中RM提供的Prepare/Commit/Rollback接口。
    - XA 方案的 RM 是放在数据库层的，它依赖了数据库的 XA 驱动程序。而上图（右），Seata 的 RM 实际上是已中间件的形式放在应用层，不用依赖数据库对协议的支持，完全剥离了分布式事务方案对数据库在协议支持上的要求。
    - TCC分布式事务模型相对于 XA 等传统模型，其特征在于它不依赖资源管理器（RM）对分布式事务的支持，而是通过对业务逻辑的分解来实现分布式事务。
    - XA两阶段提交是资源层面的，而TCC实际上把资源层面二阶段提交上提到了业务层面来实现，有效了的避免了XA两阶段提交占用资源锁时间过长导致的性能低下问题。TCC也没有AT模式中的全局行锁，所以性能也会比AT模式高很多。不过，TCC模式对业务代码有很大的侵入性，主业务服务和从业务服务都需要进行改造，从业务方改造成本更高。
    - Saga（易用、高性能）；AT（易用、隔离性）；TCC（性能、隔离性）
    - 基于本地消息表的分布式事务方案就介绍到这里了，本地消息表的方案的优点是建设成本比较低，其虽然实现了可靠消息的传递确保了分布式事务的最终一致性，其实它也有一些缺陷：
      本地消息表与业务耦合在一起，难以做成通用性，不可独立伸缩。本地消息表是基于数据库来做的，而数据库是要读写磁盘IO的，因此在高并发下是有性能瓶颈的。
    - MQ在本地消息表或者消息事务方案中起到了协调者的作用，Transaction Coordinator（TC）：事务协调器
    
#### MySQL实现事务ACID特性的方式总结如下：
- 原子性：使用 undo log来实现，如果事务执行过程中出错或者用户执行了rollback，系统通过undo log日志返回事务开始的状态。
- 持久性：使用 redo log来实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复。
- 隔离性：通过锁以及MVCC来实现。
- 一致性：通过回滚、恢复以及并发情况下的隔离性，从而实现一致性。

#### 在分布式服务中，经常出现直接或间接调用数据库，此时的事务保证如何进行？
- 解决此问题，唯一的方法就是引入"中间人"事务管理器（Transaction Manager，简称 TM，也被称之为“协调者”）
- 无论哪种方案，都需要制定"协议"，由各个数据库配合实现（资源管理器 Resource Manager，简称 RM，也被称之为“参与者”）
- 无论是 2PC 还是 3PC 都不能保证分布式系统中的数据 100% 一致，只能尽可能的做到

#### 2PC、3PC
- 二阶段提交（Two-phase Commit，简称2PC）
    - 步骤：Prepare（实际上是3PC的PreCommit）、Commit（DoCommit）
- 三阶段提交（Three-phase Commit，简称3PC）
    - 步骤：CanCommit(新增机制，尝试获取锁)、PreCommit、DoCommit
- 区别
    1. 超时机制
        - 2PC由于RM没有超时机制会产生各种阻塞问题，导致即使失败了RM的事务也不能回滚
        - 3PC引入RM超时机制，在第二阶段PreCommit超时回滚，第三阶段DoCommit超时提交
    1. 相较于2PC而言，3PC多设置了一个缓冲阶段尽可能保证了在最后提交阶段之前各参与节点的状态是一致的。
    1. 由于多个参与者最终Commit提交发生的意外(网络或者协调者故障)，还是会产生不一致，无法彻底解决
    
#### 常用分布式事务框架
- X/Open DTP(Distributed Transaction Process)模型与XA(eXtended Architecture)
    - DTP模型里面定义了XA接口，TM 和 RM 通过XA接口进行双向通信（这也是XA的主要作用， 除此之外，XA还对两阶段提交协议进行了部分优化），例如：TM通知RM提交事务或者回滚事务，RM把提交结果通知给TM。XA 的全称是eXtended Architecture，它是一个分布式事务协议，它通过二阶段提交协议保证强一致性。
    - 基于XA协议实现的分布式事务是强一致性的分布式事务，典型应用场景如JAVA中有关分布式事务的规范如JTA（Java Transaction API）和JTS（Java Transaction Service）中就涉及到了XA。
- Seata（Simple Extensible Autonomous Transaction Architecture，一站式分布式事务解决方案）是2019年1月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案。 Seata 会有 4 种分布式事务解决方案，分别是 AT 模式、TCC(Try、Commit、Cancel) 模式、Saga 模式和 XA 模式。
    - AT（Automatic Transaction）模式是基于XA事务演进而来，核心是对业务无侵入，是一种改进后的两阶段提交，需要数据库支持。
      解析SQL，提取元数据，保存before image，执行SQL，保存after image，生成行锁。需要回滚就比对数据版本号，一直就自动回滚，不一致人工处理。
    - TCC(Try、Commit、Cancel) 模式
      - 锁定，提交/回滚。业务实现回滚代码也就是cancel回调实现。
      - XA两阶段提交是资源层面的，而TCC实际上把资源层面二阶段提交上提到了业务层面来实现，有效了的避免了XA两阶段提交占用资源锁时间过长导致的性能低下问题。TCC也没有AT模式中的全局行锁，所以性能也会比AT模式高很多。不过，TCC模式对业务代码有很大的侵入性，主业务服务和从业务服务都需要进行改造，从业务方改造成本更高。
    - Saga 算法（https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf）于 1987 年提出，是一种异步的分布式事务解决方案。其理论基础在于，其假设所有事件按照顺序推进，总能达到系统的最终一致性，因此 Saga需要服务分别定义提交接口以及补偿接口，当某个事务分支失败时，调用其它的分支的补偿接口来进行回滚。
      在Saga模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。
    - XA 模式
    - 参考 <https://mp.weixin.qq.com/s/67NvEVljnU-0-6rb7MWpGw> 
    - Seata实战入门 <https://mp.weixin.qq.com/s/-iEAfrhuObMd9W5SpHXDtg>
    - 官网文档 <https://seata.io/zh-cn/docs/overview/what-is-seata.html>
- 本地消息表
- 消息事务 RocketMQ(阿里开源)
- 最大努力通知型（Best-effort Delivery）

#### TCC异常控制
- 在有了一套完备的 TCC 接口之后，是不是就真的高枕无忧了呢？答案是否定的。在微服务架构下，很有可能出现网络超时、重发，机器宕机等一系列的异常情况。一旦遇到这些 情况，就会导致我们的分布式事务执行过程出现异常，最常见的主要是空回滚、幂等、悬挂。因此，在TCC接口设计中还需要处理好这三个问题。
Cancel接口设计时需要允许空回滚。在Try接口因为丢包时没有收到，事务管理器会触发回滚，这时会触发Cancel接口，这时Cancel执行时发现没有对应的事务 XID或主键时，需要返回回滚成功。让事务服务管理器认为已回滚，否则会不断重试，而Cancel又没有对应的业务数据可以进行回滚。
- 幂等性的意思是对同一个系统使用同样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。因为网络抖动或拥堵可能会超时，事务管理器会对资源进行重试操作，所以很可能一个业务操作会被重复调用，为了不因为重复调用而多次占用资源，需要对服务设计时进行幂等控制，通常我们可以用事务XID或业务主键判重来控制。
- 悬挂的意思是Cancel比Try接口先执行，出现的原因是Try由于网络拥堵而超时，事务管理器生成回滚，触发Cancel接口，而最终又收到了Try接口调用，但是Cancel比Try先到。按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，则此时的Try接口不应该执行，否则会产生数据不一致，所以我们在Cancel空回滚返回成功之前先记录该条事务 XID或业务主键，标识这条记录已经回滚过，Try接口先检查这条事务XID或业务主键如果已经标记为回滚成功过，则不执行Try的业务操作。

#### 分布式事务的取舍
- 严格的ACID事务对隔离性的要求很高，在事务执行中必须将所有的资源锁定，对于长事务来说，整个事务期间对数据的独占，将严重影响系统并发性能。因此，在高并发场景中，对ACID的部分特性进行放松从而提高性能，这便产生了BASE柔性事务。柔性事务的理念则是通过业务逻辑将互斥锁操作从资源层面上移至业务层面。通过放宽对强一致性要求，来换取系统吞吐量的提升。另外提供自动的异常恢复机制，可以在发生异常后也能确保事务的最终一致。
- 柔性事务需要应用层进行参与，因此这类分布式事务框架一个首要的功能就是怎么最大程度降低业务改造成本，然后就是尽可能提高性能（响应时间、吞吐），最好是保证隔离性。
- 当然如果我们要自己设计一个分布式事务框架，还需要考虑很多其它特性，在明确目标场景偏好后进行权衡取舍，这些特性包括但不限于以下：     
    - 业务侵入性（基于注解、XML，补偿逻辑）；
    - 隔离性（写隔离/读隔离/读未提交，业务隔离/技术隔离）；
    - TM/TC部署形态（单独部署、与应用部署一起）；
    - 错误恢复（自动恢复、手动恢复）；
    - 性能（回滚的概率、付出的代价,响应时间、吞吐）；
    - 高可用（注册中心、数据库）；
    - 持久化（数据库、文件、多副本一致算法）；
    - 同步/异步（2PC执行方式）；
    - 日志清理(自动、手动)；
    - ......
- 分布式事务一直是业界难题，难在于CAP定理，在于分布式系统8大错误假设 ，在于FLP不可能原理 ，在于我们习惯于单机事务ACID做对比。无论是数据库领域XA，还是微服务下AT、TCC、Saga、本地消息表、事务消息、最大努力通知等方案，都没有完美解决分布式事务问题，它们不过是各自在性能、一致性、可用性等方面做取舍，寻求某些场景偏好下的权衡。

#### FLP Impossibility（FLP不可能性 Fischer, Lynch and Patterson）
在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！
<https://www.cnblogs.com/firstdream/p/6585923.html>

#### 分布式系统的8个谬误
<http://www.360doc.com/content/18/0715/15/11935121_770570455.shtml>
- 网络可靠
- 延迟为零。
- 带宽是无限的。
- 网络是安全的。
- 拓扑不会改变。
- “无所不能”的管理员。
- 传输成本为零。
- 网络是同构的。

#### 参考 
- 2PC和3PC原理 <https://zhuanlan.zhihu.com/p/91263461>
- 分布式事务科普 上<https://mp.weixin.qq.com/s/ek3ycMJ1qbMXtMRAvTQDZg>
- 分布式事务科普 下 ☆☆☆<https://mp.weixin.qq.com/s/As8QpwpJvwAViZ2otiZnPg>
- 实战案例 <https://springboot.io/t/topic/1658>
- 实战案例 <https://blog.csdn.net/hosaos/article/details/89136666>